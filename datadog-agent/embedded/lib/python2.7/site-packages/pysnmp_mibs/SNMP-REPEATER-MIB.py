#
# PySNMP MIB module SNMP-REPEATER-MIB (http://pysnmp.sf.net)
# ASN.1 source http://mibs.snmplabs.com:80/asn1/SNMP-REPEATER-MIB
# Produced by pysmi-0.0.7 at Sun Feb 14 00:28:55 2016
# On host bldfarm platform Linux version 4.1.13-100.fc21.x86_64 by user goose
# Using Python version 3.5.0 (default, Jan  5 2016, 17:11:52) 
#
( ObjectIdentifier, Integer, OctetString, ) = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
( OwnerString, ) = mibBuilder.importSymbols("IF-MIB", "OwnerString")
( NotificationGroup, ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
( ModuleIdentity, IpAddress, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, NotificationType, iso, Counter32, Gauge32, ObjectIdentity, TimeTicks, Bits, Unsigned32, Integer32, mib_2, ) = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "IpAddress", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "NotificationType", "iso", "Counter32", "Gauge32", "ObjectIdentity", "TimeTicks", "Bits", "Unsigned32", "Integer32", "mib-2")
( MacAddress, RowStatus, TextualConvention, TimeStamp, DisplayString, TestAndIncr, ) = mibBuilder.importSymbols("SNMPv2-TC", "MacAddress", "RowStatus", "TextualConvention", "TimeStamp", "DisplayString", "TestAndIncr")
snmpRptrMod = ModuleIdentity((1, 3, 6, 1, 2, 1, 22, 5)).setRevisions(("1993-09-01 00:00", "1992-10-01 00:00",))
if mibBuilder.loadTexts: snmpRptrMod.setLastUpdated('9609140000Z')
if mibBuilder.loadTexts: snmpRptrMod.setOrganization('IETF HUB MIB Working Group')
if mibBuilder.loadTexts: snmpRptrMod.setContactInfo('WG E-mail: hubmib@hprnd.rose.hp.com\n\n                Chair: Dan Romascanu\n               Postal: Madge Networks (Israel) Ltd.\n                       Atidim Technology Park, Bldg. 3\n                       Tel Aviv 61131, Israel\n                  Tel: 972-3-6458414, 6458458\n                  Fax: 972-3-6487146\n               E-mail: dromasca@madge.com\n\n               Editor: Kathryn de Graaf\n               Postal: 3Com Corporation\n                       118 Turnpike Rd.\n                       Southborough, MA 01772 USA\n                  Tel: (508)229-1627\n                  Fax: (508)490-5882\n               E-mail: kdegraaf@isd.3com.com')
if mibBuilder.loadTexts: snmpRptrMod.setDescription("Management information for 802.3 repeaters.\n\n           The following references are used throughout\n           this MIB module:\n\n           [IEEE 802.3 Std]\n               refers to IEEE 802.3/ISO 8802-3 Information\n               processing systems - Local area networks -\n               Part 3: Carrier sense multiple access with\n               collision detection (CSMA/CD) access method\n               and physical layer specifications (1993).\n\n           [IEEE 802.3 Mgt]\n               refers to IEEE 802.3u-1995, '10 Mb/s &\n               100 Mb/s Management, Section 30,'\n               Supplement to ANSI/IEEE 802.3.\n\n           The following terms are used throughout this\n           MIB module.  For complete formal definitions,\n           the IEEE 802.3 standards should be consulted\n           wherever possible:\n\n           System - A managed entity compliant with this\n           MIB, and incorporating at least one managed\n           802.3 repeater.\n\n           Chassis - An enclosure for one managed repeater,\n           part of a managed repeater, or several managed\n           repeaters.  It typically contains an integral\n           power supply and a variable number of available\n           module slots.\n\n           Repeater-unit - The portion of the repeater set\n           that is inboard of the physical media interfaces.\n           The physical media interfaces (MAUs, AUIs) may be\n           physically separated from the repeater-unit, or\n           they may be integrated into the same physical\n           package.\n\n           Trivial repeater-unit - An isolated port that can\n           gather statistics.\n\n           Group - A recommended, but optional, entity\n           defined by the IEEE 802.3 management standard,\n           in order to support a modular numbering scheme.\n           The classical example allows an implementor to\n           represent field-replaceable units as groups of\n           ports, with the port numbering matching the\n           modular hardware implementation.\n\n           System interconnect segment - An internal\n           segment allowing interconnection of ports\n           belonging to different physical entities\n           into the same logical manageable repeater.\n           Examples of implementation might be\n           backplane busses in modular hubs, or\n           chaining cables in stacks of hubs.\n           Stack - A scalable system that may include\n           managed repeaters, in which modularity is\n           achieved by interconnecting a number of\n           different chassis.\n\n           Module - A building block in a modular\n           chassis.  It typically maps into one 'slot';\n           however, the range of configurations may be\n           very large, with several modules entering\n           one slot, or one module covering several\n           slots.\n           ")
snmpDot3RptrMgt = MibIdentifier((1, 3, 6, 1, 2, 1, 22))
class OptMacAddr(OctetString, TextualConvention):
    displayHint = '1x:'
    subtypeSpec = OctetString.subtypeSpec+ConstraintsUnion(ValueSizeConstraint(0,0),ValueSizeConstraint(6,6),)
rptrBasicPackage = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 1))
rptrRptrInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 1, 1))
rptrGroupInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 1, 2))
rptrPortInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 1, 3))
rptrAllRptrInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 1, 4))
rptrMonitorPackage = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 2))
rptrMonitorRptrInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 2, 1))
rptrMonitorGroupInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 2, 2))
rptrMonitorPortInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 2, 3))
rptrMonitorAllRptrInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 2, 4))
rptrAddrTrackPackage = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 3))
rptrAddrTrackRptrInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 3, 1))
rptrAddrTrackGroupInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 3, 2))
rptrAddrTrackPortInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 3, 3))
rptrTopNPackage = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 4))
rptrTopNRptrInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 4, 1))
rptrTopNGroupInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 4, 2))
rptrTopNPortInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 4, 3))
rptrGroupCapacity = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupCapacity.setDescription('********* THIS OBJECT IS DEPRECATED **********\n\n               The rptrGroupCapacity is the number of groups\n               that can be contained within the repeater.  Within\n               each managed repeater, the groups are uniquely\n               numbered in the range from 1 to rptrGroupCapacity.\n\n               Some groups may not be present in the repeater, in\n               which case the actual number of groups present\n               will be less than rptrGroupCapacity.  The number\n               of groups present will never be greater than\n               rptrGroupCapacity.\n\n               Note:  In practice, this will generally be the\n               number of field-replaceable units (i.e., modules,\n               cards, or boards) that can fit in the physical\n               repeater enclosure, and the group numbers will\n               correspond to numbers marked on the physical\n               enclosure.')
rptrOperStatus = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6,))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("rptrFailure", 3), ("groupFailure", 4), ("portFailure", 5), ("generalFailure", 6),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrOperStatus.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\n               The rptrOperStatus object indicates the\n               operational state of the repeater.  The\n               rptrHealthText object may be consulted for more\n               specific information about the state of the\n               repeater's health.\n\n               In the case of multiple kinds of failures (e.g.,\n               repeater failure and port failure), the value of\n               this attribute shall reflect the highest priority\n               failure in the following order, listed highest\n               priority first:\n\n                   rptrFailure(3)\n                   groupFailure(4)\n                   portFailure(5)\n                   generalFailure(6).")
rptrHealthText = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrHealthText.setDescription('********* THIS OBJECT IS DEPRECATED **********\n\n               The health text object is a text string that\n               provides information relevant to the operational\n               state of the repeater.  Agents may use this string\n               to provide detailed information on current\n               failures, including how they were detected, and/or\n               instructions for problem resolution.  The contents\n               are agent-specific.')
rptrReset = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrReset.setDescription('********* THIS OBJECT IS DEPRECATED **********\n\n               Setting this object to reset(2) causes a\n               transition to the START state of Fig 9-2 in\n               section 9 [IEEE 802.3 Std] for a 10Mb/s repeater,\n               and the START state of Fig 27-2 in section 27\n               of that standard for a 100Mb/s repeater.\n\n               Setting this object to noReset(1) has no effect.\n               The agent will always return the value noReset(1)\n               when this object is read.\n\n               After receiving a request to set this variable to\n               reset(2), the agent is allowed to delay the reset\n               for a short period.  For example, the implementor\n               may choose to delay the reset long enough to allow\n               the SNMP response to be transmitted.  In any\n               event, the SNMP response must be transmitted.\n\n               This action does not reset the management counters\n               defined in this document nor does it affect the\n               portAdminStatus parameters.  Included in this\n               action is the execution of a disruptive Self-Test\n               with the following characteristics:  a) The nature\n               of the tests is not specified.  b) The test resets\n               the repeater but without affecting management\n               information about the repeater.  c) The test does\n               not inject packets onto any segment.  d) Packets\n               received during the test may or may not be\n               transferred.  e) The test does not interfere with\n               management functions.\n\n               After performing this self-test, the agent will\n               update the repeater health information (including\n               rptrOperStatus and rptrHealthText), and send a\n               rptrHealth trap.')
rptrNonDisruptTest = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("noSelfTest", 1), ("selfTest", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrNonDisruptTest.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\n               Setting this object to selfTest(2) causes the\n               repeater to perform a agent-specific, non-\n               disruptive self-test that has the following\n               characteristics:  a) The nature of the tests is\n               not specified.  b) The test does not change the\n               state of the repeater or management information\n               about the repeater.  c) The test does not inject\n               packets onto any segment.  d) The test does not\n               prevent the relay of any packets.  e) The test\n               does not interfere with management functions.\n\n               After performing this test, the agent will update\n               the repeater health information (including\n               rptrOperStatus and rptrHealthText) and send a\n               rptrHealth trap.\n\n               Note that this definition allows returning an\n               'okay' result after doing a trivial test.\n\n               Setting this object to noSelfTest(1) has no\n               effect.  The agent will always return the value\n               noSelfTest(1) when this object is read.")
rptrTotalPartitionedPorts = MibScalar((1, 3, 6, 1, 2, 1, 22, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrTotalPartitionedPorts.setDescription('********* THIS OBJECT IS DEPRECATED **********\n\n               This object returns the total number of ports in\n               the repeater whose current state meets all three\n               of the following criteria:  rptrPortOperStatus\n               does not have the value notPresent(3),\n               rptrPortAdminStatus is enabled(1), and\n               rptrPortAutoPartitionState is autoPartitioned(2).')
rptrGroupTable = MibTable((1, 3, 6, 1, 2, 1, 22, 1, 2, 1), )
if mibBuilder.loadTexts: rptrGroupTable.setDescription('Table of descriptive and status information about\n               the groups of ports.')
rptrGroupEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1), ).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrGroupIndex"))
if mibBuilder.loadTexts: rptrGroupEntry.setDescription('An entry in the table, containing information\n               about a single group of ports.')
rptrGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupIndex.setDescription('This object identifies the group within the\n               system for which this entry contains\n               information.')
rptrGroupDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupDescr.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\n               A textual description of the group.  This value\n               should include the full name and version\n               identification of the group's hardware type and\n               indicate how the group is differentiated from\n               other types of groups in the repeater.  Plug-in\n               Module, Rev A' or 'Barney Rubble 10BASE-T 4-port\n               SIMM socket Version 2.1' are examples of valid\n               group descriptions.\n\n               It is mandatory that this only contain printable\n               ASCII characters.")
rptrGroupObjectID = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupObjectID.setDescription("The vendor's authoritative identification of the\n               group.  This value may be allocated within the SMI\n               enterprises subtree (1.3.6.1.4.1) and provides a\n               straight-forward and unambiguous means for\n               determining what kind of group is being managed.\n\n               For example, this object could take the value\n               1.3.6.1.4.1.4242.1.2.14 if vendor 'Flintstones,\n               Inc.' was assigned the subtree 1.3.6.1.4.1.4242,\n               and had assigned the identifier\n               1.3.6.1.4.1.4242.1.2.14 to its 'Wilma Flintstone\n               6-Port FOIRL Plug-in Module.'")
rptrGroupOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6,))).clone(namedValues=NamedValues(("other", 1), ("operational", 2), ("malfunctioning", 3), ("notPresent", 4), ("underTest", 5), ("resetInProgress", 6),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupOperStatus.setDescription('An object that indicates the operational status\n               of the group.\n\n               A status of notPresent(4) indicates that the group\n               is temporarily or permanently physically and/or\n               logically not a part of the repeater.  It is an\n               implementation-specific matter as to whether the\n               agent effectively removes notPresent entries from\n               the table.\n\n               A status of operational(2) indicates that the\n               group is functioning, and a status of\n               malfunctioning(3) indicates that the group is\n               malfunctioning in some way.')
rptrGroupLastOperStatusChange = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupLastOperStatusChange.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\n               An object that contains the value of sysUpTime at\n               the time when the last of the following occurred:\n                 1) the agent cold- or warm-started;\n                 2) the row for the group was created (such\n                    as when the group was added to the system); or\n                 3) the value of rptrGroupOperStatus for the\n                    group changed.\n\n               A value of zero indicates that the group's\n               operational status has not changed since the agent\n               last restarted.")
rptrGroupPortCapacity = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupPortCapacity.setDescription('The rptrGroupPortCapacity is the number of ports\n               that can be contained within the group.  Valid\n               range is 1-2147483647.  Within each group, the\n               ports are uniquely numbered in the range from 1 to\n               rptrGroupPortCapacity.\n\n               Some ports may not be present in the system, in\n               which case the actual number of ports present\n               will be less than the value of rptrGroupPortCapacity.\n               The number of ports present in the group will never\n               be greater than the value of rptrGroupPortCapacity.\n\n               Note:  In practice, this will generally be the\n               number of ports on a module, card, or board, and\n               the port numbers will correspond to numbers marked\n               on the physical embodiment.')
rptrPortTable = MibTable((1, 3, 6, 1, 2, 1, 22, 1, 3, 1), )
if mibBuilder.loadTexts: rptrPortTable.setDescription('Table of descriptive and status information about\n               the repeater ports in the system.  The number of\n               entries is independent of the number of repeaters\n               in the managed system.')
rptrPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1), ).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrPortGroupIndex"), (0, "SNMP-REPEATER-MIB", "rptrPortIndex"))
if mibBuilder.loadTexts: rptrPortEntry.setDescription('An entry in the table, containing information\n               about a single port.')
rptrPortGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortGroupIndex.setDescription('This object identifies the group containing the\n               port for which this entry contains information.')
rptrPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortIndex.setDescription('This object identifies the port within the group\n               for which this entry contains information.  This\n               identifies the port independently from the repeater\n               it may be attached to.  The numbering scheme for\n               ports is implementation specific; however, this\n               value can never be greater than\n               rptrGroupPortCapacity for the associated group.')
rptrPortAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrPortAdminStatus.setDescription("Setting this object to disabled(2) disables the\n               port.  A disabled port neither transmits nor\n               receives.  Once disabled, a port must be\n               explicitly enabled to restore operation.  A port\n               which is disabled when power is lost or when a\n               reset is exerted shall remain disabled when normal\n               operation resumes.\n\n               The admin status takes precedence over auto-\n               partition and functionally operates between the\n               auto-partition mechanism and the AUI/PMA.\n\n               Setting this object to enabled(1) enables the port\n               and exerts a BEGIN on the port's auto-partition\n               state machine.\n\n               (In effect, when a port is disabled, the value of\n               rptrPortAutoPartitionState for that port is frozen\n               until the port is next enabled.  When the port\n               becomes enabled, the rptrPortAutoPartitionState\n               becomes notAutoPartitioned(1), regardless of its\n               pre-disabling state.)")
rptrPortAutoPartitionState = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("notAutoPartitioned", 1), ("autoPartitioned", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortAutoPartitionState.setDescription("The autoPartitionState flag indicates whether the\n               port is currently partitioned by the repeater's\n               auto-partition protection.\n\n               The conditions that cause port partitioning are\n               specified in partition state machine in Sections\n               9 and 27 of [IEEE 802.3 Std].  They are not\n               differentiated here.")
rptrPortOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("operational", 1), ("notOperational", 2), ("notPresent", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortOperStatus.setDescription("This object indicates the port's operational\n               status.  The notPresent(3) status indicates the\n               port is physically removed (note this may or may\n               not be possible depending on the type of port.)\n               The operational(1) status indicates that the port\n               is enabled (see rptrPortAdminStatus) and working,\n               even though it might be auto-partitioned (see\n               rptrPortAutoPartitionState).\n\n               If this object has the value operational(1) and\n               rptrPortAdminStatus is set to disabled(2), it is\n               expected that this object's value will soon change\n               to notOperational(2).")
rptrPortRptrId = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortRptrId.setDescription('This object identifies the repeater to\n               which this port belongs.  The repeater\n               identified by a particular value of this object\n               is the same as that identified by the same\n               value of rptrInfoId.  A value of zero\n               indicates that this port currently is not\n               a member of any repeater.')
rptrInfoTable = MibTable((1, 3, 6, 1, 2, 1, 22, 1, 4, 1), )
if mibBuilder.loadTexts: rptrInfoTable.setDescription('A table of information about each\n               non-trivial repeater. The number of entries\n               depends on the physical configuration of the\n               managed system.')
rptrInfoEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 1, 4, 1, 1), ).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrInfoId"))
if mibBuilder.loadTexts: rptrInfoEntry.setDescription('An entry in the table, containing information\n               about a single non-trivial repeater.')
rptrInfoId = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrInfoId.setDescription('This object identifies the repeater for which\n               this entry contains information.')
rptrInfoRptrType = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4,))).clone(namedValues=NamedValues(("other", 1), ("tenMb", 2), ("onehundredMbClassI", 3), ("onehundredMbClassII", 4),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrInfoRptrType.setDescription('The rptrInfoRptrType returns a value that identifies\n               the CSMA/CD repeater type.')
rptrInfoOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("failure", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrInfoOperStatus.setDescription('The rptrInfoOperStatus object indicates the\n               operational state of the repeater.')
rptrInfoReset = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrInfoReset.setDescription('Setting this object to reset(2) causes a\n               transition to the START state of Fig 9-2 in\n               section 9 [IEEE 802.3 Std] for a 10Mb/s repeater,\n               and to the START state of Fig 27-2 in section 27\n               of that standard for a 100Mb/s repeater.\n\n               Setting this object to noReset(1) has no effect.\n               The agent will always return the value noReset(1)\n               when this object is read.\n\n               After receiving a request to set this variable to\n               reset(2), the agent is allowed to delay the reset\n               for a short period.  For example, the implementor\n               may choose to delay the reset long enough to allow\n               the SNMP response to be transmitted.  In any\n               event, the SNMP response must be transmitted.\n\n               This action does not reset the management counters\n               defined in this document nor does it affect the\n               portAdminStatus parameters.  Included in this\n               action is the execution of a disruptive Self-Test\n               with the following characteristics:  a) The nature\n               of the tests is not specified.  b) The test resets\n               the repeater but without affecting management\n               information about the repeater.  c) The test does\n               not inject packets onto any segment.  d) Packets\n               received during the test may or may not be\n               transferred.  e) The test does not interfere with\n               management functions.\n\n               After performing this self-test, the agent will\n               update the repeater health information (including\n               rptrInfoOperStatus), and send a rptrInfoResetEvent\n               notification.')
rptrInfoPartitionedPorts = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 4, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrInfoPartitionedPorts.setDescription('This object returns the total number of ports in\n               the repeater whose current state meets all three\n               of the following criteria:  rptrPortOperStatus\n               does not have the value notPresent(3),\n               rptrPortAdminStatus is enabled(1), and\n               rptrPortAutoPartitionState is autoPartitioned(2).')
rptrInfoLastChange = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 1, 4, 1, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrInfoLastChange.setDescription('The value of sysUpTime when any of the following\n               conditions occurred:\n                 1) agent cold- or warm-started;\n                 2) this instance of repeater was created\n                    (such as when a device or module was\n                    added to the system);\n                 3) a change in the value of rptrInfoOperStatus;\n                 4) ports were added or removed as members of\n                    the repeater; or\n                 5) any of the counters associated with this\n                    repeater had a discontinuity.')
rptrMonitorTransmitCollisions = MibScalar((1, 3, 6, 1, 2, 1, 22, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorTransmitCollisions.setDescription('********* THIS OBJECT IS DEPRECATED **********\n\n               For a clause 9 (10Mb/s) repeater, this counter\n               is incremented every time the repeater state\n               machine enters the TRANSMIT COLLISION state\n               from any state other than ONE PORT LEFT\n               (Ref: Fig 9-2 [IEEE 802.3 Std]).\n\n               For a clause 27 repeater, this counter is\n               incremented every time the repeater core state\n               diagram enters the Jam state as a result of\n               Activity(ALL) > 1 (fig 27-2 [IEEE 802.3 Std]).\n               The approximate minimum time for rollover of this\n               counter is 16 hours in a 10Mb/s repeater and 1.6\n               hours in a 100Mb/s repeater.')
rptrMonitorGroupTable = MibTable((1, 3, 6, 1, 2, 1, 22, 2, 2, 1), )
if mibBuilder.loadTexts: rptrMonitorGroupTable.setDescription('********* THIS OBJECT IS DEPRECATED **********\n\n               Table of performance and error statistics for the\n               groups within the repeater.  The number of entries\n               is the same as that in the rptrGroupTable.')
rptrMonitorGroupEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1), ).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrMonitorGroupIndex"))
if mibBuilder.loadTexts: rptrMonitorGroupEntry.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\n               An entry in the table, containing total\n               performance and error statistics for a single\n               group.  Regular retrieval of the information in\n               this table provides a means of tracking the\n               performance and health of the networked devices\n               attached to this group's ports.\n\n               The counters in this table are redundant in the\n               sense that they are the summations of information\n               already available through other objects.  However,\n               these sums provide a considerable optimization of\n               network management traffic over the otherwise\n               necessary retrieval of the individual counters\n               included in each sum.\n\n               Note:  Group-level counters are\n               deprecated in this MIB.  It is recommended\n               that management applications instead use\n               the repeater-level counters contained in\n               the rptrMonTable.")
rptrMonitorGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorGroupIndex.setDescription('********* THIS OBJECT IS DEPRECATED **********\n\n               This object identifies the group within the\n               repeater for which this entry contains\n               information.')
rptrMonitorGroupTotalFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorGroupTotalFrames.setDescription('********* THIS OBJECT IS DEPRECATED **********\n\n               The total number of frames of valid frame length\n               that have been received on the ports in this group\n               and for which the FCSError and CollisionEvent\n               signals were not asserted.  This counter is the\n               summation of the values of the\n               rptrMonitorPortReadableFrames counters for all of\n               the ports in the group.\n\n               This statistic provides one of the parameters\n               necessary for obtaining the packet error rate.\n               The approximate minimum time for rollover of this\n               counter is 80 hours in a 10Mb/s repeater.')
rptrMonitorGroupTotalOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorGroupTotalOctets.setDescription('********* THIS OBJECT IS DEPRECATED **********\n\n               The total number of octets contained in the valid\n               frames that have been received on the ports in\n               this group.  This counter is the summation of the\n               values of the rptrMonitorPortReadableOctets\n               counters for all of the ports in the group.\n\n               This statistic provides an indicator of the total\n               data transferred.  The approximate minimum time\n               for rollover of this counter is 58 minutes in a\n               10Mb/s repeater.')
rptrMonitorGroupTotalErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorGroupTotalErrors.setDescription('********* THIS OBJECT IS DEPRECATED **********\n\n               The total number of errors which have occurred on\n               all of the ports in this group.  This counter is\n               the summation of the values of the\n               rptrMonitorPortTotalErrors counters for all of the\n               ports in the group.')
rptrMonitorPortTable = MibTable((1, 3, 6, 1, 2, 1, 22, 2, 3, 1), )
if mibBuilder.loadTexts: rptrMonitorPortTable.setDescription('Table of performance and error statistics for the\n               ports.  The number of entries is the same as that\n               in the rptrPortTable.\n\n               The columnar object rptrMonitorPortLastChange\n               is used to indicate possible discontinuities\n               of counter type columnar objects in the table.')
rptrMonitorPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1), ).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrMonitorPortGroupIndex"), (0, "SNMP-REPEATER-MIB", "rptrMonitorPortIndex"))
if mibBuilder.loadTexts: rptrMonitorPortEntry.setDescription('An entry in the table, containing performance and\n               error statistics for a single port.')
rptrMonitorPortGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortGroupIndex.setDescription('This object identifies the group containing the\n               port for which this entry contains information.')
rptrMonitorPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortIndex.setDescription('This object identifies the port within the group\n               for which this entry contains information.')
rptrMonitorPortReadableFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortReadableFrames.setDescription('This object is the number of frames of valid\n               frame length that have been received on this port.\n               This counter is incremented by one for each frame\n               received on this port whose OctetCount is greater\n               than or equal to minFrameSize and less than or\n               equal to maxFrameSize (Ref: IEEE 802.3 Std,\n               4.4.2.1) and for which the FCSError and\n               CollisionEvent signals are not asserted.\n\n               A discontinuity may occur in the value\n               when the value of object\n               rptrMonitorPortLastChange changes.\n\n               This statistic provides one of the parameters\n               necessary for obtaining the packet error rate.\n               The approximate minimum time for rollover of this\n               counter is 80 hours at 10Mb/s.')
rptrMonitorPortReadableOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortReadableOctets.setDescription("This object is the number of octets contained in\n               valid frames that have been received on this port.\n               This counter is incremented by OctetCount for each\n               frame received on this port which has been\n               determined to be a readable frame (i.e., including\n               FCS octets but excluding framing bits and dribble\n               bits).\n\n               A discontinuity may occur in the value\n               when the value of object\n               rptrMonitorPortLastChange changes.\n\n               This statistic provides an indicator of the total\n               data transferred.  The approximate minimum time\n               for rollover of this counter in a 10Mb/s repeater\n               is 58 minutes.\n\n               For ports receiving traffic at a maximum rate in\n               a 100Mb/s repeater, this counter can roll over\n               in less than 6 minutes.  Since that amount of time\n               could be less than a management station's poll cycle\n               time, in order to avoid a loss of information a\n               management station is advised to also poll the\n               rptrMonitorPortUpper32Octets object, or to use the\n               64-bit counter defined by\n               rptrMonitorPortHCReadableOctets instead of the\n               two 32-bit counters.")
rptrMonitorPortFCSErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortFCSErrors.setDescription('This counter is incremented by one for each frame\n               received on this port with the FCSError signal\n               asserted and the FramingError and CollisionEvent\n               signals deasserted and whose OctetCount is greater\n               than or equal to minFrameSize and less than or\n               equal to maxFrameSize (Ref: 4.4.2.1, IEEE 802.3\n               Std).\n\n               A discontinuity may occur in the value\n               when the value of object\n               rptrMonitorPortLastChange changes.\n\n               The approximate minimum time for rollover of this\n               counter is 80 hours at 10Mb/s.')
rptrMonitorPortAlignmentErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortAlignmentErrors.setDescription('This counter is incremented by one for each frame\n               received on this port with the FCSError and\n               FramingError signals asserted and CollisionEvent\n               signal deasserted and whose OctetCount is greater\n               than or equal to minFrameSize and less than or\n               equal to maxFrameSize (Ref: IEEE 802.3 Std,\n               4.4.2.1).  If rptrMonitorPortAlignmentErrors is\n               incremented then the rptrMonitorPortFCSErrors\n               Counter shall not be incremented for the same\n               frame.\n\n               A discontinuity may occur in the value\n               when the value of object\n               rptrMonitorPortLastChange changes.\n\n               The approximate minimum time for rollover of this\n               counter is 80 hours at 10Mb/s.')
rptrMonitorPortFrameTooLongs = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortFrameTooLongs.setDescription('This counter is incremented by one for each frame\n               received on this port whose OctetCount is greater\n               than maxFrameSize (Ref: 4.4.2.1, IEEE 802.3 Std).\n               If rptrMonitorPortFrameTooLongs is incremented\n               then neither the rptrMonitorPortAlignmentErrors\n               nor the rptrMonitorPortFCSErrors counter shall be\n               incremented for the frame.\n\n               A discontinuity may occur in the value\n               when the value of object\n               rptrMonitorPortLastChange changes.\n\n               The approximate minimum time for rollover of this\n               counter is 61 days in a 10Mb/s repeater.')
rptrMonitorPortShortEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortShortEvents.setDescription('This counter is incremented by one for each\n               CarrierEvent on this port with ActivityDuration\n               less than ShortEventMaxTime.  ShortEventMaxTime is\n               greater than 74 bit times and less than 82 bit\n               times.  ShortEventMaxTime has tolerances included\n               to provide for circuit losses between a\n               conformance test point at the AUI and the\n               measurement point within the state machine.\n\n               Notes:\n\n               ShortEvents may indicate externally\n               generated noise hits which will cause the repeater\n               to transmit Runts to its other ports, or propagate\n               a collision (which may be late) back to the\n               transmitting DTE and damaged frames to the rest of\n               the network.\n\n               Implementors may wish to consider selecting the\n               ShortEventMaxTime towards the lower end of the\n               allowed tolerance range to accommodate bit losses\n               suffered through physical channel devices not\n               budgeted for within this standard.\n\n               The significance of this attribute is different\n               in 10 and 100 Mb/s collision domains.  Clause 9\n               repeaters perform fragment extension of short\n               events which would be counted as runts on the\n               interconnect ports of other repeaters.  Clause\n               27 repeaters do not perform fragment extension.\n\n               A discontinuity may occur in the value\n               when the value of object\n               rptrMonitorPortLastChange changes.\n\n               The approximate minimum time for rollover of this\n               counter is 16 hours in a 10Mb/s repeater.')
rptrMonitorPortRunts = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortRunts.setDescription('This counter is incremented by one for each\n               CarrierEvent on this port that meets one of the\n               following two conditions.  Only one test need be\n               made.  a) The ActivityDuration is greater than\n               ShortEventMaxTime and less than ValidPacketMinTime\n               and the CollisionEvent signal is deasserted.  b)\n               The OctetCount is less than 64, the\n               ActivityDuration is greater than ShortEventMaxTime\n               and the CollisionEvent signal is deasserted.\n               ValidPacketMinTime is greater than or equal to 552\n               bit times and less than 565 bit times.\n\n               An event whose length is greater than 74 bit times\n               but less than 82 bit times shall increment either\n               the shortEvents counter or the runts counter but\n               not both.  A CarrierEvent greater than or equal to\n               552 bit times but less than 565 bit times may or\n               may not be counted as a runt.\n\n               ValidPacketMinTime has tolerances included to\n               provide for circuit losses between a conformance\n               test point at the AUI and the measurement point\n               within the state machine.\n\n               Runts usually indicate collision fragments, a\n               normal network event.  In certain situations\n               associated with large diameter networks a\n               percentage of collision fragments may exceed\n               ValidPacketMinTime.\n               A discontinuity may occur in the value\n               when the value of object\n               rptrMonitorPortLastChange changes.\n\n               The approximate minimum time for rollover of this\n               counter is 16 hours in a 10Mb/s repeater.')
rptrMonitorPortCollisions = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortCollisions.setDescription('For a clause 9 repeater, this counter is\n               incremented by one for any CarrierEvent signal\n               on any port for which the CollisionEvent signal\n               on this port is asserted.  For a clause 27\n               repeater port the counter increments on entering\n               the Collision Count Increment state of the\n               partition state diagram (fig 27-8 of\n               [IEEE 802.3 Std]).\n\n               A discontinuity may occur in the value\n               when the value of object\n               rptrMonitorPortLastChange changes.\n\n               The approximate minimum time for rollover of this\n               counter is 16 hours in a 10Mb/s repeater.')
rptrMonitorPortLateEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortLateEvents.setDescription('For a clause 9 repeater port, this counter is\n               incremented by one for each CarrierEvent\n               on this port in which the CollIn(X)\n               variable transitions to the value SQE (Ref:\n               9.6.6.2, IEEE 802.3 Std) while the\n               ActivityDuration is greater than the\n               LateEventThreshold.  For a clause 27 repeater\n               port, this counter is incremented by one on\n               entering the Collision Count Increment state\n               of the  partition state diagram (fig 27-8)\n               while the  ActivityDuration is greater than\n               the LateEvent- Threshold.  Such a CarrierEvent\n               is counted twice, as both a collision and as a\n               lateEvent.\n\n               The LateEventThreshold is greater than 480 bit\n               times and less than 565 bit times.\n               LateEventThreshold has tolerances included to\n               permit an implementation to build a single\n               threshold to serve as both the LateEventThreshold\n               and ValidPacketMinTime threshold.\n\n               A discontinuity may occur in the value\n               when the value of object\n               rptrMonitorPortLastChange changes.\n\n               The approximate minimum time for rollover of this\n               counter is 81 hours in a 10Mb/s repeater.')
rptrMonitorPortVeryLongEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortVeryLongEvents.setDescription('For a clause 9 repeater port, this counter\n               is incremented by one for each CarrierEvent\n               whose ActivityDuration is greater than the\n               MAU Jabber Lockup Protection timer TW3\n               (Ref: 9.6.1 & 9.6.5, IEEE 802.3 Std).\n\n               For a clause 27 repeater port, this counter\n               is incremented by one on entry to the\n               Rx Jabber state of the receiver timer state\n               diagram (fig 27-7).  Other counters may\n               be incremented as appropriate.\n\n               A discontinuity may occur in the value\n               when the value of object\n               rptrMonitorPortLastChange changes.')
rptrMonitorPortDataRateMismatches = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortDataRateMismatches.setDescription("This counter is incremented by one for each\n               frame received by this port that meets all\n               of the conditions required by only one of the\n               following two measurement methods:\n\n               Measurement method A:  1) The CollisionEvent\n               signal is not asserted (10Mb/s operation) or\n               the Collision Count Increment state of the\n               partition state diagram (fig 27-8 of\n               [IEEE 802.3 Std]) has not been entered\n               (100Mb/s operation).  2) The ActivityDuration\n               is greater than ValidPacketMinTime.  3) The\n               frequency (data rate) is detectably mismatched\n               from the local transmit frequency.\n\n               Measurement method B:  1) The CollisionEvent\n               signal is not asserted (10Mb/s operation)\n               or the Collision Count Increment state of the\n               partition state diagram (fig 27-8 of\n               [IEEE 802.3 Std]) has not been entered\n               (100Mb/s operation).  2) The OctetCount is\n               greater than 63.  3) The frequency (data\n               rate) is detectably mismatched from the local\n               transmit frequency.  The exact degree of\n               mismatch is vendor specific and is to be\n               defined by the vendor for conformance testing.\n\n               When this event occurs, other counters whose\n               increment conditions were satisfied may or may not\n               also be incremented, at the implementor's\n               discretion.  Whether or not the repeater was able\n               to maintain data integrity is beyond the scope of\n               this standard.\n\n               A discontinuity may occur in the value\n               when the value of object\n               rptrMonitorPortLastChange changes.")
rptrMonitorPortAutoPartitions = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortAutoPartitions.setDescription('This counter is incremented by one for\n               each time the repeater has automatically\n               partitioned this port.\n\n               The conditions that cause a clause 9\n               repeater port to partition are specified in\n               the partition state diagram in clause 9 of\n               [IEEE 802.3 Std].  They are not differentiated\n               here.  A clause 27 repeater port partitions\n               on entry to the Partition Wait state of the\n               partition state diagram (fig 27-8 in\n               [IEEE 802.3 Std]).\n\n               A discontinuity may occur in the value\n               when the value of object\n               rptrMonitorPortLastChange changes.')
rptrMonitorPortTotalErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortTotalErrors.setDescription('The total number of errors which have occurred on\n               this port.  This counter is the summation of the\n               values of other error counters (for the same\n               port), namely:\n\n                   rptrMonitorPortFCSErrors,\n                   rptrMonitorPortAlignmentErrors,\n                   rptrMonitorPortFrameTooLongs,\n                   rptrMonitorPortShortEvents,\n                   rptrMonitorPortLateEvents,\n                   rptrMonitorPortVeryLongEvents,\n                   rptrMonitorPortDataRateMismatches, and\n                   rptrMonitorPortSymbolErrors.\n\n               This counter is redundant in the sense that it is\n               the summation of information already available\n               through other objects.  However, it is included\n               specifically because the regular retrieval of this\n               object as a means of tracking the health of a port\n               provides a considerable optimization of network\n               management traffic over the otherwise necessary\n               retrieval of the summed counters.\n\n               Note that rptrMonitorPortRunts is not included\n               in this total; this is because runts usually\n               indicate collision fragments, a normal network\n               event.\n\n               A discontinuity may occur in the value\n               when the value of object\n               rptrMonitorPortLastChange changes.')
rptrMonitorPortLastChange = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 1, 1, 16), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortLastChange.setDescription('The value of sysUpTime when the last of\n               the following occurred:\n                 1) the agent cold- or warm-started;\n                 2) the row for the port was created\n                    (such as when a device or module was added\n                     to the system); or\n                 3) any condition that would cause one of\n                    the counters for the row to experience\n                    a discontinuity.')
rptrMonitor100PortTable = MibTable((1, 3, 6, 1, 2, 1, 22, 2, 3, 2), )
if mibBuilder.loadTexts: rptrMonitor100PortTable.setDescription('Table of additional performance and error\n               statistics for 100Mb/s ports, above and\n               beyond those parameters that apply to both\n               10 and 100Mbps ports.  Entries exist only for\n               ports attached to 100Mbps repeaters.\n\n               The columnar object rptrMonitorPortLastChange\n               is used to indicate possible discontinuities\n               of counter type columnar objects in this table.')
rptrMonitor100PortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 2, 3, 2, 1), ).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrMonitorPortGroupIndex"), (0, "SNMP-REPEATER-MIB", "rptrMonitorPortIndex"))
if mibBuilder.loadTexts: rptrMonitor100PortEntry.setDescription('An entry in the table, containing performance\n               and error statistics for a single 100Mb/s port.')
rptrMonitorPortIsolates = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortIsolates.setDescription('This counter is incremented by one each time that\n               the repeater port automatically isolates as a\n               consequence of false carrier events.  The conditions\n               which cause a port to automatically isolate are\n               defined by the transition from the False Carrier\n               state to the Link Unstable state of the carrier\n               integrity state diagram (figure 27-9)\n               [IEEE 802.3 Standard].\n\n               Note:  Isolates do not affect the value of\n               the PortOperStatus object.\n\n               A discontinuity may occur in the value\n               when the value of object\n               rptrMonitorPortLastChange changes.')
rptrMonitorPortSymbolErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortSymbolErrors.setDescription('This counter is incremented by one each time when\n               valid length packet was received at the port and\n               there was at least one occurrence of an invalid\n               data symbol. This can increment only once per valid\n               carrier event. A collision presence at any port of\n               the repeater containing port N, will not cause this\n               attribute to increment.\n\n               A discontinuity may occur in the value\n               when the value of object\n               rptrMonitorPortLastChange changes.\n\n               The approximate minimum time for rollover of this\n               counter is 7.4 hours at 100Mb/s.')
rptrMonitorPortUpper32Octets = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortUpper32Octets.setDescription('This object is the number of octets contained in\n               valid frames that have been received on this port,\n               modulo 2**32.  That is, it contains the upper 32\n               bits of a 64-bit octets counter, of which the\n               lower 32 bits are contained in the\n               rptrMonitorPortReadableOctets object.\n\n               This two-counter mechanism is provided for those\n               network management protocols that do not support\n               64-bit counters (e.g. SNMP V1) and are used to\n               manage a repeater type of 100Mb/s.\n\n               Conformance clauses for this MIB are defined such\n               that implementation of this object is not required\n               in a system which does not support 100Mb/s.\n               However, systems with mixed 10 and 100Mb/s ports\n               may implement this object across all ports,\n               including 10Mb/s.  If this object is implemented,\n               it must be according to the definition in the first\n               paragraph of this description; that is, the value\n               of this object MUST be a valid count.\n\n               A discontinuity may occur in the value\n               when the value of object\n               rptrMonitorPortLastChange changes.')
rptrMonitorPortHCReadableOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 3, 2, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonitorPortHCReadableOctets.setDescription('This object is the number of octets contained in\n               valid frames that have been received on this port.\n               This counter is incremented by OctetCount for each\n               frame received on this port which has been\n               determined to be a readable frame (i.e., including\n               FCS octets but excluding framing bits and dribble\n               bits).\n\n               This statistic provides an indicator of the total\n               data transferred.\n\n               This counter is a 64-bit version of rptrMonitor-\n               PortReadableOctets. It should be used by network\n               management protocols which suppport 64-bit counters\n               (e.g. SNMPv2).\n\n               Conformance clauses for this MIB are defined such\n               that implementation of this object is not required\n               in a system which does not support 100Mb/s.\n               However, systems with mixed 10 and 100Mb/s ports\n               may implement this object across all ports,\n               including 10Mb/s.  If this object is implemented,\n               it must be according to the definition in the first\n               paragraph of this description; that is, the value\n               of this object MUST be a valid count.\n\n               A discontinuity may occur in the value\n               when the value of object\n               rptrMonitorPortLastChange changes.')
rptrMonTable = MibTable((1, 3, 6, 1, 2, 1, 22, 2, 4, 1), )
if mibBuilder.loadTexts: rptrMonTable.setDescription('A table of information about each\n               non-trivial repeater.  The number of entries\n               in this table is the same as the number of\n               entries in the rptrInfoTable.\n\n               The columnar object rptrInfoLastChange is\n               used to indicate possible discontinuities of\n               counter type columnar objects in this table.')
rptrMonEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 2, 4, 1, 1), ).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrInfoId"))
if mibBuilder.loadTexts: rptrMonEntry.setDescription('An entry in the table, containing information\n               about a single non-trivial repeater.')
rptrMonTxCollisions = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 4, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonTxCollisions.setDescription('For a clause 9 (10Mb/s) repeater, this counter\n               is incremented every time the repeater state\n               machine enters the TRANSMIT COLLISION state\n               from any state other than ONE PORT LEFT\n               (Ref: Fig 9-2 [IEEE 802.3 Std]).\n\n               For a clause 27 repeater, this counter is\n               incremented every time the repeater core state\n               diagram enters the Jam state as a result of\n               Activity(ALL) > 1 (fig 27-2 [IEEE 802.3 Std]).\n\n               The approximate minimum time for rollover of this\n               counter is 16 hours in a 10Mb/s repeater and 1.6\n               hours in a 100Mb/s repeater.')
rptrMonTotalFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 4, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonTotalFrames.setDescription('The number of frames of valid frame length\n               that have been received on the ports in this repeater\n               and for which the FCSError and CollisionEvent\n               signals were not asserted.  If an implementation\n               can not obtain a count of frames as seen by\n               the repeater itself, this counter may be\n               implemented as the summation of the values of the\n               rptrMonitorPortReadableFrames counters for all of\n               the ports in the repeater.\n\n               This statistic provides one of the parameters\n               necessary for obtaining the packet error rate.\n               The approximate minimum time for rollover of this\n               counter is 80 hours in a 10Mb/s repeater.')
rptrMonTotalErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 4, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonTotalErrors.setDescription('The total number of errors which have occurred on\n               all of the ports in this repeater.  The errors\n               included in this count are the same as those listed\n               for the rptrMonitorPortTotalErrors counter.  If an\n               implementation can not obtain a count of these\n               errors as seen by the repeater itself, this counter\n               may be implemented as the summation of the values of\n               the rptrMonitorPortTotalErrors counters for all of\n               the ports in the repeater.')
rptrMonTotalOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 4, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonTotalOctets.setDescription("The total number of octets contained in the valid\n               frames that have been received on the ports in\n               this group.  If an implementation can not obtain\n               a count of octets as seen by the repeater itself,\n               this counter may be the summation of the\n               values of the rptrMonitorPortReadableOctets\n               counters for all of the ports in the group.\n\n               This statistic provides an indicator of the total\n               data transferred.  The approximate minimum time\n               for rollover of this counter in a 10Mb/s repeater\n               is 58 minutes divided by the number of ports in\n               the repeater.\n\n               For 100Mb/s repeaters processing traffic at a\n               maximum rate, this counter can roll over in less\n               than 6 minutes divided by the number of ports in\n               the repeater.  Since that amount of time could\n               be less than a management station's poll cycle\n               time, in order to avoid a loss of information a\n               management station is advised to also poll the\n               rptrMonUpper32TotalOctets object, or to use the\n               64-bit counter defined by rptrMonHCTotalOctets\n               instead of the two 32-bit counters.")
rptrMon100Table = MibTable((1, 3, 6, 1, 2, 1, 22, 2, 4, 2), )
if mibBuilder.loadTexts: rptrMon100Table.setDescription('A table of additional information about each\n               100Mb/s repeater, augmenting the entries in\n               the rptrMonTable.  Entries exist in this table\n               only for 100Mb/s repeaters.\n\n               The columnar object rptrInfoLastChange is\n               used to indicate possible discontinuities of\n               counter type columnar objects in this table.')
rptrMon100Entry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 2, 4, 2, 1), ).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrInfoId"))
if mibBuilder.loadTexts: rptrMon100Entry.setDescription('An entry in the table, containing information\n               about a single 100Mbps repeater.')
rptrMonUpper32TotalOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 4, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonUpper32TotalOctets.setDescription('The total number of octets contained in the valid\n               frames that have been received on the ports in\n               this repeater, modulo 2**32.  That is, it contains\n               the upper 32 bits of a 64-bit counter, of which\n               the lower 32 bits are contained in the\n               rptrMonTotalOctets object.  If an implementation\n               can not obtain a count of octets as seen\n               by the repeater itself, the 64-bit value\n               may be the summation of the values of the\n               rptrMonitorPortReadableOctets counters combined\n               with the corresponding rptrMonitorPortUpper32Octets\n               counters for all of the ports in the repeater.\n\n               This statistic provides an indicator of the total\n               data transferred within the repeater.\n\n               This two-counter mechanism is provided for those\n               network management protocols that do not support\n               64-bit counters (e.g. SNMP V1) and are used to\n               manage a repeater type of 100Mb/s.\n\n               Conformance clauses for this MIB are defined such\n               that implementation of this object is not required\n               in a system which does not support 100Mb/s.\n               However, systems with mixed 10 and 100Mb/s ports\n               may implement this object across all ports,\n               including 10Mb/s.  If this object is implemented,\n               it must be according to the definition in the first\n               paragraph of this description; that is, the value\n               of this object MUST be a valid count.')
rptrMonHCTotalOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 2, 4, 2, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrMonHCTotalOctets.setDescription('The total number of octets contained in the valid\n               frames that have been received on the ports in\n               this group.  If a implementation can not obtain\n               a count of octets as seen by the repeater itself,\n               this counter may be the summation of the\n               values of the rptrMonitorPortReadableOctets\n               counters for all of the ports in the group.\n\n               This statistic provides an indicator of the total\n               data transferred.\n\n               This counter is a 64-bit (high-capacity) version\n               of rptrMonUpper32TotalOctets and rptrMonTotalOctets.\n               It should be used by network management protocols\n               which support 64-bit counters (e.g. SNMPv2).\n\n               Conformance clauses for this MIB are defined such\n               that implementation of this object is not required\n               in a system which does not support 100Mb/s.\n               However, systems with mixed 10 and 100Mb/s ports\n               may implement this object across all ports,\n               including 10Mb/s.  If this object is implemented,\n               it must be according to the definition in the first\n               paragraph of this description; that is, the value\n               of this object MUST be a valid count.')
rptrAddrSearchTable = MibTable((1, 3, 6, 1, 2, 1, 22, 3, 1, 1), )
if mibBuilder.loadTexts: rptrAddrSearchTable.setDescription("This table contains one entry per repeater in the\n               system.  It defines objects which allow a network\n               management application to instruct an agent to watch\n               for a given MAC address and report which port it\n               was seen on.  Only one address search can be in\n               progress on each repeater at any one time.  Before\n               starting an address search, a management application\n               should obtain 'ownership' of the entry in\n               rptrAddrSearchTable for the repeater that is to\n               perform the search.  This is accomplished with the\n               rptrAddrSearchLock and rptrAddrSearchStatus as\n               follows:\n\n               try_again:\n                   get(rptrAddrSearchLock, rptrAddrSearchStatus)\n                   while (rptrAddrSearchStatus != notInUse)\n                   {\n                       /* Loop waiting for objects to be available*/\n                       short delay\n                       get(rptrAddrSearchLock, rptrAddrSearchStatus)\n                   }\n\n                   /* Try to claim map objects */\n                   lock_value = rptrAddrSearchLock\n                   if ( set(rptrAddrSearchLock = lock_value,\n                            rptrAddrSearchStatus = inUse,\n                            rptrAddrSearchOwner = 'my-IP-address)\n                         == FAILURE)\n                       /* Another manager got the lock */\n                       goto try_again\n\n                   /* I have the lock */\n                   set (rptrAddrSearchAddress = <search target>)\n\n                   wait for rptrAddrSearchState to change from none\n\n                   if (rptrAddrSearchState == single)\n                       get (rptrAddrSearchGroup, rptrAddrSearchPort)\n\n                   /* release the lock, making sure not to overwrite\n                      anyone else's lock */\n                   set (rptrAddrSearchLock = lock_value+1,\n                        rptrAddrSearchStatus = notInUse,\n                        rptrAddrSearchOwner = '')\n\n               A management station first retrieves the values of\n               the appropriate instances of the rptrAddrSearchLock\n               and rptrAddrSearchStatus objects, periodically\n               repeating the retrieval if necessary, until the value\n               of rptrAddrSearchStatus is 'notInUse'.  The\n               management station then tries to set the same\n               instance of the rptrAddrSearchLock object to the\n               value it just retrieved, the same instance of the\n               rptrAddrSearchStatus object to 'inUse', and the\n               corresponding instance of rptrAddrSearchOwner to a\n               value indicating itself.  If the set operation\n               succeeds, then the management station has obtained\n               ownership of the rptrAddrSearchEntry, and the value\n               of rptrAddrSearchLock is incremented by the agent (as\n               per the semantics of TestAndIncr).  Failure of the\n               set operation indicates that some other manager has\n               obtained ownership of the rptrAddrSearchEntry.\n\n               Once ownership is obtained, the management station\n               can proceed with the search operation.  Note that the\n               agent will reset rptrAddrSearchStatus to 'notInUse'\n               if it has been in the 'inUse' state for an abnormally\n               long period of time, to prevent a misbehaving manager\n               from permanently locking the entry.  It is suggested\n               that this timeout period be between one and five\n               minutes.\n\n               When the management station has completed its search\n               operation, it should free the entry by setting\n               the instance of the rptrAddrSearchLock object to the\n               previous value + 1, the instance of the\n               rptrAddrSearchStatus to 'notInUse', and the instance\n               of rptrAddrSearchOwner to a zero length string.  This\n               is done to prevent overwriting another station's\n               lock.")
rptrAddrSearchEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 3, 1, 1, 1), ).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrInfoId"))
if mibBuilder.loadTexts: rptrAddrSearchEntry.setDescription('An entry containing objects for invoking an address\n               search on a repeater.')
rptrAddrSearchLock = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 1, 1, 1, 1), TestAndIncr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrAddrSearchLock.setDescription('This object is used by a management station as an\n               advisory lock for this rptrAddrSearchEntry.')
rptrAddrSearchStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("notInUse", 1), ("inUse", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrAddrSearchStatus.setDescription("This object is used to indicate that some management\n               station is currently using this rptrAddrSearchEntry.\n               Cooperating managers should set this object to\n               'notInUse' when they are finished using this entry.\n               The agent will automatically set the value of this\n               object to 'notInUse' if it has been set to 'inUse'\n               for an unusually long period of time.")
rptrAddrSearchAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 1, 1, 1, 3), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrAddrSearchAddress.setDescription("This object is used to search for a specified MAC\n               address.  When this object is set, an address search\n               begins.  This automatically sets the corresponding\n               instance of the rptrAddrSearchState object  to 'none'\n               and the corresponding instances of the\n               rptrAddrSearchGroup and rptrAddrSearchPort objects to\n               0.\n\n               When a valid frame is received by this repeater with\n               a source MAC address which matches the current value\n               of rptrAddrSearchAddress, the agent will update the\n               corresponding instances of rptrAddrSearchState,\n               rptrAddrSearchGroup and rptrAddrSearchPort to reflect\n               the current status of the search, and the group and\n               port on which the frame was seen.")
rptrAddrSearchState = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("none", 1), ("single", 2), ("multiple", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrSearchState.setDescription("The current state of the MAC address search on this\n               repeater.  This object is initialized to 'none' when\n               the corresponding instance of rptrAddrSearchAddress\n               is set.  If the agent detects the address on exactly\n               one port, it will set this object to 'single', and\n               set the corresponding instances of\n               rptrAddrSearchGroup and rptrAddrSearchPort to reflect\n               the group and port on which the address was heard.\n               If the agent detects the address on more than one\n               port, it will set this object to 'multiple'.")
rptrAddrSearchGroup = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrSearchGroup.setDescription("The group from which an error-free frame whose\n               source address is equal to the corresponding instance\n               of rptrAddrSearchAddress has been received.  The\n               value of this object is undefined when the\n               corresponding instance of rptrAddrSearchState is\n               equal to 'none' or 'multiple'.")
rptrAddrSearchPort = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrSearchPort.setDescription("The port rom which an error-free frame whose\n               source address is equal to the corresponding instance\n               of rptrAddrSearchAddress has been received.  The\n               value of this object is undefined when the\n               corresponding instance of rptrAddrSearchState is\n               equal to 'none' or 'multiple'.")
rptrAddrSearchOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 1, 1, 1, 7), OwnerString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrAddrSearchOwner.setDescription("The entity which currently has 'ownership' of this\n               rptrAddrSearchEntry.")
rptrAddrTrackTable = MibTable((1, 3, 6, 1, 2, 1, 22, 3, 3, 1), )
if mibBuilder.loadTexts: rptrAddrTrackTable.setDescription('Table of address mapping information about the\n               ports.')
rptrAddrTrackEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1), ).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrAddrTrackGroupIndex"), (0, "SNMP-REPEATER-MIB", "rptrAddrTrackPortIndex"))
if mibBuilder.loadTexts: rptrAddrTrackEntry.setDescription('An entry in the table, containing address mapping\n               information about a single port.')
rptrAddrTrackGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackGroupIndex.setDescription('This object identifies the group containing the\n               port for which this entry contains information.')
rptrAddrTrackPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackPortIndex.setDescription('This object identifies the port within the group\n               for which this entry contains information.')
rptrAddrTrackLastSourceAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackLastSourceAddress.setDescription('********* THIS OBJECT IS DEPRECATED **********\n               This object is the SourceAddress of the last\n               readable frame (i.e., counted by\n               rptrMonitorPortReadableFrames) received by this\n               port.\n\n               This object has been deprecated because its value\n               is undefined when no frames have been observed on\n               this port.  The replacement object is\n               rptrAddrTrackNewLastSrcAddress.')
rptrAddrTrackSourceAddrChanges = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackSourceAddrChanges.setDescription('This counter is incremented by one for each time\n               that the rptrAddrTrackLastSourceAddress attribute\n               for this port has changed.\n\n               This may indicate whether a link is connected to a\n               single DTE or another multi-user segment.\n\n               A discontinuity may occur in the value when the\n               value of object rptrMonitorPortLastChange changes.\n\n               The approximate minimum time for rollover of this\n               counter is 81 hours in a 10Mb/s repeater.')
rptrAddrTrackNewLastSrcAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 5), OptMacAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackNewLastSrcAddress.setDescription('This object is the SourceAddress of the last\n               readable frame (i.e., counted by\n               rptrMonitorPortReadableFrames) received by this\n               port.  If no frames have been received by this\n               port since the agent began monitoring the port\n               activity, the agent shall return a string of\n               length zero.')
rptrAddrTrackCapacity = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrAddrTrackCapacity.setDescription('The maximum number of addresses that can be\n               detected on this port. This value indicates\n               to the maximum  number of entries in the\n               rptrExtAddrTrackTable relative to this port.\n\n               If this object has the value of 1, the agent\n               implements only the LastSourceAddress mechanism\n               described by RFC 1368 or RFC 1516.')
rptrExtAddrTrackTable = MibTable((1, 3, 6, 1, 2, 1, 22, 3, 3, 2), )
if mibBuilder.loadTexts: rptrExtAddrTrackTable.setDescription('A table to extend the address tracking table (i.e.,\n               rptrAddrTrackTable) with a list of source MAC\n               addresses that were recently received on each port.\n               The number of ports is the same as the number\n               of entries in table rptrPortTable. The number of\n               entries in this table depends on the agent/repeater\n               implementation and the number of different\n               addresses received on each port.\n\n               The first entry for each port contains\n               the same MAC address that is given by the\n               rptrAddrTrackNewLastSrcAddress for that port.\n\n               Entries in this table for a particular port are\n               retained when that port is switched from one\n               repeater to another.\n\n               The ordering of MAC addresses listed for a\n               particular port is implementation dependent.')
rptrExtAddrTrackEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 3, 3, 2, 1), ).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrAddrTrackGroupIndex"), (0, "SNMP-REPEATER-MIB", "rptrAddrTrackPortIndex"), (0, "SNMP-REPEATER-MIB", "rptrExtAddrTrackMacIndex"))
if mibBuilder.loadTexts: rptrExtAddrTrackEntry.setDescription('A row in the table of extended address tracking\n               information for ports. Entries can not be directly\n               created or deleted via SNMP operations.')
rptrExtAddrTrackMacIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrExtAddrTrackMacIndex.setDescription('The index of a source MAC address seen on\n               the port.\n\n               The ordering of MAC addresses listed for a\n               particular port is implementation dependent.\n\n               There is no implied relationship between a\n               particular index and a particular MAC\n               address.  The index for a particular MAC\n               address may change without notice.')
rptrExtAddrTrackSourceAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 3, 3, 2, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrExtAddrTrackSourceAddress.setDescription('The source MAC address from a readable frame\n               (i.e., counted by rptrMonitorPortReadableFrames)\n               recently received by the port.')
rptrTopNPortControlTable = MibTable((1, 3, 6, 1, 2, 1, 22, 4, 3, 1), )
if mibBuilder.loadTexts: rptrTopNPortControlTable.setDescription("A table of control records for reports on the top `N'\n           ports for the rate of a selected counter. The number\n           of entries depends on the configuration of the agent.\n           The maximum number of entries is implementation\n           dependent.")
rptrTopNPortControlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 4, 3, 1, 1), ).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrTopNPortControlIndex"))
if mibBuilder.loadTexts: rptrTopNPortControlEntry.setDescription('A set of parameters that control the creation of a\n               report of the top N ports according to several metrics.')
rptrTopNPortControlIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrTopNPortControlIndex.setDescription('An index that uniquely identifies an entry in the\n               rptrTopNPortControl table.  Each such entry defines\n               one top N report prepared for a repeater or system.')
rptrTopNPortRepeaterId = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rptrTopNPortRepeaterId.setDescription("Identifies the repeater for which a top N report will\n               be prepared (see rptrInfoId).  If the value of this\n               object is positive, only ports assigned to this repeater\n               will be used to form the list in which to order the\n               Top N table.  If this value is zero, all ports will be\n               eligible for inclusion on the list.\n\n               The value of this object may not be modified if the\n               associated rptrTopNPortRowStatus object is equal to\n               active(1).\n               If, for a particular row in this table, the repeater\n               specified by the value of this object goes away (is\n               removed from the rptrInfoTable) while the associated\n               rptrTopNPortRowStatus object is equal to active(1),\n               the row in this table is preserved by the agent but\n               the value of rptrTopNPortRowStatus is changed to\n               notInService(2), and the agent may time out the row\n               if appropriate.  If the specified repeater comes\n               back (reappears in the rptrInfoTable) before the row\n               has been timed out, the management station must set\n               the value of the rptrTopNPortRowStatus object back\n               to active(1) if desired (the agent doesn't do this\n               automatically).")
rptrTopNPortRateBase = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,))).clone(namedValues=NamedValues(("readableFrames", 1), ("readableOctets", 2), ("fcsErrors", 3), ("alignmentErrors", 4), ("frameTooLongs", 5), ("shortEvents", 6), ("runts", 7), ("collisions", 8), ("lateEvents", 9), ("veryLongEvents", 10), ("dataRateMismatches", 11), ("autoPartitions", 12), ("totalErrors", 13), ("isolates", 14), ("symbolErrors", 15),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rptrTopNPortRateBase.setDescription('The monitored variable, which the rptrTopNPortRate\n               variable is based upon.\n\n               The value of this object may not be modified if\n               the associated rptrTopNPortRowStatus object has\n               a value of active(1).')
rptrTopNPortTimeRemaining = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rptrTopNPortTimeRemaining.setDescription('The number of seconds left in the report\n               currently being collected.  When this object\n               is modified by the management station, a new\n               collection is started, possibly aborting a\n               currently running report.  The new value is\n               used as the requested duration of this report,\n               which is loaded into the associated\n               rptrTopNPortDuration object.\n\n               When this object is set to a non-zero value,\n               any associated rptrTopNPortEntries shall be\n               made inaccessible by the agent.  While the value\n               of this object is non-zero, it decrements by one\n               per second until it reaches zero.  During this\n               time, all associated rptrTopNPortEntries shall\n               remain inaccessible.  At the time that this object\n               decrements to zero, the report is made accessible\n               in the rptrTopNPortTable.  Thus, the rptrTopNPort\n               table needs to be created only at the end of the\n               collection interval.\n\n               If the value of this object is set to zero\n               while the associated report is running, the\n               running report is aborted and no associated\n               rptrTopNPortEntries are created.')
rptrTopNPortDuration = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrTopNPortDuration.setDescription('The number of seconds that this report has\n               collected during the last sampling interval,\n               or if this report is currently being collected,\n               the number of seconds that this report is being\n               collected during this sampling interval.\n\n               When the associated rptrTopNPortTimeRemaining\n               object is set, this object shall be set by the\n               agent to the same value and shall not be modified\n               until the next time the rptrTopNPortTimeRemaining\n               is set.\n\n               This value shall be zero if no reports have been\n               requested for this rptrTopNPortControlEntry.')
rptrTopNPortRequestedSize = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 1, 1, 6), Integer32().clone(10)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rptrTopNPortRequestedSize.setDescription('The maximum number of repeater ports requested\n               for the Top N Table.\n\n               When this object is created or modified, the\n               agent should set rptrTopNPortGrantedSize as close\n               to this object as is possible for the particular\n               implementation and available resources.')
rptrTopNPortGrantedSize = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrTopNPortGrantedSize.setDescription('The maximum number of repeater ports in the\n               top N table.\n\n               When the associated rptrTopNPortRequestedSize object is\n               created or modified, the agent should set this object as\n               closely to the requested value as is possible for the\n               particular implementation and available resources.  The\n               agent must not lower this value except as a result of a\n               set to the associated rptrTopNPortRequestedSize object.')
rptrTopNPortStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 1, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrTopNPortStartTime.setDescription('The value of sysUpTime when this top N report was\n               last started.  In other words, this is the time that\n               the associated rptrTopNPortTimeRemaining object was\n               modified to start the requested report.\n\n               If the report has not yet been started, the value\n               of this object is zero.')
rptrTopNPortOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 1, 1, 9), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rptrTopNPortOwner.setDescription('The entity that configured this entry and is\n               using the resources assigned to it.')
rptrTopNPortRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 1, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rptrTopNPortRowStatus.setDescription('The status of this row.\n\n              If the value of this object is not equal to\n              active(1), all associated entries in the\n              rptrTopNPortTable shall be deleted by the\n              agent.')
rptrTopNPortTable = MibTable((1, 3, 6, 1, 2, 1, 22, 4, 3, 2), )
if mibBuilder.loadTexts: rptrTopNPortTable.setDescription("A table of reports for the top `N' ports based on\n               setting of associated control table entries. The\n               maximum number of entries depends on the number\n               of entries in table rptrTopNPortControlTable and\n               the value of object rptrTopNPortGrantedSize for\n               each entry.\n\n               For each entry in the rptrTopNPortControlTable,\n               repeater ports with the highest value of\n               rptrTopNPortRate shall be placed in this table\n               in decreasing order of that rate until there is\n               no more room or until there are no more ports.")
rptrTopNPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 22, 4, 3, 2, 1), ).setIndexNames((0, "SNMP-REPEATER-MIB", "rptrTopNPortControlIndex"), (0, "SNMP-REPEATER-MIB", "rptrTopNPortIndex"))
if mibBuilder.loadTexts: rptrTopNPortEntry.setDescription('A set of statistics for a repeater port that is\n               part of a top N report.')
rptrTopNPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrTopNPortIndex.setDescription('An index that uniquely identifies an entry in\n               the rptrTopNPort table among those in the same\n               report.  This index is between 1 and N, where N\n               is the number of entries in this report.  Increasing\n               values of rptrTopNPortIndex shall be assigned to\n               entries with decreasing values of rptrTopNPortRate\n               until index N is assigned to the entry with the\n               lowest value of rptrTopNPortRate or there are no\n               more rptrTopNPortEntries.\n\n               No ports are included in a report where their\n               value of rptrTopNPortRate would be zero.')
rptrTopNPortGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrTopNPortGroupIndex.setDescription('This object identifes the group containing\n               the port for this entry. (See also object\n               type rptrGroupIndex.)')
rptrTopNPortPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrTopNPortPortIndex.setDescription('The index of the repeater port.\n           (See object type rptrPortIndex.)')
rptrTopNPortRate = MibTableColumn((1, 3, 6, 1, 2, 1, 22, 4, 3, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrTopNPortRate.setDescription("The amount of change in the selected variable\n               during this sampling interval for the identified\n               port.  The selected variable is that port's\n               instance of the object selected by\n               rptrTopNPortRateBase.")
rptrHealth = NotificationType((1, 3, 6, 1, 2, 1, 22, 0, 1)).setObjects(*(("SNMP-REPEATER-MIB", "rptrOperStatus"),))
if mibBuilder.loadTexts: rptrHealth.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\n               In a system containing a single managed repeater,\n               the rptrHealth notification conveys information\n               related to the operational status of the repeater.\n               It is sent either when the value of\n               rptrOperStatus changes, or upon completion of a\n               non-disruptive test.\n\n               The rptrHealth notification must contain the\n               rptrOperStatus object.  The agent may optionally\n               include the rptrHealthText object in the varBind\n               list.  See the rptrOperStatus and rptrHealthText\n               objects for descriptions of the information that\n               is sent.\n\n               The agent must throttle the generation of\n               consecutive rptrHealth traps so that there is at\n               least a five-second gap between traps of this\n               type.  When traps are throttled, they are dropped,\n               not queued for sending at a future time.  (Note\n               that 'generating' a trap means sending to all\n               configured recipients.)")
rptrGroupChange = NotificationType((1, 3, 6, 1, 2, 1, 22, 0, 2)).setObjects(*(("SNMP-REPEATER-MIB", "rptrGroupIndex"),))
if mibBuilder.loadTexts: rptrGroupChange.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\n               In a system containing a single managed repeater,\n               this notification is sent when a change occurs in the\n               group structure of the repeater.  This occurs only\n               when a group is logically or physically removed\n               from or added to a repeater.  The varBind list\n               contains the identifier of the group that was\n               removed or added.\n\n               The agent must throttle the generation of\n               consecutive rptrGroupChange traps for the same\n               group so that there is at least a five-second gap\n               between traps of this type.  When traps are\n               throttled, they are dropped, not queued for\n               sending at a future time.  (Note that 'generating'\n               a trap means sending to all configured\n               recipients.)")
rptrResetEvent = NotificationType((1, 3, 6, 1, 2, 1, 22, 0, 3)).setObjects(*(("SNMP-REPEATER-MIB", "rptrOperStatus"),))
if mibBuilder.loadTexts: rptrResetEvent.setDescription("********* THIS OBJECT IS DEPRECATED **********\n\n               In a system containing a single managed repeater-unit,\n               the rptrResetEvent notification conveys information\n               related to the operational status of the repeater.\n               This trap is sent on completion of a repeater\n               reset action.  A repeater reset action is defined\n               as an a transition to the START state of Fig 9-2\n               in section 9 [IEEE 802.3 Std], when triggered by a\n               management command (e.g., an SNMP Set on the\n               rptrReset object).\n\n               The agent must throttle the generation of\n               consecutive rptrResetEvent traps so that there is\n               at least a five-second gap between traps of this\n               type.  When traps are throttled, they are dropped,\n               not queued for sending at a future time.  (Note\n               that 'generating' a trap means sending to all\n               configured recipients.)\n\n               The rptrResetEvent trap is not sent when the agent\n               restarts and sends an SNMP coldStart or warmStart\n               trap.  However, it is recommended that a repeater\n               agent send the rptrOperStatus object as an\n               optional object with its coldStart and warmStart\n               trap PDUs.\n\n               The rptrOperStatus object must be included in the\n               varbind list sent with this trap.  The agent may\n               optionally include the rptrHealthText object as\n               well.")
rptrInfoHealth = NotificationType((1, 3, 6, 1, 2, 1, 22, 0, 4)).setObjects(*(("SNMP-REPEATER-MIB", "rptrInfoOperStatus"),))
if mibBuilder.loadTexts: rptrInfoHealth.setDescription("In a system containing multiple managed repeaters,\n               the rptrInfoHealth notification conveys information\n               related to the operational status of a repeater.\n               It is sent either when the value of rptrInfoOperStatus\n               changes, or upon completion of a non-disruptive test.\n\n               The agent must throttle the generation of\n               consecutive rptrInfoHealth notifications for\n               the same repeater so that there is at least\n               a five-second gap between notifications of this type.\n               When notifications are throttled, they are dropped,\n               not queued for sending at a future time.  (Note\n               that 'generating' a notification means sending\n               to all configured recipients.)")
rptrInfoResetEvent = NotificationType((1, 3, 6, 1, 2, 1, 22, 0, 5)).setObjects(*(("SNMP-REPEATER-MIB", "rptrInfoOperStatus"),))
if mibBuilder.loadTexts: rptrInfoResetEvent.setDescription("In a system containing multiple managed\n               repeaters, the rptrInfoResetEvent notification\n               conveys information related to the operational\n               status of a repeater. This notification is sent\n               on completion of a repeater reset action.  A\n               repeater reset action is defined as a transition\n               to the START state of Fig 9-2 in section 9 of\n               [IEEE 802.3 Std], when triggered by a management\n               command (e.g., an SNMP Set on the rptrInfoReset\n               object).\n\n               The agent must throttle the generation of\n               consecutive rptrInfoResetEvent notifications for\n               a single repeater so that there is at least\n               a five-second gap between notifications of\n               this type.  When notifications are throttled,\n               they are dropped, not queued for sending at\n               a future time.  (Note that 'generating' a\n               notification means sending to all configured\n               recipients.)\n\n               The rptrInfoResetEvent is not sent when the\n               agent restarts and sends an SNMP coldStart or\n               warmStart trap.  However, it is recommended that\n               a repeater agent send the rptrInfoOperStatus\n               object as an optional object with its coldStart\n               and warmStart trap PDUs.")
snmpRptrModConf = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 5, 1))
snmpRptrModCompls = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 5, 1, 1))
snmpRptrModObjGrps = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 5, 1, 2))
snmpRptrModNotGrps = MibIdentifier((1, 3, 6, 1, 2, 1, 22, 5, 1, 3))
snmpRptrGrpBasic1516 = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 1)).setObjects(*(("SNMP-REPEATER-MIB", "rptrGroupCapacity"), ("SNMP-REPEATER-MIB", "rptrOperStatus"), ("SNMP-REPEATER-MIB", "rptrHealthText"), ("SNMP-REPEATER-MIB", "rptrReset"), ("SNMP-REPEATER-MIB", "rptrNonDisruptTest"), ("SNMP-REPEATER-MIB", "rptrTotalPartitionedPorts"), ("SNMP-REPEATER-MIB", "rptrGroupIndex"), ("SNMP-REPEATER-MIB", "rptrGroupDescr"), ("SNMP-REPEATER-MIB", "rptrGroupObjectID"), ("SNMP-REPEATER-MIB", "rptrGroupOperStatus"), ("SNMP-REPEATER-MIB", "rptrGroupLastOperStatusChange"), ("SNMP-REPEATER-MIB", "rptrGroupPortCapacity"), ("SNMP-REPEATER-MIB", "rptrPortGroupIndex"), ("SNMP-REPEATER-MIB", "rptrPortIndex"), ("SNMP-REPEATER-MIB", "rptrPortAdminStatus"), ("SNMP-REPEATER-MIB", "rptrPortAutoPartitionState"), ("SNMP-REPEATER-MIB", "rptrPortOperStatus"),))
if mibBuilder.loadTexts: snmpRptrGrpBasic1516.setDescription('********* THIS GROUP IS DEPRECATED **********\n\n           Basic group from RFCs 1368 and 1516.\n\n           NOTE: this object group is DEPRECATED and replaced\n                 with snmpRptrGrpBasic.')
snmpRptrGrpMonitor1516 = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 2)).setObjects(*(("SNMP-REPEATER-MIB", "rptrMonitorTransmitCollisions"), ("SNMP-REPEATER-MIB", "rptrMonitorGroupIndex"), ("SNMP-REPEATER-MIB", "rptrMonitorGroupTotalFrames"), ("SNMP-REPEATER-MIB", "rptrMonitorGroupTotalOctets"), ("SNMP-REPEATER-MIB", "rptrMonitorGroupTotalErrors"), ("SNMP-REPEATER-MIB", "rptrMonitorPortGroupIndex"), ("SNMP-REPEATER-MIB", "rptrMonitorPortIndex"), ("SNMP-REPEATER-MIB", "rptrMonitorPortReadableFrames"), ("SNMP-REPEATER-MIB", "rptrMonitorPortReadableOctets"), ("SNMP-REPEATER-MIB", "rptrMonitorPortFCSErrors"), ("SNMP-REPEATER-MIB", "rptrMonitorPortAlignmentErrors"), ("SNMP-REPEATER-MIB", "rptrMonitorPortFrameTooLongs"), ("SNMP-REPEATER-MIB", "rptrMonitorPortShortEvents"), ("SNMP-REPEATER-MIB", "rptrMonitorPortRunts"), ("SNMP-REPEATER-MIB", "rptrMonitorPortCollisions"), ("SNMP-REPEATER-MIB", "rptrMonitorPortLateEvents"), ("SNMP-REPEATER-MIB", "rptrMonitorPortVeryLongEvents"), ("SNMP-REPEATER-MIB", "rptrMonitorPortDataRateMismatches"), ("SNMP-REPEATER-MIB", "rptrMonitorPortAutoPartitions"), ("SNMP-REPEATER-MIB", "rptrMonitorPortTotalErrors"),))
if mibBuilder.loadTexts: snmpRptrGrpMonitor1516.setDescription('********* THIS GROUP IS DEPRECATED **********\n\n           Monitor group from RFCs 1368 and 1516.\n\n           NOTE: this object group is DEPRECATED and replaced\n                 with snmpRptrGrpMonitor.')
snmpRptrGrpAddrTrack1368 = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 3)).setObjects(*(("SNMP-REPEATER-MIB", "rptrAddrTrackGroupIndex"), ("SNMP-REPEATER-MIB", "rptrAddrTrackPortIndex"), ("SNMP-REPEATER-MIB", "rptrAddrTrackLastSourceAddress"), ("SNMP-REPEATER-MIB", "rptrAddrTrackSourceAddrChanges"),))
if mibBuilder.loadTexts: snmpRptrGrpAddrTrack1368.setDescription('Address tracking group from RFC 1368.\n\n           NOTE: this object group is OBSOLETE and replaced\n                 with snmpRptrGrpAddrTrack1516.')
snmpRptrGrpAddrTrack1516 = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 4)).setObjects(*(("SNMP-REPEATER-MIB", "rptrAddrTrackGroupIndex"), ("SNMP-REPEATER-MIB", "rptrAddrTrackPortIndex"), ("SNMP-REPEATER-MIB", "rptrAddrTrackLastSourceAddress"), ("SNMP-REPEATER-MIB", "rptrAddrTrackSourceAddrChanges"), ("SNMP-REPEATER-MIB", "rptrAddrTrackNewLastSrcAddress"),))
if mibBuilder.loadTexts: snmpRptrGrpAddrTrack1516.setDescription('********* THIS GROUP IS DEPRECATED **********\n           Address tracking group from RFC 1516.\n\n           NOTE: this object group is DEPRECATED and\n                 replaced with snmpRptrGrpAddrTrack.')
snmpRptrGrpBasic = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 5)).setObjects(*(("SNMP-REPEATER-MIB", "rptrGroupIndex"), ("SNMP-REPEATER-MIB", "rptrGroupObjectID"), ("SNMP-REPEATER-MIB", "rptrGroupOperStatus"), ("SNMP-REPEATER-MIB", "rptrGroupPortCapacity"), ("SNMP-REPEATER-MIB", "rptrPortGroupIndex"), ("SNMP-REPEATER-MIB", "rptrPortIndex"), ("SNMP-REPEATER-MIB", "rptrPortAdminStatus"), ("SNMP-REPEATER-MIB", "rptrPortAutoPartitionState"), ("SNMP-REPEATER-MIB", "rptrPortOperStatus"), ("SNMP-REPEATER-MIB", "rptrPortRptrId"), ("SNMP-REPEATER-MIB", "rptrInfoId"), ("SNMP-REPEATER-MIB", "rptrInfoRptrType"), ("SNMP-REPEATER-MIB", "rptrInfoOperStatus"), ("SNMP-REPEATER-MIB", "rptrInfoReset"), ("SNMP-REPEATER-MIB", "rptrInfoPartitionedPorts"), ("SNMP-REPEATER-MIB", "rptrInfoLastChange"),))
if mibBuilder.loadTexts: snmpRptrGrpBasic.setDescription('Basic group for a system with one or more\n           repeater-units in multi-segment (post-RFC 1516)\n           version of the MIB module.')
snmpRptrGrpMonitor = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 6)).setObjects(*(("SNMP-REPEATER-MIB", "rptrMonitorPortGroupIndex"), ("SNMP-REPEATER-MIB", "rptrMonitorPortIndex"), ("SNMP-REPEATER-MIB", "rptrMonitorPortReadableFrames"), ("SNMP-REPEATER-MIB", "rptrMonitorPortReadableOctets"), ("SNMP-REPEATER-MIB", "rptrMonitorPortFCSErrors"), ("SNMP-REPEATER-MIB", "rptrMonitorPortAlignmentErrors"), ("SNMP-REPEATER-MIB", "rptrMonitorPortFrameTooLongs"), ("SNMP-REPEATER-MIB", "rptrMonitorPortShortEvents"), ("SNMP-REPEATER-MIB", "rptrMonitorPortRunts"), ("SNMP-REPEATER-MIB", "rptrMonitorPortCollisions"), ("SNMP-REPEATER-MIB", "rptrMonitorPortLateEvents"), ("SNMP-REPEATER-MIB", "rptrMonitorPortVeryLongEvents"), ("SNMP-REPEATER-MIB", "rptrMonitorPortDataRateMismatches"), ("SNMP-REPEATER-MIB", "rptrMonitorPortAutoPartitions"), ("SNMP-REPEATER-MIB", "rptrMonitorPortTotalErrors"), ("SNMP-REPEATER-MIB", "rptrMonitorPortLastChange"), ("SNMP-REPEATER-MIB", "rptrMonTxCollisions"), ("SNMP-REPEATER-MIB", "rptrMonTotalFrames"), ("SNMP-REPEATER-MIB", "rptrMonTotalErrors"), ("SNMP-REPEATER-MIB", "rptrMonTotalOctets"),))
if mibBuilder.loadTexts: snmpRptrGrpMonitor.setDescription('Monitor group for a system with one or more\n           repeater-units in multi-segment (post-RFC 1516)\n           version of the MIB module.')
snmpRptrGrpMonitor100 = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 7)).setObjects(*(("SNMP-REPEATER-MIB", "rptrMonitorPortIsolates"), ("SNMP-REPEATER-MIB", "rptrMonitorPortSymbolErrors"), ("SNMP-REPEATER-MIB", "rptrMonitorPortUpper32Octets"), ("SNMP-REPEATER-MIB", "rptrMonUpper32TotalOctets"),))
if mibBuilder.loadTexts: snmpRptrGrpMonitor100.setDescription('Monitor group for 100Mb/s ports and repeaters\n           in a system with one or more repeater-units in\n           multi-segment (post-RFC 1516) version of the MIB\n           module.  Systems which support Counter64 should\n           also implement snmpRptrGrpMonitor100w64.')
snmpRptrGrpMonitor100w64 = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 8)).setObjects(*(("SNMP-REPEATER-MIB", "rptrMonitorPortHCReadableOctets"), ("SNMP-REPEATER-MIB", "rptrMonHCTotalOctets"),))
if mibBuilder.loadTexts: snmpRptrGrpMonitor100w64.setDescription('Monitor group for 100Mb/s ports and repeaters in a\n           system with one or more repeater-units and support\n           for Counter64.')
snmpRptrGrpAddrTrack = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 9)).setObjects(*(("SNMP-REPEATER-MIB", "rptrAddrTrackGroupIndex"), ("SNMP-REPEATER-MIB", "rptrAddrTrackPortIndex"), ("SNMP-REPEATER-MIB", "rptrAddrTrackSourceAddrChanges"), ("SNMP-REPEATER-MIB", "rptrAddrTrackNewLastSrcAddress"), ("SNMP-REPEATER-MIB", "rptrAddrTrackCapacity"),))
if mibBuilder.loadTexts: snmpRptrGrpAddrTrack.setDescription('Passive address tracking group for post-RFC 1516\n           version of the MIB module.')
snmpRptrGrpExtAddrTrack = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 10)).setObjects(*(("SNMP-REPEATER-MIB", "rptrExtAddrTrackMacIndex"), ("SNMP-REPEATER-MIB", "rptrExtAddrTrackSourceAddress"),))
if mibBuilder.loadTexts: snmpRptrGrpExtAddrTrack.setDescription('Extended passive address tracking group for\n           a system with one or more repeater-units in\n           post-RFC 1516 version of the MIB module.')
snmpRptrGrpRptrAddrSearch = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 11)).setObjects(*(("SNMP-REPEATER-MIB", "rptrAddrSearchLock"), ("SNMP-REPEATER-MIB", "rptrAddrSearchStatus"), ("SNMP-REPEATER-MIB", "rptrAddrSearchAddress"), ("SNMP-REPEATER-MIB", "rptrAddrSearchState"), ("SNMP-REPEATER-MIB", "rptrAddrSearchGroup"), ("SNMP-REPEATER-MIB", "rptrAddrSearchPort"), ("SNMP-REPEATER-MIB", "rptrAddrSearchOwner"),))
if mibBuilder.loadTexts: snmpRptrGrpRptrAddrSearch.setDescription('Active MAC address search group and topology\n           mapping support for repeaters.')
snmpRptrGrpTopNPort = ObjectGroup((1, 3, 6, 1, 2, 1, 22, 5, 1, 2, 12)).setObjects(*(("SNMP-REPEATER-MIB", "rptrTopNPortControlIndex"), ("SNMP-REPEATER-MIB", "rptrTopNPortRepeaterId"), ("SNMP-REPEATER-MIB", "rptrTopNPortRateBase"), ("SNMP-REPEATER-MIB", "rptrTopNPortTimeRemaining"), ("SNMP-REPEATER-MIB", "rptrTopNPortDuration"), ("SNMP-REPEATER-MIB", "rptrTopNPortRequestedSize"), ("SNMP-REPEATER-MIB", "rptrTopNPortGrantedSize"), ("SNMP-REPEATER-MIB", "rptrTopNPortStartTime"), ("SNMP-REPEATER-MIB", "rptrTopNPortOwner"), ("SNMP-REPEATER-MIB", "rptrTopNPortRowStatus"), ("SNMP-REPEATER-MIB", "rptrTopNPortIndex"), ("SNMP-REPEATER-MIB", "rptrTopNPortGroupIndex"), ("SNMP-REPEATER-MIB", "rptrTopNPortPortIndex"), ("SNMP-REPEATER-MIB", "rptrTopNPortRate"),))
if mibBuilder.loadTexts: snmpRptrGrpTopNPort.setDescription("Top `N' group for repeater ports.")
snmpRptrModComplRFC1368 = ModuleCompliance((1, 3, 6, 1, 2, 1, 22, 5, 1, 1, 1)).setObjects(*(("SNMP-REPEATER-MIB", "snmpRptrGrpBasic1516"), ("SNMP-REPEATER-MIB", "snmpRptrGrpMonitor1516"), ("SNMP-REPEATER-MIB", "snmpRptrGrpAddrTrack1368"),))
if mibBuilder.loadTexts: snmpRptrModComplRFC1368.setDescription('Compliance for RFC 1368.\n\n           NOTE: this module compliance is OBSOLETE and\n                 replaced by snmpRptrModComplRFC1516.')
snmpRptrModComplRFC1516 = ModuleCompliance((1, 3, 6, 1, 2, 1, 22, 5, 1, 1, 2)).setObjects(*(("SNMP-REPEATER-MIB", "snmpRptrGrpBasic1516"), ("SNMP-REPEATER-MIB", "snmpRptrGrpMonitor1516"), ("SNMP-REPEATER-MIB", "snmpRptrGrpAddrTrack1516"),))
if mibBuilder.loadTexts: snmpRptrModComplRFC1516.setDescription('********* THIS COMPLIANCE IS DEPRECATED **********\n\n           Compliance for RFC 1516 and for backwards\n           compatibility with single-repeater,\n           10Mb/s-only implementations.')
snmpRptrModCompl = ModuleCompliance((1, 3, 6, 1, 2, 1, 22, 5, 1, 1, 3)).setObjects(*(("SNMP-REPEATER-MIB", "snmpRptrGrpBasic"), ("SNMP-REPEATER-MIB", "snmpRptrGrpMonitor"), ("SNMP-REPEATER-MIB", "snmpRptrGrpAddrTrack"), ("SNMP-REPEATER-MIB", "snmpRptrGrpMonitor100"), ("SNMP-REPEATER-MIB", "snmpRptrGrpMonitor100w64"), ("SNMP-REPEATER-MIB", "snmpRptrGrpExtAddrTrack"), ("SNMP-REPEATER-MIB", "snmpRptrGrpRptrAddrSearch"), ("SNMP-REPEATER-MIB", "snmpRptrGrpTopNPort"),))
if mibBuilder.loadTexts: snmpRptrModCompl.setDescription('Compliance for the multi-segment version of the\n           MIB module for a system with one or more\n           repeater-units.')
mibBuilder.exportSymbols("SNMP-REPEATER-MIB", rptrTopNPortDuration=rptrTopNPortDuration, rptrGroupLastOperStatusChange=rptrGroupLastOperStatusChange, snmpRptrGrpTopNPort=snmpRptrGrpTopNPort, rptrAllRptrInfo=rptrAllRptrInfo, rptrMonitorGroupTotalErrors=rptrMonitorGroupTotalErrors, rptrGroupPortCapacity=rptrGroupPortCapacity, rptrTopNPortRowStatus=rptrTopNPortRowStatus, rptrGroupIndex=rptrGroupIndex, rptrMonitorPortLastChange=rptrMonitorPortLastChange, rptrMonitor100PortTable=rptrMonitor100PortTable, rptrReset=rptrReset, rptrAddrTrackNewLastSrcAddress=rptrAddrTrackNewLastSrcAddress, rptrAddrSearchTable=rptrAddrSearchTable, snmpRptrGrpBasic=snmpRptrGrpBasic, rptrGroupTable=rptrGroupTable, rptrGroupOperStatus=rptrGroupOperStatus, rptrMon100Table=rptrMon100Table, rptrTopNPortIndex=rptrTopNPortIndex, rptrAddrTrackEntry=rptrAddrTrackEntry, rptrAddrTrackRptrInfo=rptrAddrTrackRptrInfo, snmpDot3RptrMgt=snmpDot3RptrMgt, rptrAddrTrackCapacity=rptrAddrTrackCapacity, rptrMonTotalFrames=rptrMonTotalFrames, rptrTopNPortStartTime=rptrTopNPortStartTime, rptrMon100Entry=rptrMon100Entry, rptrTopNPortInfo=rptrTopNPortInfo, rptrNonDisruptTest=rptrNonDisruptTest, rptrAddrSearchOwner=rptrAddrSearchOwner, rptrGroupCapacity=rptrGroupCapacity, rptrInfoTable=rptrInfoTable, rptrAddrSearchAddress=rptrAddrSearchAddress, rptrExtAddrTrackMacIndex=rptrExtAddrTrackMacIndex, rptrAddrSearchPort=rptrAddrSearchPort, rptrMonTotalOctets=rptrMonTotalOctets, rptrPortIndex=rptrPortIndex, rptrMonTable=rptrMonTable, snmpRptrGrpMonitor100=snmpRptrGrpMonitor100, rptrMonitorPortVeryLongEvents=rptrMonitorPortVeryLongEvents, rptrMonitorPortReadableOctets=rptrMonitorPortReadableOctets, rptrInfoOperStatus=rptrInfoOperStatus, snmpRptrModComplRFC1368=snmpRptrModComplRFC1368, PYSNMP_MODULE_ID=snmpRptrMod, rptrGroupEntry=rptrGroupEntry, snmpRptrModObjGrps=snmpRptrModObjGrps, snmpRptrGrpBasic1516=snmpRptrGrpBasic1516, rptrTopNPortEntry=rptrTopNPortEntry, rptrTopNPortRate=rptrTopNPortRate, rptrPortAdminStatus=rptrPortAdminStatus, rptrMonitorPortGroupIndex=rptrMonitorPortGroupIndex, rptrMonitorPortRunts=rptrMonitorPortRunts, rptrExtAddrTrackTable=rptrExtAddrTrackTable, rptrTotalPartitionedPorts=rptrTotalPartitionedPorts, rptrAddrTrackGroupInfo=rptrAddrTrackGroupInfo, rptrExtAddrTrackEntry=rptrExtAddrTrackEntry, rptrMonTotalErrors=rptrMonTotalErrors, rptrAddrTrackSourceAddrChanges=rptrAddrTrackSourceAddrChanges, rptrMonitorTransmitCollisions=rptrMonitorTransmitCollisions, rptrHealth=rptrHealth, rptrTopNPackage=rptrTopNPackage, rptrInfoRptrType=rptrInfoRptrType, rptrAddrSearchLock=rptrAddrSearchLock, rptrTopNPortPortIndex=rptrTopNPortPortIndex, rptrHealthText=rptrHealthText, rptrMonitorPortReadableFrames=rptrMonitorPortReadableFrames, OptMacAddr=OptMacAddr, rptrMonEntry=rptrMonEntry, snmpRptrGrpAddrTrack1368=snmpRptrGrpAddrTrack1368, snmpRptrModCompl=snmpRptrModCompl, snmpRptrGrpMonitor=snmpRptrGrpMonitor, rptrInfoPartitionedPorts=rptrInfoPartitionedPorts, snmpRptrGrpMonitor100w64=snmpRptrGrpMonitor100w64, rptrMonHCTotalOctets=rptrMonHCTotalOctets, rptrAddrSearchState=rptrAddrSearchState, rptrMonitorAllRptrInfo=rptrMonitorAllRptrInfo, rptrInfoResetEvent=rptrInfoResetEvent, rptrGroupInfo=rptrGroupInfo, rptrAddrSearchGroup=rptrAddrSearchGroup, rptrPortInfo=rptrPortInfo, rptrAddrTrackTable=rptrAddrTrackTable, snmpRptrGrpExtAddrTrack=snmpRptrGrpExtAddrTrack, rptrTopNPortGrantedSize=rptrTopNPortGrantedSize, rptrOperStatus=rptrOperStatus, rptrAddrTrackPortIndex=rptrAddrTrackPortIndex, rptrTopNPortOwner=rptrTopNPortOwner, rptrResetEvent=rptrResetEvent, rptrTopNPortTable=rptrTopNPortTable, rptrBasicPackage=rptrBasicPackage, rptrGroupChange=rptrGroupChange, rptrMonTxCollisions=rptrMonTxCollisions, rptrAddrTrackPackage=rptrAddrTrackPackage, rptrMonitorPortFCSErrors=rptrMonitorPortFCSErrors, rptrTopNPortControlEntry=rptrTopNPortControlEntry, snmpRptrGrpMonitor1516=snmpRptrGrpMonitor1516, rptrPortRptrId=rptrPortRptrId, rptrMonitorPortCollisions=rptrMonitorPortCollisions, rptrMonitorPortUpper32Octets=rptrMonitorPortUpper32Octets, snmpRptrGrpAddrTrack=snmpRptrGrpAddrTrack, rptrMonitorGroupInfo=rptrMonitorGroupInfo, rptrTopNPortControlIndex=rptrTopNPortControlIndex, snmpRptrGrpRptrAddrSearch=snmpRptrGrpRptrAddrSearch, rptrPortGroupIndex=rptrPortGroupIndex, rptrInfoLastChange=rptrInfoLastChange, rptrPortAutoPartitionState=rptrPortAutoPartitionState, rptrMonitorPortLateEvents=rptrMonitorPortLateEvents, rptrInfoId=rptrInfoId, rptrTopNPortTimeRemaining=rptrTopNPortTimeRemaining, rptrInfoHealth=rptrInfoHealth, rptrAddrTrackLastSourceAddress=rptrAddrTrackLastSourceAddress, rptrGroupObjectID=rptrGroupObjectID, rptrMonitorPortInfo=rptrMonitorPortInfo, rptrInfoReset=rptrInfoReset, rptrTopNPortRateBase=rptrTopNPortRateBase, rptrMonitorGroupTable=rptrMonitorGroupTable, snmpRptrModCompls=snmpRptrModCompls, rptrMonitorGroupTotalFrames=rptrMonitorGroupTotalFrames, rptrAddrTrackPortInfo=rptrAddrTrackPortInfo, rptrMonitorGroupEntry=rptrMonitorGroupEntry, rptrMonitorPortEntry=rptrMonitorPortEntry, rptrMonitorPortIsolates=rptrMonitorPortIsolates, snmpRptrModComplRFC1516=snmpRptrModComplRFC1516, rptrAddrSearchStatus=rptrAddrSearchStatus, rptrAddrTrackGroupIndex=rptrAddrTrackGroupIndex, rptrMonitorPortShortEvents=rptrMonitorPortShortEvents, rptrTopNPortRepeaterId=rptrTopNPortRepeaterId, snmpRptrModNotGrps=snmpRptrModNotGrps, rptrMonitorGroupTotalOctets=rptrMonitorGroupTotalOctets, rptrMonitorPackage=rptrMonitorPackage, rptrMonitorPortFrameTooLongs=rptrMonitorPortFrameTooLongs, rptrTopNPortRequestedSize=rptrTopNPortRequestedSize, rptrRptrInfo=rptrRptrInfo, rptrTopNRptrInfo=rptrTopNRptrInfo, snmpRptrGrpAddrTrack1516=snmpRptrGrpAddrTrack1516, rptrGroupDescr=rptrGroupDescr, rptrTopNGroupInfo=rptrTopNGroupInfo, rptrMonitorRptrInfo=rptrMonitorRptrInfo, rptrTopNPortGroupIndex=rptrTopNPortGroupIndex, rptrExtAddrTrackSourceAddress=rptrExtAddrTrackSourceAddress, snmpRptrMod=snmpRptrMod, rptrMonitorGroupIndex=rptrMonitorGroupIndex, rptrAddrSearchEntry=rptrAddrSearchEntry, snmpRptrModConf=snmpRptrModConf, rptrMonitorPortDataRateMismatches=rptrMonitorPortDataRateMismatches, rptrMonitor100PortEntry=rptrMonitor100PortEntry, rptrMonitorPortAlignmentErrors=rptrMonitorPortAlignmentErrors, rptrMonitorPortSymbolErrors=rptrMonitorPortSymbolErrors, rptrMonitorPortTotalErrors=rptrMonitorPortTotalErrors, rptrMonitorPortTable=rptrMonitorPortTable, rptrMonitorPortAutoPartitions=rptrMonitorPortAutoPartitions, rptrPortOperStatus=rptrPortOperStatus, rptrMonitorPortIndex=rptrMonitorPortIndex, rptrPortTable=rptrPortTable, rptrPortEntry=rptrPortEntry, rptrInfoEntry=rptrInfoEntry, rptrMonUpper32TotalOctets=rptrMonUpper32TotalOctets, rptrTopNPortControlTable=rptrTopNPortControlTable, rptrMonitorPortHCReadableOctets=rptrMonitorPortHCReadableOctets)
