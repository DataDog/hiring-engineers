#
# PySNMP MIB module APPLETALK-MIB (http://pysnmp.sf.net)
# ASN.1 source http://mibs.snmplabs.com:80/asn1/APPLETALK-MIB
# Produced by pysmi-0.0.7 at Sun Feb 14 00:05:10 2016
# On host bldfarm platform Linux version 4.1.13-100.fc21.x86_64 by user goose
# Using Python version 3.5.0 (default, Jan  5 2016, 17:11:52) 
#
( Integer, OctetString, ObjectIdentifier, ) = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
( ModuleCompliance, NotificationGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
( Unsigned32, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, mib_2, Integer32, ModuleIdentity, ObjectIdentity, IpAddress, Bits, Counter64, TimeTicks, MibIdentifier, NotificationType, Gauge32, iso, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "mib-2", "Integer32", "ModuleIdentity", "ObjectIdentity", "IpAddress", "Bits", "Counter64", "TimeTicks", "MibIdentifier", "NotificationType", "Gauge32", "iso")
( TextualConvention, DisplayString, ) = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
appletalk = MibIdentifier((1, 3, 6, 1, 2, 1, 13))
class ATNetworkNumber(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(2,2)
    fixedLength = 2

class DdpNodeAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(3,3)
    fixedLength = 3

class DdpSocketAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(4,4)
    fixedLength = 4

class ATName(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(0,32)

llap = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 1))
aarp = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 2))
atport = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 3))
ddp = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 4))
rtmp = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 5))
kip = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 6))
zipRouter = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 7))
nbp = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 8))
atecho = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 9))
atp = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 10))
pap = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 11))
asp = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 12))
adsp = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 13))
atportptop = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 14))
rtmpStub = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 16))
zipEndNode = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 17))
perPort = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 18))
llapTable = MibTable((1, 3, 6, 1, 2, 1, 13, 1, 1), )
if mibBuilder.loadTexts: llapTable.setDescription('The list of LLAP entries.')
llapEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 1, 1, 1), ).setIndexNames((0, "APPLETALK-MIB", "llapIfIndex"))
if mibBuilder.loadTexts: llapEntry.setDescription('An LLAP entry containing objects for the LocalTalk\n                  Link Access Protocol for a particular LocalTalk\n                  interface.\n\n                  As an example, an instance of the llapOutPkts object\n                  might be named llapOutPks.1')
llapIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: llapIfIndex.setDescription('The LLAP interface to which this entry pertains.\n                  The interface identified by a particular value of\n                  this index is the same interface as identified\n                  by the same value of ifIndex.')
llapInPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 1, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: llapInPkts.setDescription('The total number of good data packets received on\n                  this LocalTalk interface.')
llapOutPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: llapOutPkts.setDescription('The total number of data packets transmitted on\n                  this LocalTalk interface.')
llapInNoHandlers = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: llapInNoHandlers.setDescription('The total number of good packets received on this\n                  LocalTalk interface for which there was no protocol\n                  handler.')
llapInLengthErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: llapInLengthErrors.setDescription('The total number of packets received on this LocalTalk\n                  interface whose actual length did not match the length\n                  in the header.')
llapInErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: llapInErrors.setDescription('The total number of packets containing errors received\n                  on this LocalTalk interface.')
llapCollisions = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: llapCollisions.setDescription('The total number of collisions assumed on this\n                  LocalTalk interface due to the lack of a lapCTS reply.')
llapDefers = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: llapDefers.setDescription('The total number of times this LocalTalk interface\n                  deferred to other packets.')
llapNoDataErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: llapNoDataErrors.setDescription('The total number of times this LocalTalk interface\n                  received a lapRTS packet and expected a data packet,\n                  but did not receive any data packet.')
llapRandomCTSErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: llapRandomCTSErrors.setDescription('The total number of times this LocalTalk interface\n                  received a lapCTS packet that was not solicited by a\n                  lapRTS packet.')
llapFCSErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: llapFCSErrors.setDescription('The total number of times this LocalTalk interface\n                  received a packet with an FCS (Frame Check Sequence)\n                  error.')
aarpTable = MibTable((1, 3, 6, 1, 2, 1, 13, 2, 1), )
if mibBuilder.loadTexts: aarpTable.setDescription('The AppleTalk Address Translation Table contains an\n                  equivalence of AppleTalk Network Addresses to the link\n                  layer physical address.')
aarpEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 2, 1, 1), ).setIndexNames((0, "APPLETALK-MIB", "aarpIfIndex"), (0, "APPLETALK-MIB", "aarpNetAddress"))
if mibBuilder.loadTexts: aarpEntry.setDescription('Each entry contains one AppleTalk Network Address to\n                  physical address equivalence.\n\n                  As an example, an instance of the aarpPhysAddress\n                  object might be named aarpPhysAddress.1.0.80.234')
aarpIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aarpIfIndex.setDescription("The interface on which this entry's equivalence is\n                  effective.  The interface identified by a particular\n                  value of this index is the same interface as\n                  identified by the same value of ifIndex.")
aarpPhysAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 2, 1, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aarpPhysAddress.setDescription('The media-dependent physical address.')
aarpNetAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 2, 1, 1, 3), DdpNodeAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aarpNetAddress.setDescription('The AppleTalk Network Address corresponding to the\n                  media-dependent physical address.')
aarpStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aarpStatus.setDescription('The status of this AARP entry.\n                  Setting this object to the value invalid(2) has the\n                  effect of invalidating the corresponding entry in the\n                  aarpTable.  That is, it effectively disassociates\n                  the mapping identified with said entry.  It is an\n                  implementation-specific matter as to whether the agent\n                  removes an invalidated entry from the table.\n                  Accordingly, management stations must be prepared to\n                  receive from agents tabular information corresponding\n                  to entries not currently in use.  Proper\n                  interpretation of such entries requires examination\n                  of the relevant aarpStatus object.')
aarpLookups = MibScalar((1, 3, 6, 1, 2, 1, 13, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aarpLookups.setDescription('The number of times the AARP cache for this entity\n                  was searched.')
aarpHits = MibScalar((1, 3, 6, 1, 2, 1, 13, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aarpHits.setDescription('The number of times an entry was searched for and\n                  found in the AARP cache for this entity.')
atportTable = MibTable((1, 3, 6, 1, 2, 1, 13, 3, 1), )
if mibBuilder.loadTexts: atportTable.setDescription('A list of AppleTalk ports for this entity.')
atportEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 3, 1, 1), ).setIndexNames((0, "APPLETALK-MIB", "atportIndex"))
if mibBuilder.loadTexts: atportEntry.setDescription('The description of one of the AppleTalk\n                  ports on this entity.\n\n                  As an example, an instance of the atportNetFrom object\n                  might be named atportNetFrom.2')
atportIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atportIndex.setDescription("A unique value for each AppleTalk port.\n                  Its value is between 1 and the total number of\n                  AppleTalk ports.  The value for each port must\n                  remain constant at least from the re-initialization\n                  of the entity's network management system to the\n                  next re-initialization.")
atportDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportDescr.setDescription('A text string containing information about the\n                  port.  This string is intended for presentation\n                  to a human; it must not contain anything but printable\n                  ASCII characters.')
atportType = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,))).clone(namedValues=NamedValues(("other", 1), ("localtalk", 2), ("ethertalk1", 3), ("ethertalk2", 4), ("tokentalk", 5), ("iptalk", 6), ("serialPPP", 7), ("serialNonstandard", 8), ("virtual", 9), ("fdditalk", 10), ("arctalk", 11), ("smdstalk", 12), ("aurp", 13), ("frameRelay", 14), ("x25", 15), ("ip", 16), ("osi", 17), ("decnetIV", 18), ("arap", 19), ("isdnInThePacketMode", 20), ("nonAppleTalk3Com", 21), ("ipx", 22), ("arns", 23), ("hdlc", 24),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportType.setDescription('The type of port, distinguished by the protocol\n                  immediately below DDP in the protocol stack.')
atportNetStart = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 4), ATNetworkNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportNetStart.setDescription('The first AppleTalk network address in the range\n                  configured for this port.  If this port is not a\n                  native AppleTalk port, this object shall have the\n                  value of two octets of zero.')
atportNetEnd = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 5), ATNetworkNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportNetEnd.setDescription('The last AppleTalk network address in the range\n                  configured for this port.  If the network to which\n                  this AppleTalk port is connected is a non-extended\n                  network, or if it is not a native AppleTalk port,\n                  the value for atportNetEnd shall be two octets of\n                  zero.')
atportNetAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 6), DdpNodeAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportNetAddress.setDescription('The AppleTalk network address configured for this\n                  port.  In addition, this value may be used as a hint\n                  for an initial node number used during node-finding.\n                  If this port is not a native AppleTalk port, this\n                  object shall have the value of three octets of zero.')
atportStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7,))).clone(namedValues=NamedValues(("routing", 1), ("unconfigured", 2), ("off", 3), ("invalid", 4), ("endNode", 5), ("offDueToConflict", 6), ("other", 7),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportStatus.setDescription('The configuration status of this port.\n\n                  Setting this object to the value invalid(4) has the\n                  effect of invalidating the corresponding entry in the\n                  atportTable.  That is, it effectively disassociates the\n                  mapping identified with said entry.  It is an\n                  implementation-specific matter as to whether the agent\n                  removes an invalidated entry from the table.\n                  Accordingly, management stations must be prepared to\n                  receive from agents tabular information corresponding\n                  to entries not currently in use.  Proper\n                  interpretation of such entries requires examination\n                  of the relevant atportStatus object.')
atportNetConfig = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6,))).clone(namedValues=NamedValues(("conflictOrientedSeed", 1), ("garnered", 2), ("guessed", 3), ("unconfigured", 4), ("conflictAverseSeed", 5), ("softSeed", 6),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportNetConfig.setDescription('The status of the network information for this port.\n                  If this port is not a native AppleTalk port, this\n                  object shall have the value unconfigured(4).')
atportZoneConfig = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6,))).clone(namedValues=NamedValues(("conflictOrientedSeed", 1), ("garnered", 2), ("guessed", 3), ("unconfigured", 4), ("conflictAverseSeed", 5), ("softSeed", 6),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportZoneConfig.setDescription('The status of the zone information for this port.\n                  If this port is not a native AppleTalk port, this\n                  object shall have the value unconfigured(4).')
atportZoneDefault = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 10), ATName()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportZoneDefault.setDescription('The name of the default zone for this port.  If\n                  this port only has one zone, that zone is\n                  represented here. If this port is not a native\n                  AppleTalk port, this object shall contain an octet\n                  string of zero length.\n\n                  When this value is changed in a router, the router\n                  must send a zipNotify packet on the associated\n                  network.')
atportIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportIfIndex.setDescription('The physical interface associated with this\n                  AppleTalk port.  The interface identified by a\n                  particular value of this index is the same interface\n                  as identified by the same value of ifIndex.')
atportNetFrom = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 12), DdpNodeAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atportNetFrom.setDescription('When atportNetConfig is set to garnered(2), this\n                  variable contains the DDP address of an entity from\n                  which the AppleTalk network number was garnered.\n                  When atportNetConfig is set to\n                  conflictOrientedSeed(1), conflictAverseSeed(5),\n                  or softSeed(6), this variable contains the DDP\n                  address of an entity which confirmed or supplied our\n                  AppleTalk network number, for example by replying to\n                  a ZIP GetNetInfo request.\n\n                  If atportNetConfig is set to guessed(3) or\n                  unconfigured(4), or if the entity has not received\n                  any network number confirmation, this variable\n                  should be set to three octets of zero.')
atportZoneFrom = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 13), DdpNodeAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atportZoneFrom.setDescription('When atportZoneConfig is set to garnered(2), this\n                  variable contains the DDP address of an entity from\n                  which the AppleTalk zone list was garnered.\n\n                  When atportZoneConfig is set to\n                  conflictOrientedSeed(1), conflictAverseSeed(5), or\n                  softSeed(6), this variable contains the DDP address\n                  of an entity which confirmed or supplied our\n                  AppleTalk zone information, for example by replying\n                  to a ZIP GetNetInfo request or a ZIP Query.\n\n                  If atportZoneConfig is set to guessed(3) or\n                  unconfigured(4), or if the entity has not received\n                  any zone confirmation, this variable should be set\n                  to three octets of zero.')
atportInPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atportInPkts.setDescription('The number of packets received by this entity on\n                  this port.')
atportOutPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atportOutPkts.setDescription('The number of packets transmitted by this entity on\n                  this port.')
atportHome = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("home", 1), ("notHome", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atportHome.setDescription('An indication of whether or not the entity is\n                  homed on this port, that is to say, a port on which\n                  the entity could perform NBP registrations for\n                  services that it chooses to advertise.')
atportCurrentZone = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 17), ATName()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportCurrentZone.setDescription('The current zone for the port.  In general, this is\n                  the zone name in which services on this port will\n                  be registered.  If this port is not a native\n                  AppleTalk port, this object shall contain an octet\n                  string of zero length.  Note that modifications to\n                  this object do not affect the nbpTable.')
atportConflictPhysAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 1, 1, 18), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atportConflictPhysAddr.setDescription('The link-layer address of a device which caused\n                  this entity to set atportStatus to\n                  offDueToConflict(6). If this address is not\n                  available, or if the entity has not set atportStatus\n                  to offDueToConflict, this object shall be a zero\n                  length OCTET STRING.')
atportZoneTable = MibTable((1, 3, 6, 1, 2, 1, 13, 3, 2), )
if mibBuilder.loadTexts: atportZoneTable.setDescription('The table of zone information for non-default\n                  zones on ports.')
atportZoneEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 3, 2, 1), ).setIndexNames((0, "APPLETALK-MIB", "atportZonePort"), (0, "APPLETALK-MIB", "atportZoneName"))
if mibBuilder.loadTexts: atportZoneEntry.setDescription('An entry of zone information for a port.\n\n                  As an example, an instance of the atportZoneStatus\n                  object might be named\n                  atportZoneStatus.2.8.84.119.105.108.105.103.104.116')
atportZonePort = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: atportZonePort.setDescription('An integer representing the port to which this zone\n                  belongs. The port identified by a particular value\n                  of this object is the same port as identified by the\n                  same value of atportIndex.')
atportZoneName = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 2, 1, 2), ATName().subtype(subtypeSpec=ValueSizeConstraint(1,32)))
if mibBuilder.loadTexts: atportZoneName.setDescription('A zone name configured for the AppleTalk port\n                  referred to in the corresponding entry of\n                  atportZonePort.\n\n                  When this value is changed in a router, the router\n                  must send a zipNotify packet on the associated\n                  network.')
atportZoneStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportZoneStatus.setDescription('The status of this zone entry.\n\n                  Setting this object to the value invalid(2) has the\n                  effect of invalidating the corresponding entry in\n                  the atportZoneTable.  That is, it effectively\n                  disassociates the mapping identified with said\n                  entry.  It is an implementation-specific matter as\n                  to whether the agent removes an invalidated entry\n                  from the table. Accordingly, management stations\n                  must be prepared to receive from agents tabular\n                  information corresponding to entries not currently\n                  in use.  Proper interpretation of such entries\n                  requires examination of the relevant\n                  atportZoneStatus object.')
ddpOutRequests = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpOutRequests.setDescription('The total number of DDP datagrams which were\n                  supplied to DDP by local DDP clients in requests for\n                  transmission.  Note that this counter does not\n                  include any datagrams counted in ddpForwRequests.')
ddpOutShorts = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpOutShorts.setDescription('The total number of short DDP datagrams which were\n                  transmitted from this entity.')
ddpOutLongs = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpOutLongs.setDescription('The total number of long DDP datagrams which were\n                  transmitted from this entity.')
ddpInReceives = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpInReceives.setDescription('The total number of input datagrams received by\n                  DDP, including those received in error.')
ddpInLocalDatagrams = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpInLocalDatagrams.setDescription('The total number of input DDP datagrams for which\n                  this\n                  entity was their final DDP destination.')
ddpNoProtocolHandlers = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpNoProtocolHandlers.setDescription('The total number of DDP datagrams addressed to this\n                  entity that were addressed to an upper layer protocol\n                  for which no protocol handler existed.')
ddpTooShortErrors = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpTooShortErrors.setDescription('The total number of input DDP datagrams dropped\n                  because the received data length was less than the\n                  data length specified in the DDP header or the\n                  received data length was less than the length of the\n                  expected DDP header.')
ddpTooLongErrors = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpTooLongErrors.setDescription('The total number of input DDP datagrams dropped\n                  because they exceeded the maximum DDP datagram\n                  size.')
ddpShortDDPErrors = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpShortDDPErrors.setDescription('The total number of input DDP datagrams dropped\n                  because this entity was not their final destination\n                  and their type was short DDP.')
ddpChecksumErrors = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpChecksumErrors.setDescription('The total number of input DDP datagrams for which\n                  this DDP entity was their final destination, and\n                  which were dropped because of a checksum error.')
ddpListenerTable = MibTable((1, 3, 6, 1, 2, 1, 13, 4, 15), )
if mibBuilder.loadTexts: ddpListenerTable.setDescription('The ddpListenerTable stores information for each\n                  DDP socket that has a listener.')
ddpListenerEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 4, 15, 1), ).setIndexNames((0, "APPLETALK-MIB", "ddpListenerAddress"))
if mibBuilder.loadTexts: ddpListenerEntry.setDescription('This ddpListenerEntry contains information about a\n                  particular socket that has a socket listener.\n\n                  As an example, an instance of the ddpListenerStatus\n                  object might be named ddpListenerStatus.0.80.220.1')
ddpListenerAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 4, 15, 1, 1), DdpSocketAddress())
if mibBuilder.loadTexts: ddpListenerAddress.setDescription("The DDP address that this socket listener is bound\n                  to.  If this socket listener isn't bound to a\n                  particular address, for instance if it is intended\n                  for all interfaces, this object shall have the value\n                  of three octets of zero followed by one octet of\n                  socket number. The socket number must not equal\n                  zero.")
ddpListenerInPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 4, 15, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpListenerInPkts.setDescription('The number of packets received for this listener.')
ddpListenerStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 4, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ddpListenerStatus.setDescription('The status of this socket listener.\n                  Setting this object to the value invalid(2) has the\n                  effect of invalidating the corresponding entry in the\n                  ddpListenerTable.  That is, it effectively\n                  disassociates the mapping identified with said\n                  entry.  It is an implementation-specific matter as\n                  to whether the agent removes an invalidated entry\n                  from the table. Accordingly, management stations\n                  must be prepared to receive from agents tabular\n                  information corresponding to entries not currently\n                  in use.  Proper interpretation of such entries\n                  requires examination of the relevant\n                  ddpListenerStatus object.')
ddpForwRequests = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpForwRequests.setDescription('The number of input datagrams for which this entity\n                  was not their final DDP destination, as a result of\n                  which an attempt was made to find a route to forward\n                  them to that final destination.')
ddpOutNoRoutes = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpOutNoRoutes.setDescription('The total number of DDP datagrams dropped because a\n                  route could not be found to their final destination.')
ddpBroadcastErrors = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpBroadcastErrors.setDescription('The total number of input DDP datagrams dropped\n                  because this entity was not their final destination\n                  and they were addressed to the link level broadcast.')
ddpHopCountErrors = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpHopCountErrors.setDescription('The total number of input DDP datagrams dropped\n                  because this entity was not their final destination\n                  and their hop count would exceed 15.')
ddpForwardingTable = MibTable((1, 3, 6, 1, 2, 1, 13, 4, 16), )
if mibBuilder.loadTexts: ddpForwardingTable.setDescription('A table of forwarding entries for DDP.  This table\n                  contains a route for each AppleTalk network currently\n                  known to the entity.')
ddpForwardingEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 4, 16, 1), ).setIndexNames((0, "APPLETALK-MIB", "ddpForwardingNetEnd"))
if mibBuilder.loadTexts: ddpForwardingEntry.setDescription('A forwarding entry for a particular AppleTalk\n                  network.\n\n                  As an example, an instance of the ddpForwardingPort\n                  object might be named ddpForwardingPort.0.90')
ddpForwardingNetEnd = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 4, 16, 1, 1), ATNetworkNumber())
if mibBuilder.loadTexts: ddpForwardingNetEnd.setDescription('The last network number in the network range\n                  matched by this forwarding entry.  This will not be\n                  zero even if this corresponds to a non-extended\n                  net.')
ddpForwardingNetStart = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 4, 16, 1, 2), ATNetworkNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpForwardingNetStart.setDescription('The first network number in the network range\n                  matched by this forwarding entry.')
ddpForwardingNextHop = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 4, 16, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpForwardingNextHop.setDescription("The next hop in the route to this entry's\n                  destination network.  The format of this address can\n                  be determined by examinating the atportType\n                  corresponding to this entry.")
ddpForwardingProto = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 4, 16, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpForwardingProto.setDescription('The routing mechanism by which this route was\n                  learned.')
ddpForwardingModifiedTime = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 4, 16, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpForwardingModifiedTime.setDescription('The value of sysUpTime at the time of the last\n                  modification to this entry.  The initial value of\n                  ddpForwardingModified time shall be the value of\n                  sysUpTime at the time the entry is created.')
ddpForwardingUseCounts = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 4, 16, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpForwardingUseCounts.setDescription('The number of times this entry has been used to\n                  route a packet to the destination network.  Note\n                  that this counter is not cleared when the\n                  corresponding ddpForwardingNextHop variable\n                  changes.')
ddpForwardingPort = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 4, 16, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpForwardingPort.setDescription('The AppleTalk port through which\n                  ddpForwardingNextHop is reached.  The interface\n                  identified by a particular value of this variable is\n                  the same interface as identified by the same value\n                  of atportIndex.')
ddpForwProtoOids = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 4, 17))
rtmpRoutingProto = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 4, 17, 1))
kipRoutingProto = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 4, 17, 2))
ddpForwardingTableOverflows = MibScalar((1, 3, 6, 1, 2, 1, 13, 4, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpForwardingTableOverflows.setDescription('The number of times the entity attempted to add an\n                  entry to the forwarding table but failed due to\n                  overflow.')
rtmpTable = MibTable((1, 3, 6, 1, 2, 1, 13, 5, 1), )
if mibBuilder.loadTexts: rtmpTable.setDescription('A list of Routing Table Maintenance Protocol\n                  entries for this entity.')
rtmpEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 5, 1, 1), ).setIndexNames((0, "APPLETALK-MIB", "rtmpRangeStart"))
if mibBuilder.loadTexts: rtmpEntry.setDescription('The route entry to a particular network range.\n\n                  As an example, an instance of the rtmpPort object\n                  might be named rtmpPort.0.80')
rtmpRangeStart = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 5, 1, 1, 1), ATNetworkNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmpRangeStart.setDescription('The first DDP network address in the network range\n                  to which this routing entry pertains.  This is a two\n                  octet DDP network address in network byte order.')
rtmpRangeEnd = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 5, 1, 1, 2), ATNetworkNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmpRangeEnd.setDescription('The last DDP network address in the network range\n                  to which this routing entry pertains.  This is a two\n                  octet DDP network address in network byte order.  If\n                  the network to which this routing entry pertains is\n                  a non-extended network, the value for rtmpRangeEnd\n                  shall be two octets of zero.')
rtmpNextHop = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 5, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmpNextHop.setDescription("The next internet router in the route to this\n                  entry's destination network.  The format of this\n                  address can be determined by examinating the\n                  atportType corresponding to this entry.")
rtmpType = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4,))).clone(namedValues=NamedValues(("other", 1), ("appletalk", 2), ("serialPPP", 3), ("serialNonstandard", 4),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmpType.setDescription('The type of network over which this route points.')
rtmpPort = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 5, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmpPort.setDescription('The AppleTalk port over which this route points.\n                  The interface identified by a particular value of\n                  this variable is the same interface as identified by\n                  the same value of atportIndex.')
rtmpHops = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 5, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmpHops.setDescription('The number of hops required to reach the\n                  destination network to which this routing entry\n                  pertains.')
rtmpState = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("good", 1), ("suspect", 2), ("badZero", 3), ("badOne", 4), ("invalid", 5),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtmpState.setDescription('The status of the information contained in this\n                  route entry.\n\n                  Setting this object to the value invalid(5) has the\n                  effect of invalidating the corresponding entry in\n                  the rtmpTable.  That is, it  effectively\n                  disassociates the mapping identified with said\n                  entry.  It is an implementation-specific matter as\n                  to whether the agent removes an invalidated entry\n                  from the table. Accordingly, management stations\n                  must be prepared to receive from agents tabular\n                  information corresponding to entries not currently\n                  in use.  Proper interpretation of such entries\n                  requires examination of the relevant rtmpState\n                  object.')
rtmpInDataPkts = MibScalar((1, 3, 6, 1, 2, 1, 13, 5, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmpInDataPkts.setDescription('A count of the number of good RTMP data packets\n                  received by this entity.')
rtmpOutDataPkts = MibScalar((1, 3, 6, 1, 2, 1, 13, 5, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmpOutDataPkts.setDescription('A count of the number of RTMP packets sent by this\n                  entity.')
rtmpInRequestPkts = MibScalar((1, 3, 6, 1, 2, 1, 13, 5, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmpInRequestPkts.setDescription('A count of the number of good RTMP Request packets\n                  received by this entity.')
rtmpNextIREqualChanges = MibScalar((1, 3, 6, 1, 2, 1, 13, 5, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmpNextIREqualChanges.setDescription('A count of the number of times RTMP changes the\n                  Next Internet Router in a routing entry because the\n                  hop count advertised in a routing tuple was equal to\n                  the current hop count for a particular network.')
rtmpNextIRLessChanges = MibScalar((1, 3, 6, 1, 2, 1, 13, 5, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmpNextIRLessChanges.setDescription('A count of the number of times RTMP changes the\n                  Next Internet Router in a routing entry because the\n                  hop count advertised in a routing tuple was less\n                  than the current hop count for a particular network.')
rtmpRouteDeletes = MibScalar((1, 3, 6, 1, 2, 1, 13, 5, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmpRouteDeletes.setDescription('A count of the number of times RTMP deletes a route\n                  because it was aged out of the table.  This can help\n                  to detect routing problems.')
rtmpRoutingTableOverflows = MibScalar((1, 3, 6, 1, 2, 1, 13, 5, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmpRoutingTableOverflows.setDescription('The number of times RTMP attempted to add a route\n                  to the RTMP table but failed due to lack of space.')
rtmpOutRequestPkts = MibScalar((1, 3, 6, 1, 2, 1, 13, 16, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmpOutRequestPkts.setDescription('A count of the number of RTMP Request packets sent\n                  by this entity.')
rtmpInVersionMismatches = MibScalar((1, 3, 6, 1, 2, 1, 13, 16, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmpInVersionMismatches.setDescription('A count of the number of RTMP packets received by\n                  this entity that were rejected due to a version\n                  mismatch.')
rtmpInErrors = MibScalar((1, 3, 6, 1, 2, 1, 13, 16, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtmpInErrors.setDescription('A count of the number of RTMP packets received by\n                  this entity that were rejected for an error other\n                  than version mismatch.')
kipTable = MibTable((1, 3, 6, 1, 2, 1, 13, 6, 1), )
if mibBuilder.loadTexts: kipTable.setDescription('The table of routing information for KIP networks.')
kipEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 6, 1, 1), ).setIndexNames((0, "APPLETALK-MIB", "kipNetStart"))
if mibBuilder.loadTexts: kipEntry.setDescription('An entry in the routing table for KIP networks.\n\n                  As an example, an instance of the kipCore object\n                  might be named kipCore.0.80')
kipNetStart = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 6, 1, 1, 1), ATNetworkNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kipNetStart.setDescription('The first AppleTalk network address in the range\n                  for this routing entry.  This address is a two octet\n                  DDP network address in network byte order.')
kipNetEnd = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 6, 1, 1, 2), ATNetworkNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kipNetEnd.setDescription('The last AppleTalk network address in the range for\n                  this routing entry.  This address is a two octet DDP\n                  network address in network byte order.  If the\n                  network to which this AppleTalk port is connected is\n                  a non-extended network, the value for kipNetEnd\n                  shall be two octets of zero.')
kipNextHop = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 6, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kipNextHop.setDescription("The IP address of the next hop in the route to this\n                  entry's destination network.")
kipHopCount = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 6, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kipHopCount.setDescription('The number of hops required to reach the destination\n                  network to which this entry pertains.')
kipBCastAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 6, 1, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kipBCastAddr.setDescription('The form of the IP address used to broadcast on this\n                  network.')
kipCore = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("core", 1), ("notcore", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kipCore.setDescription('The status of kipNextHop as a core gateway.')
kipType = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("kipRouter", 1), ("net", 2), ("host", 3), ("other", 4), ("async", 5),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kipType.setDescription('The type of the entity that this route points to.')
kipState = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("configured", 1), ("learned", 2), ("invalid", 3),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kipState.setDescription('The state of this network entry.\n\n                  Setting this object to the value invalid(3) has the\n                  effect of invalidating the corresponding entry in the\n                  kipTable.  That is, it  effectively disassociates the\n                  mapping identified with said entry.  It is an\n                  implementation-specific matter as to whether the agent\n                  removes an invalidated entry from the table.\n                  Accordingly, management stations must be prepared to\n                  receive from agents tabular information corresponding\n                  to entries not currently in use.  Proper\n                  interpretation of such entries requires examination\n                  of the relevant kipState object.')
kipShare = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 6, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("shared", 1), ("private", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: kipShare.setDescription('If the information in this entry is propagated to\n                  other routers as part of the AA routing protocol,\n                  the value of this variable is equal to shared(1).\n                  Otherwise its value is private(2).')
kipFrom = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 6, 1, 1, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: kipFrom.setDescription('The IP address from which the routing entry was\n                  learned via the AA protocol.  If this entry was not\n                  created via the AA protocol, it should contain IP\n                  address 0.0.0.0.')
zipTable = MibTable((1, 3, 6, 1, 2, 1, 13, 7, 1), )
if mibBuilder.loadTexts: zipTable.setDescription('The table of zone information for reachable\n                  AppleTalk networks.')
zipEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 7, 1, 1), ).setIndexNames((0, "APPLETALK-MIB", "zipZoneNetStart"), (0, "APPLETALK-MIB", "zipZoneIndex"))
if mibBuilder.loadTexts: zipEntry.setDescription('An entry of zone information for a particular zone\n                  and network combination.\n\n                  As an example, an instance of the zipZoneState object\n                  might be named zipZoneState.0.80.4')
zipZoneName = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 7, 1, 1, 1), ATName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zipZoneName.setDescription('The zone name of this entry.  This is stored in\n                  Mac ASCII format.  If the full zone list for the\n                  entry is not known, the value for zipZoneName shall\n                  be a zero length octet string.')
zipZoneIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 7, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zipZoneIndex.setDescription('An integer that is unique to the zipZoneName that\n                  is present in this entry.  For any given zone name,\n                  every zipEntry that has an equal zone name will have\n                  the same zipZoneIndex.  When a zone name is\n                  discovered which is not currently in the table, it\n                  will be assigned an index greater than any\n                  previously assigned index.')
zipZoneNetStart = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 7, 1, 1, 3), ATNetworkNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zipZoneNetStart.setDescription('The network that starts the range for this entry.\n                  This address is a two octet DDP network address in\n                  network byte order.')
zipZoneNetEnd = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 7, 1, 1, 4), ATNetworkNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zipZoneNetEnd.setDescription('The network that ends the range for this entry.\n                  This address is a two octet DDP network address in\n                  network byte order.  If the network to which this\n                  zip entry pertains is a non-extended network, the\n                  value for zipZoneNetEnd shall be two octets of\n                  zero.')
zipZoneState = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: zipZoneState.setDescription('The state of this zip entry.\n\n                  Setting this object to the value invalid(2) has the\n                  effect of invalidating the corresponding entry in\n                  the zipTable.  That is, it  effectively\n                  disassociates the mapping identified with said\n                  entry.  It is an implementation-specific matter as\n                  to whether the agent removes an invalidated entry\n                  from the table. Accordingly, management stations\n                  must be prepared to receive from agents tabular\n                  information corresponding to entries not currently\n                  in use.  Proper interpretation of such entries\n                  requires examination of the relevant zipZoneState\n                  object.')
zipZoneFrom = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 7, 1, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zipZoneFrom.setDescription('The address from which this zone name to network\n                  number mapping was learned.  The format of this\n                  address can be determined by examining the\n                  atportType corresponding to this entry.  When this\n                  mapping is learned from the entity itself, this\n                  object shall have the value of three\n                  octets of zero.')
zipZonePort = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 7, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zipZonePort.setDescription('The AppleTalk port through which this zone name to\n                  network number mapping was learned.  The interface\n                  identified by a particular value of this variable is\n                  the same interface as identified by the same value\n                  of atportIndex.')
zipInZipQueries = MibScalar((1, 3, 6, 1, 2, 1, 13, 7, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zipInZipQueries.setDescription('The number of ZIP Queries received by this entity.')
zipInZipReplies = MibScalar((1, 3, 6, 1, 2, 1, 13, 7, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zipInZipReplies.setDescription('The number of ZIP Replies received by this entity.')
zipInZipExtendedReplies = MibScalar((1, 3, 6, 1, 2, 1, 13, 7, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zipInZipExtendedReplies.setDescription('The number of ZIP Extended Replies received by this\n                  entity.')
zipZoneConflictErrors = MibScalar((1, 3, 6, 1, 2, 1, 13, 7, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zipZoneConflictErrors.setDescription("The number of times a conflict has been detected\n                  between this entity's zone information and another\n                  entity's zone information.")
zipInObsoletes = MibScalar((1, 3, 6, 1, 2, 1, 13, 7, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zipInObsoletes.setDescription('The number of ZIP Takedown or ZIP Bringup packets\n                  received by this entity.  Note that as the ZIP\n                  Takedown and ZIP Bringup packets have been\n                  obsoleted, the receipt of one of these packets\n                  indicates that a node sent it in error.')
zipRouterNetInfoTable = MibTable((1, 3, 6, 1, 2, 1, 13, 7, 7), )
if mibBuilder.loadTexts: zipRouterNetInfoTable.setDescription('The table of Net Info packets received by each port\n                  on this entity.')
zipRouterNetInfoEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 7, 7, 1), ).setIndexNames((0, "APPLETALK-MIB", "atportIndex"))
if mibBuilder.loadTexts: zipRouterNetInfoEntry.setDescription('The description of the Net Info packets received on\n                  a particular port on this entity.  One such entry\n                  shall exist for each atport on this router entity.\n\n                  As an example, an instance of the zipInGetNetInfos\n                  object might be named zipInGetNetInfos.2')
zipInGetNetInfos = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 7, 7, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zipInGetNetInfos.setDescription('The number of ZIP GetNetInfo packets received on\n                  this port by this entity.')
zipOutGetNetInfoReplies = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 7, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zipOutGetNetInfoReplies.setDescription('The number of ZIP GetNetInfo Reply packets sent out\n                  this port by this entity.')
zipZoneOutInvalids = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 7, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zipZoneOutInvalids.setDescription('The number of times this entity has sent a ZIP\n                  GetNetInfo Reply with the zone invalid bit set in\n                  response to a GetNetInfo Request with an invalid\n                  zone name.')
zipAddressInvalids = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 7, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zipAddressInvalids.setDescription('The number of times this entity had to broadcast a\n                  ZIP GetNetInfo Reply because the GetNetInfo Request\n                  had an invalid address.')
zipNetInfoTable = MibTable((1, 3, 6, 1, 2, 1, 13, 17, 1), )
if mibBuilder.loadTexts: zipNetInfoTable.setDescription('The table of Net Info packets received by each port\n                  on this entity.')
zipNetInfoEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 17, 1, 1), ).setIndexNames((0, "APPLETALK-MIB", "atportIndex"))
if mibBuilder.loadTexts: zipNetInfoEntry.setDescription('The description of the Net Info packets received on\n                  a particular port on this entity.  One such entry\n                  shall exist for each atport on this entity.\n\n                  As an example, an instance of the zipOutGetNetInfos\n                  object might be named zipOutGetNetInfos.2')
zipOutGetNetInfos = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 17, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zipOutGetNetInfos.setDescription('The number of ZIP GetNetInfo packets sent out this\n                  port by this entity.')
zipInGetNetInfoReplies = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 17, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zipInGetNetInfoReplies.setDescription('The number of ZIP GetNetInfo Reply packets received\n              on this port by this entity.')
zipZoneInInvalids = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 17, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zipZoneInInvalids.setDescription('The number of times this entity has received a ZIP\n                  GetNetInfo Reply with the zone invalid bit set\n                  because the corresponding GetNetInfo Request had an\n                  invalid zone name.')
zipInErrors = MibScalar((1, 3, 6, 1, 2, 1, 13, 17, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zipInErrors.setDescription('The number of ZIP packets received by this entity\n                  that were rejected for any error.')
nbpTable = MibTable((1, 3, 6, 1, 2, 1, 13, 8, 1), )
if mibBuilder.loadTexts: nbpTable.setDescription('The table of NBP services registered on this entity.')
nbpEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 8, 1, 1), ).setIndexNames((0, "APPLETALK-MIB", "nbpIndex"))
if mibBuilder.loadTexts: nbpEntry.setDescription('The description of an NBP service registered on this\n                  entity.\n\n                  As an example, an instance of the nbpZone object\n                  might be named nbpZone.2')
nbpIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 8, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbpIndex.setDescription('The index of this NBP entry.  This index is unique\n                  with respect to the indexes of all other NBP entries,\n                  and shall remain constant throughout the lifetime\n                  of this object.')
nbpObject = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 8, 1, 1, 2), ATName().subtype(subtypeSpec=ValueSizeConstraint(1,32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbpObject.setDescription('The name of the service described by this entity.\n                  When this variable is changed, the entity should\n                  perform an NBP registration using the new nbpObject.')
nbpType = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 8, 1, 1, 3), ATName().subtype(subtypeSpec=ValueSizeConstraint(1,32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbpType.setDescription('The type of the service described by this entity.\n                  When this variable is changed, the entity should\n                  perform an NBP registration using the new nbpType.')
nbpZone = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 8, 1, 1, 4), ATName()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbpZone.setDescription('The zone the service described by this entity is\n                  registered in.  This must be the actual zone name,\n                  without any wildcard characters.  When this variable\n                  is changed, the entity should perform an NBP\n                  registration using the new nbpZone.')
nbpState = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4,))).clone(namedValues=NamedValues(("valid", 1), ("registering", 2), ("registrationFailed", 3), ("invalid", 4),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbpState.setDescription('The state of this NBP entry.\n                  When the registration for an entry in the nbpTable\n                  fails, it is an implementation-specific matter as to\n                  how long the entry will remain in the\n                  registrationFailed(3) state before moving to the\n                  invalid(4) state.  Note that the entry may pass\n                  immediately from the registrationFailed state to\n                  the invalid state.\n\n                  Setting this object to the value invalid(4) has the\n                  effect of invalidating the corresponding entry in the\n                  nbpTable.  That is, it  effectively disassociates the\n                  mapping identified with said entry.  It is an\n                  implementation-specific matter as to whether the agent\n                  removes an invalidated entry from the table.\n                  Accordingly, management stations must be prepared to\n                  receive from agents tabular information corresponding\n                  to entries not currently in use.  Proper\n                  interpretation of such entries requires examination\n                  of the relevant nbpState object.')
nbpAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 8, 1, 1, 6), DdpSocketAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbpAddress.setDescription('The DDP network, node, and socket number of this\n                  entity. If this is unspecified, for instance if the\n                  registration is on all ports of a multiport device,\n                  this object shall have the value of three octets of\n                  zero, followed by one octet of socket number.')
nbpEnumerator = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 8, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbpEnumerator.setDescription('The enumerator assigned to this entity.')
nbpInLookUpRequests = MibScalar((1, 3, 6, 1, 2, 1, 13, 8, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbpInLookUpRequests.setDescription('The number of NBP LookUp Requests received.')
nbpInLookUpReplies = MibScalar((1, 3, 6, 1, 2, 1, 13, 8, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbpInLookUpReplies.setDescription('The number of NBP LookUp Replies received.')
nbpInBroadcastRequests = MibScalar((1, 3, 6, 1, 2, 1, 13, 8, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbpInBroadcastRequests.setDescription('The number of NBP Broadcast Requests received.')
nbpInForwardRequests = MibScalar((1, 3, 6, 1, 2, 1, 13, 8, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbpInForwardRequests.setDescription('The number of NBP Forward Requests received.')
nbpOutLookUpReplies = MibScalar((1, 3, 6, 1, 2, 1, 13, 8, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbpOutLookUpReplies.setDescription('The number of NBP LookUp Replies sent.')
nbpRegistrationFailures = MibScalar((1, 3, 6, 1, 2, 1, 13, 8, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbpRegistrationFailures.setDescription('The number of times this node experienced a failure\n                  in attempting to register an NBP entity.')
nbpInErrors = MibScalar((1, 3, 6, 1, 2, 1, 13, 8, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbpInErrors.setDescription('The number of NBP packets received by this entity\n                  that were rejected for any error.')
atechoRequests = MibScalar((1, 3, 6, 1, 2, 1, 13, 9, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atechoRequests.setDescription('The number of AppleTalk Echo requests received.')
atechoReplies = MibScalar((1, 3, 6, 1, 2, 1, 13, 9, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atechoReplies.setDescription('The number of AppleTalk Echo replies sent.')
atechoOutRequests = MibScalar((1, 3, 6, 1, 2, 1, 13, 9, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atechoOutRequests.setDescription('The count of AppleTalk Echo requests sent.')
atechoInReplies = MibScalar((1, 3, 6, 1, 2, 1, 13, 9, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atechoInReplies.setDescription('The count of AppleTalk Echo replies received.')
atpInPkts = MibScalar((1, 3, 6, 1, 2, 1, 13, 10, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atpInPkts.setDescription('The number of ATP packets received by this entity.')
atpOutPkts = MibScalar((1, 3, 6, 1, 2, 1, 13, 10, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atpOutPkts.setDescription('The number of ATP packets sent by this entity.')
atpTRequestRetransmissions = MibScalar((1, 3, 6, 1, 2, 1, 13, 10, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atpTRequestRetransmissions.setDescription('The number of times that a timeout occurred and a\n                  Transaction Request packet needed to be\n                  retransmitted by this host.')
atpTResponseRetransmissions = MibScalar((1, 3, 6, 1, 2, 1, 13, 10, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atpTResponseRetransmissions.setDescription('The number of times a timeout was detected and a\n                  Transaction Response packet needed to be\n                  retransmitted by this host.')
atpReleaseTimerExpiredCounts = MibScalar((1, 3, 6, 1, 2, 1, 13, 10, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atpReleaseTimerExpiredCounts.setDescription('The number of times the release timer expired, as a\n                  result of which a Request Control Block had to be\n                  deleted.')
atpRetryCountExceededs = MibScalar((1, 3, 6, 1, 2, 1, 13, 10, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atpRetryCountExceededs.setDescription('The number of times the retry count was exceeded,\n                  and an error was returned to the client of ATP.')
atpListenerTable = MibTable((1, 3, 6, 1, 2, 1, 13, 10, 7), )
if mibBuilder.loadTexts: atpListenerTable.setDescription('The atpListenerTable stores information for each ATP\n                  socket that has a listener.')
atpListenerEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 10, 7, 1), ).setIndexNames((0, "APPLETALK-MIB", "atpListenerAddress"))
if mibBuilder.loadTexts: atpListenerEntry.setDescription('This atpListenerEntry contains information about a\n                  particular socket that has a socket listener.\n\n                  As an example, an instance of the atpListenerStatus\n                  object might be named atpListenerStatus.0.80.220.3')
atpListenerAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 10, 7, 1, 1), DdpSocketAddress())
if mibBuilder.loadTexts: atpListenerAddress.setDescription("The DDP address that this socket listener is bound\n                  to. If this socket listener isn't bound to a\n                  particular address, for instance if it is intended\n                  for all interfaces, this object shall have the value\n                  of three octets of zero followed by one octet of\n                  socket number.")
atpListenerStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 10, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atpListenerStatus.setDescription('The status of this socket.\n\n                  Setting this object to the value invalid(2) has the\n                  effect of invalidating the corresponding entry in\n                  the atpListenerTable.  That is, it effectively\n                  disassociates the mapping identified with said\n                  entry.  It is an implementation-specific matter as\n                  to whether the agent removes an invalidated entry\n                  from the table. Accordingly, management stations\n                  must be prepared to receive from agents tabular\n                  information corresponding to entries not currently\n                  in use.  Proper interpretation of such entries\n                  requires examination of the relevant\n                  atpListenerStatus object.')
papInOpenConns = MibScalar((1, 3, 6, 1, 2, 1, 13, 11, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: papInOpenConns.setDescription('The number of PAP Open Connection requests received\n                  by this entity.')
papOutOpenConns = MibScalar((1, 3, 6, 1, 2, 1, 13, 11, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: papOutOpenConns.setDescription('The number of PAP Open Connection requests sent by\n                  this entity.')
papInDatas = MibScalar((1, 3, 6, 1, 2, 1, 13, 11, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: papInDatas.setDescription('The number of PAP Data messages received by\n                  this entity.')
papOutDatas = MibScalar((1, 3, 6, 1, 2, 1, 13, 11, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: papOutDatas.setDescription('The number of PAP Data messages sent by\n                  this entity.')
papInCloseConns = MibScalar((1, 3, 6, 1, 2, 1, 13, 11, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: papInCloseConns.setDescription('The number of PAP Close Connection requests\n                  received by this entity.')
papOutCloseConns = MibScalar((1, 3, 6, 1, 2, 1, 13, 11, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: papOutCloseConns.setDescription('The number of PAP Close Connection requests sent by\n                  this entity.')
papTickleTimeoutCloses = MibScalar((1, 3, 6, 1, 2, 1, 13, 11, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: papTickleTimeoutCloses.setDescription("The number of times the PAP entity on this node\n                  closed a connection because it didn't receive a\n                  Tickle message before its timer expired.")
papServerTable = MibTable((1, 3, 6, 1, 2, 1, 13, 11, 8), )
if mibBuilder.loadTexts: papServerTable.setDescription('A list of servers on this entity that are\n                  accessible through the Printer Access Protocol.')
papServerEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 11, 8, 1), ).setIndexNames((0, "APPLETALK-MIB", "papServerIndex"))
if mibBuilder.loadTexts: papServerEntry.setDescription("A set of information about a particular PAP server's\n                  configuration and performance.\n\n                  As an example, an instance of the papServerStatus\n                  object might be named papServerStatus.1")
papServerIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 11, 8, 1, 1), Integer32())
if mibBuilder.loadTexts: papServerIndex.setDescription('An unique value for each Printer Access Protocol\n                  Server.')
papServerListeningSocket = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 11, 8, 1, 2), DdpSocketAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: papServerListeningSocket.setDescription('The Server Listening Socket that this PAP server is\n                  listening on.')
papServerStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 11, 8, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: papServerStatus.setDescription('The status string of this server.  This is the\n                  message as it would appear in a PAP Status Reply\n                  from this server.')
papServerCompletedJobs = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 11, 8, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: papServerCompletedJobs.setDescription('The number of jobs that have been accepted and\n                  successfully executed by this server.')
papServerBusyJobs = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 11, 8, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: papServerBusyJobs.setDescription('The number of GetNextJob calls that have accepted\n                  and are currently executing a job.')
papServerFreeJobs = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 11, 8, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: papServerFreeJobs.setDescription('The minimum number of GetNextJob calls that are\n                  currently waiting for a job.')
papServerAuthenticationFailures = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 11, 8, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: papServerAuthenticationFailures.setDescription('The number of times this PAP server rejected a job\n                  because the job was not correctly authenticated.')
papServerAccountingFailures = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 11, 8, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: papServerAccountingFailures.setDescription('The number of times this PAP server rejected a job\n                  because the job did not fit some accounting rule,\n                  such as exceeding a quota.')
papServerGeneralFailures = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 11, 8, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: papServerGeneralFailures.setDescription('The number of times this PAP server rejected a job\n                  for some reason other than authentication or\n                  accounting failures.')
papServerState = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 11, 8, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: papServerState.setDescription('The state of this PAP Server entry.\n\n                  Setting this object to the value invalid(2) has the\n                  effect of invalidating the corresponding entry in\n                  the papServerTable.  That is, it  effectively\n                  disassociates the mapping identified with said\n                  entry.  It is an implementation-specific matter as\n                  to whether the agent removes an invalidated entry\n                  from the table. Accordingly, management stations\n                  must be prepared to receive from agents tabular\n                  information corresponding to entries not currently\n                  in use.  Proper interpretation of such entries\n                  requires examination of the relevant papServerState\n                  object.')
papServerLastStatusMsg = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 11, 8, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: papServerLastStatusMsg.setDescription('The last status message that was transmitted by\n                  this server.')
aspInputTransactions = MibScalar((1, 3, 6, 1, 2, 1, 13, 12, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aspInputTransactions.setDescription('The number of ASP requests and replies received by\n                  this entity.  Note that this is not necessarily the\n                  number of packets containing ASP transactions.')
aspOutputTransactions = MibScalar((1, 3, 6, 1, 2, 1, 13, 12, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aspOutputTransactions.setDescription('The number of ASP requests and replies sent by this\n                  entity.  Note that this is not necessarily the number\n                  of packets containing ASP transactions.')
aspInOpenSessions = MibScalar((1, 3, 6, 1, 2, 1, 13, 12, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aspInOpenSessions.setDescription('The number of ASP Open Session requests and replies\n                  received by this entity.')
aspOutOpenSessions = MibScalar((1, 3, 6, 1, 2, 1, 13, 12, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aspOutOpenSessions.setDescription('The number of ASP Open Session requests and replies\n                  sent by this entity.')
aspInCloseSessions = MibScalar((1, 3, 6, 1, 2, 1, 13, 12, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aspInCloseSessions.setDescription('The number of ASP Close Session requests and replies\n                  received by this entity.')
aspOutCloseSessions = MibScalar((1, 3, 6, 1, 2, 1, 13, 12, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aspOutCloseSessions.setDescription('The number of ASP Close Session requests and replies\n                  sent by this entity.')
aspNoMoreSessionsErrors = MibScalar((1, 3, 6, 1, 2, 1, 13, 12, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aspNoMoreSessionsErrors.setDescription('The number of times an error condition was returned\n                  because this server implementation could not support\n                  another session.')
aspTickleTimeOutCloses = MibScalar((1, 3, 6, 1, 2, 1, 13, 12, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aspTickleTimeOutCloses.setDescription("The number of times the ASP entity on this node\n                  closed a connection because it didn't receive any\n                  messages from the remote end before its timer\n                  expired.")
aspConnTable = MibTable((1, 3, 6, 1, 2, 1, 13, 12, 9), )
if mibBuilder.loadTexts: aspConnTable.setDescription('A list of ASP connections on this entity.')
aspConnEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 12, 9, 1), ).setIndexNames((0, "APPLETALK-MIB", "aspConnLocalAddress"), (0, "APPLETALK-MIB", "aspConnRemoteAddress"), (0, "APPLETALK-MIB", "aspConnID"))
if mibBuilder.loadTexts: aspConnEntry.setDescription('A set of information describing an ASP connection.\n\n                  As an example, an instance of the aspConnState object\n                  might be named\n                  aspConnState.0.80.220.135.0.80.239.119.12')
aspConnLocalAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 12, 9, 1, 1), DdpSocketAddress())
if mibBuilder.loadTexts: aspConnLocalAddress.setDescription('The local address of this ASP connection.')
aspConnRemoteAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 12, 9, 1, 2), DdpSocketAddress())
if mibBuilder.loadTexts: aspConnRemoteAddress.setDescription('The remote address of this ASP connection.  If\n                  this entry is in the listening mode, this object\n                  shall have a value of four octets of zero.')
aspConnID = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 12, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,255)))
if mibBuilder.loadTexts: aspConnID.setDescription('The remote Connection ID of this ASP connection.  If\n                  this entry is in the listening mode, this object\n                  shall have a value of zero.')
aspConnLastReqNum = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 12, 9, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aspConnLastReqNum.setDescription('The last request number on this ASP connection.  If\n                  this entry is in the listening mode, this object\n                  shall have a value of zero.')
aspConnServerEnd = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 12, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("sss", 1), ("wss", 2), ("sls", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aspConnServerEnd.setDescription('Specifies what mode the local session end is in.')
aspConnState = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 12, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("invalid", 3),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aspConnState.setDescription('The state of this ASP connection.\n                  Setting this object to the value invalid(3) has the\n                  effect of invalidating the corresponding entry in the\n                  aspConnTable.  That is, it  effectively disassociates\n                  the mapping identified with said entry.  It is an\n                  implementation-specific matter as to whether the agent\n                  removes an invalidated entry from the table.\n                  Accordingly, management stations must be prepared to\n                  receive from agents tabular information corresponding\n                  to entries not currently in use.  Proper\n                  interpretation of such entries requires examination\n                  of the relevant aspConnState object.')
adspInPkts = MibScalar((1, 3, 6, 1, 2, 1, 13, 13, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adspInPkts.setDescription('The number of ADSP packets received by this entity.')
adspOutPkts = MibScalar((1, 3, 6, 1, 2, 1, 13, 13, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adspOutPkts.setDescription('The number of ADSP packets sent by this entity.')
adspInOctets = MibScalar((1, 3, 6, 1, 2, 1, 13, 13, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adspInOctets.setDescription('The number of data octets contained in ADSP packets\n                  received by this entity.  Note that this does not\n                  include EOM bits.')
adspOutOctets = MibScalar((1, 3, 6, 1, 2, 1, 13, 13, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adspOutOctets.setDescription('The number of data octets contained in ADSP packets\n                  sent by this entity.  Note that this does not include\n                  EOM bits.')
adspInDataPkts = MibScalar((1, 3, 6, 1, 2, 1, 13, 13, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adspInDataPkts.setDescription('The number of ADSP data packets this entity has\n                  received.')
adspOutDataPkts = MibScalar((1, 3, 6, 1, 2, 1, 13, 13, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adspOutDataPkts.setDescription('The number of ADSP data packets this entity has\n                  sent.')
adspTimeoutErrors = MibScalar((1, 3, 6, 1, 2, 1, 13, 13, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adspTimeoutErrors.setDescription('The number of times the ADSP on this entity detected\n                  an expired connection timer.')
adspTimeoutCloseErrors = MibScalar((1, 3, 6, 1, 2, 1, 13, 13, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adspTimeoutCloseErrors.setDescription('The number of times the ADSP on this entity closed a\n                  connection because of too many timeouts.')
adspConnTable = MibTable((1, 3, 6, 1, 2, 1, 13, 13, 9), )
if mibBuilder.loadTexts: adspConnTable.setDescription('A list of ADSP connections on this entity.')
adspConnEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 13, 9, 1), ).setIndexNames((0, "APPLETALK-MIB", "adspConnLocalAddress"), (0, "APPLETALK-MIB", "adspConnRemoteAddress"), (0, "APPLETALK-MIB", "adspConnLocalConnID"))
if mibBuilder.loadTexts: adspConnEntry.setDescription('A set of information describing an ADSP connection.\n                  As an example, an instance of the adspConnState object\n                  might be named\n                  adspConnState.0.80.220.7.0.80.239.142.31231')
adspConnLocalAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 13, 9, 1, 1), DdpSocketAddress())
if mibBuilder.loadTexts: adspConnLocalAddress.setDescription('The local DDP address of this ADSP connection.')
adspConnLocalConnID = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 13, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,65535)))
if mibBuilder.loadTexts: adspConnLocalConnID.setDescription('The local Connection ID of this ADSP connection.  If\n                  this entry specifies an ADSP listener, this value\n                  shall be zero.')
adspConnRemoteAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 13, 9, 1, 3), DdpSocketAddress())
if mibBuilder.loadTexts: adspConnRemoteAddress.setDescription('The remote DDP address of this ADSP connection.  If\n                  this entry specifies an ADSP listener, this value\n                  shall be zero.')
adspConnRemoteConnID = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 13, 9, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: adspConnRemoteConnID.setDescription('The remote Connection ID of this ADSP connection.\n                  If this entry specifies an ADSP listener, this value\n                  shall be zero.')
adspConnState = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 13, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6,))).clone(namedValues=NamedValues(("open", 1), ("localHalfOpen", 2), ("remoteHalfOpen", 3), ("listening", 4), ("closed", 5), ("invalid", 6),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adspConnState.setDescription('The state of this ADSP connection.  The state is\n                  open if both ends are established.  If only one end\n                  is established, then the state is half-open.  If\n                  neither end is established, then the state is\n                  closed.  If an ADSP server is listening on a socket\n                  and is not yet connected, its state is set to\n                  listening, and the adspConnRemoteAddress,\n                  adspConnRemoteSocket, adspConnRemoteConnID, and\n                  adspConnRemoteWindowSize are all set to zero.\n\n                  Setting this object to the value invalid(6) has the\n                  effect of invalidating the corresponding entry in\n                  the adspConnTable.  That is, it  effectively\n                  disassociates the mapping identified with said\n                  entry.  It is an implementation-specific matter as\n                  to whether the agent removes an invalidated entry\n                  from the table. Accordingly, management stations\n                  must be prepared to receive from agents tabular\n                  information corresponding to entries not currently\n                  in use.  Proper interpretation of such entries\n                  requires examination of the relevant adspConnState\n                  object.')
atportPtoPTable = MibTable((1, 3, 6, 1, 2, 1, 13, 14, 1), )
if mibBuilder.loadTexts: atportPtoPTable.setDescription('A list of AppleTalk point-to-point connections for\n                  this entity.')
atportPtoPEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 14, 1, 1), ).setIndexNames((0, "APPLETALK-MIB", "atportPtoPIndex"))
if mibBuilder.loadTexts: atportPtoPEntry.setDescription('The description of one of the AppleTalk\n                  point-to-point connections on this entity.\n\n                  As an example, an instance of the\n                  atportPtoPRemoteAddress object might be named\n                  atportPtoPRemoteAddress.2')
atportPtoPIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 14, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: atportPtoPIndex.setDescription("A unique value for each AppleTalk point-to-point\n                  connection.  Its value is between 1 and the total\n                  number of AppleTalk point-to-point connections.  The\n                  value for each connection must remain constant at\n                  least from the re-initialization of the entity's\n                  network management system to the next\n                  re-initialization.")
atportPtoPProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 14, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportPtoPProtocol.setDescription('The protocol type used over the point-to-point\n                  connection.')
atportPtoPRemoteName = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 14, 1, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportPtoPRemoteName.setDescription('A text string containing the network node name of the\n                  entity at the other end of the point-to-point link.\n                  If the name is unknown or undefined, then this\n                  string is zero length.')
atportPtoPRemoteAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 14, 1, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportPtoPRemoteAddress.setDescription('The network address of the entity at the other end\n                  of the point-to-point link in network byte order.\n                  The format of this address can be determined\n                  by examinating the atportType corresponding to this\n                  entry.  If the address is unknown or undefined, then\n                  this string is zero length.')
atportPtoPPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 14, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportPtoPPortIndex.setDescription('The AppleTalk port associated with this\n                  point-to-point connection.  The interface identified\n                  by a particular value of this index is the same\n                  interface as identified by the same value of\n                  atportIndex.')
atportPtoPStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 14, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atportPtoPStatus.setDescription('The status of this entry in the atportPtoPTable.\n\n                  Setting this object to the value invalid(2) has the\n                  effect of invalidating the corresponding entry in\n                  the atportPtoPTable.  That is, it  effectively\n                  disassociates the mapping identified with said\n                  entry.  It is an implementation-specific matter as\n                  to whether the agent removes an invalidated entry\n                  from the table. Accordingly, management stations\n                  must be prepared to receive from agents tabular\n                  information corresponding to entries not currently\n                  in use.  Proper interpretation of such entries\n                  requires examinationr of the relevant\n                  atportPtoPStatus object.')
atportPtoPProtoOids = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 14, 2))
pToPProtoOther = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 14, 2, 1))
pToPProtoAurp = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 14, 2, 2))
pToPProtoCaymanUdp = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 14, 2, 3))
pToPProtoAtkvmsDecnetIV = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 14, 2, 4))
pToPProtoLiaisonUdp = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 14, 2, 5))
pToPProtoIpx = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 14, 2, 6))
pToPProtoShivaIp = MibIdentifier((1, 3, 6, 1, 2, 1, 13, 14, 2, 7))
perPortTable = MibTable((1, 3, 6, 1, 2, 1, 13, 18, 1), )
if mibBuilder.loadTexts: perPortTable.setDescription('The table of per-port statistics for this entity.')
perPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 13, 18, 1, 1), ).setIndexNames((0, "APPLETALK-MIB", "atportIndex"))
if mibBuilder.loadTexts: perPortEntry.setDescription('The statistics available for a particular port on\n                  this entity.\n\n                  As an example, an instance of the perPortAarpInProbes\n                  object might be named perPortAarpInProbes.2')
perPortAarpInProbes = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortAarpInProbes.setDescription('The total number of AARP Probe packets received\n                  by this entity on this port.')
perPortAarpOutProbes = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortAarpOutProbes.setDescription('The total number of AARP Probe packets sent by\n                  this entity on this port.')
perPortAarpInReqs = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortAarpInReqs.setDescription('The total number of AARP Request packets received\n                  by this entity on this port.')
perPortAarpOutReqs = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortAarpOutReqs.setDescription('The total number of AARP Request packets sent by\n                  this entity on this port.')
perPortAarpInRsps = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortAarpInRsps.setDescription('The total number of AARP Response packets received\n                  by this entity on this port.')
perPortAarpOutRsps = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortAarpOutRsps.setDescription('The total number of AARP Response packets sent by\n                  this entity on this port.')
perPortDdpInReceives = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortDdpInReceives.setDescription('The total number of input datagrams received by DDP\n                  on this port, including those received in error.')
perPortDdpInLocalDatagrams = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortDdpInLocalDatagrams.setDescription('The total number of input DDP datagrams on this\n                  port for which this entity was their final DDP\n                  destination.')
perPortDdpNoProtocolHandlers = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortDdpNoProtocolHandlers.setDescription('The total number of DDP datagrams addressed to this\n                  entity on this port that were addressed to an upper\n                  layer protocol for which no protocol handler\n                  existed.')
perPortDdpTooShortErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortDdpTooShortErrors.setDescription('The total number of input DDP datagrams on this\n                  port dropped because the received data length was\n                  less than the data length specified in the DDP\n                  header or the received data length was less than the\n                  length of the expected DDP header.')
perPortDdpTooLongErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortDdpTooLongErrors.setDescription('The total number of input DDP datagrams on this\n                  port dropped because they exceeded the maximum DDP\n                  datagram size.')
perPortDdpChecksumErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortDdpChecksumErrors.setDescription('The total number of input DDP datagrams on this\n                  port for which this DDP entity was their final\n                  destination, and which were dropped because of a\n                  checksum error.')
perPortDdpForwRequests = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortDdpForwRequests.setDescription('The number of input datagrams on this port for\n                  which this entity was not their final DDP\n                  destination, as a result of which an attempt was\n                  made to find a route to forward them to that final\n                  destination.')
perPortRtmpInDataPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortRtmpInDataPkts.setDescription('A count of the number of good RTMP data packets\n                  received by this entity on this port.')
perPortRtmpOutDataPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortRtmpOutDataPkts.setDescription('A count of the number of RTMP packets sent by this\n                  entity on this port.')
perPortRtmpInRequestPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortRtmpInRequestPkts.setDescription('A count of the number of good RTMP Request packets\n                  received by this entity on this port.')
perPortRtmpRouteDeletes = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortRtmpRouteDeletes.setDescription('A count of the number of times RTMP deletes a route\n                  on this port because it was aged out of the table.')
perPortZipInZipQueries = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortZipInZipQueries.setDescription('The number of ZIP Queries received by this entity\n                  on this port.')
perPortZipInZipReplies = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortZipInZipReplies.setDescription('The number of ZIP Replies received by this entity\n                  on this port.')
perPortZipInZipExtendedReplies = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortZipInZipExtendedReplies.setDescription('The number of ZIP Extended Replies received by this\n                  entity on this port.')
perPortZipZoneConflictErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortZipZoneConflictErrors.setDescription("The number of times a conflict has been detected on\n                  this port between this entity's zone information and\n                  another entity's zone information.")
perPortZipInErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortZipInErrors.setDescription('The number of ZIP packets received by this entity\n                  on this port that were rejected for any error.')
perPortNbpInLookUpRequests = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortNbpInLookUpRequests.setDescription('The number of NBP LookUp Requests received on this\n                  port.')
perPortNbpInLookUpReplies = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortNbpInLookUpReplies.setDescription('The number of NBP LookUp Replies received on this\n                  port.')
perPortNbpInBroadcastRequests = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortNbpInBroadcastRequests.setDescription('The number of NBP Broadcast Requests received on\n                  this port.')
perPortNbpInForwardRequests = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortNbpInForwardRequests.setDescription('The number of NBP Forward Requests received on this\n                  port.')
perPortNbpOutLookUpReplies = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortNbpOutLookUpReplies.setDescription('The number of NBP LookUp Replies sent on this port.')
perPortNbpRegistrationFailures = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortNbpRegistrationFailures.setDescription('The number of times this node experienced a failure\n                  in attempting to register an NBP entity on this\n                  port.')
perPortNbpInErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortNbpInErrors.setDescription('The number of NBP packets received by this entity\n                  on this port that were rejected for any error.')
perPortEchoRequests = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortEchoRequests.setDescription('The number of AppleTalk Echo requests received on\n                  this port.')
perPortEchoReplies = MibTableColumn((1, 3, 6, 1, 2, 1, 13, 18, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perPortEchoReplies.setDescription('The count of AppleTalk Echo replies received on\n                  this port.')
mibBuilder.exportSymbols("APPLETALK-MIB", aarpIfIndex=aarpIfIndex, ddpOutRequests=ddpOutRequests, adspConnLocalConnID=adspConnLocalConnID, rtmpOutDataPkts=rtmpOutDataPkts, nbpInLookUpReplies=nbpInLookUpReplies, ddpTooLongErrors=ddpTooLongErrors, perPortEchoReplies=perPortEchoReplies, aspNoMoreSessionsErrors=aspNoMoreSessionsErrors, rtmp=rtmp, papServerAccountingFailures=papServerAccountingFailures, DdpNodeAddress=DdpNodeAddress, atportStatus=atportStatus, atpListenerAddress=atpListenerAddress, adspOutOctets=adspOutOctets, ddpTooShortErrors=ddpTooShortErrors, atechoOutRequests=atechoOutRequests, aspConnLastReqNum=aspConnLastReqNum, zipEndNode=zipEndNode, perPortAarpOutReqs=perPortAarpOutReqs, appletalk=appletalk, kip=kip, perPortNbpInBroadcastRequests=perPortNbpInBroadcastRequests, llapInNoHandlers=llapInNoHandlers, atpRetryCountExceededs=atpRetryCountExceededs, perPortDdpNoProtocolHandlers=perPortDdpNoProtocolHandlers, papServerFreeJobs=papServerFreeJobs, perPortEchoRequests=perPortEchoRequests, aarpHits=aarpHits, zipInZipExtendedReplies=zipInZipExtendedReplies, perPortDdpChecksumErrors=perPortDdpChecksumErrors, perPortZipInErrors=perPortZipInErrors, aarpNetAddress=aarpNetAddress, pToPProtoAtkvmsDecnetIV=pToPProtoAtkvmsDecnetIV, aspConnTable=aspConnTable, atechoInReplies=atechoInReplies, papServerEntry=papServerEntry, zipOutGetNetInfoReplies=zipOutGetNetInfoReplies, atportZoneDefault=atportZoneDefault, zipZoneNetStart=zipZoneNetStart, atechoReplies=atechoReplies, aspConnEntry=aspConnEntry, atportNetEnd=atportNetEnd, perPortDdpInReceives=perPortDdpInReceives, ddpListenerTable=ddpListenerTable, atpListenerStatus=atpListenerStatus, atportType=atportType, perPortZipZoneConflictErrors=perPortZipZoneConflictErrors, adspConnRemoteConnID=adspConnRemoteConnID, atpListenerTable=atpListenerTable, rtmpNextIRLessChanges=rtmpNextIRLessChanges, papInDatas=papInDatas, ddpForwardingTable=ddpForwardingTable, zipInErrors=zipInErrors, kipNetStart=kipNetStart, atp=atp, zipNetInfoEntry=zipNetInfoEntry, adspInPkts=adspInPkts, perPortNbpOutLookUpReplies=perPortNbpOutLookUpReplies, zipInZipQueries=zipInZipQueries, perPortRtmpInRequestPkts=perPortRtmpInRequestPkts, nbpEntry=nbpEntry, llapEntry=llapEntry, rtmpState=rtmpState, papInOpenConns=papInOpenConns, pap=pap, rtmpOutRequestPkts=rtmpOutRequestPkts, zipZonePort=zipZonePort, perPortAarpInRsps=perPortAarpInRsps, ddpForwProtoOids=ddpForwProtoOids, kipNetEnd=kipNetEnd, aspInputTransactions=aspInputTransactions, ddpOutShorts=ddpOutShorts, perPortAarpInReqs=perPortAarpInReqs, ddpBroadcastErrors=ddpBroadcastErrors, zipNetInfoTable=zipNetInfoTable, atportPtoPRemoteAddress=atportPtoPRemoteAddress, ddpHopCountErrors=ddpHopCountErrors, rtmpInVersionMismatches=rtmpInVersionMismatches, nbpZone=nbpZone, aarp=aarp, adspInDataPkts=adspInDataPkts, rtmpType=rtmpType, atechoRequests=atechoRequests, ddpListenerEntry=ddpListenerEntry, atportNetStart=atportNetStart, nbpEnumerator=nbpEnumerator, nbpObject=nbpObject, atportZoneFrom=atportZoneFrom, pToPProtoAurp=pToPProtoAurp, perPortEntry=perPortEntry, perPortRtmpRouteDeletes=perPortRtmpRouteDeletes, zipZoneName=zipZoneName, perPortNbpInForwardRequests=perPortNbpInForwardRequests, perPortDdpInLocalDatagrams=perPortDdpInLocalDatagrams, papOutDatas=papOutDatas, kipTable=kipTable, pToPProtoOther=pToPProtoOther, perPortDdpTooShortErrors=perPortDdpTooShortErrors, kipHopCount=kipHopCount, ddpForwardingTableOverflows=ddpForwardingTableOverflows, atportPtoPProtoOids=atportPtoPProtoOids, atportHome=atportHome, zipZoneOutInvalids=zipZoneOutInvalids, adspTimeoutErrors=adspTimeoutErrors, atportEntry=atportEntry, ddpInLocalDatagrams=ddpInLocalDatagrams, nbpAddress=nbpAddress, perPortZipInZipReplies=perPortZipInZipReplies, adspOutDataPkts=adspOutDataPkts, llapCollisions=llapCollisions, perPortAarpOutRsps=perPortAarpOutRsps, aarpTable=aarpTable, aarpStatus=aarpStatus, ddpForwardingNextHop=ddpForwardingNextHop, ddpForwardingPort=ddpForwardingPort, atportOutPkts=atportOutPkts, papServerState=papServerState, atportPtoPStatus=atportPtoPStatus, ddpListenerStatus=ddpListenerStatus, pToPProtoLiaisonUdp=pToPProtoLiaisonUdp, aspConnServerEnd=aspConnServerEnd, atportZoneTable=atportZoneTable, papServerListeningSocket=papServerListeningSocket, atportDescr=atportDescr, rtmpInRequestPkts=rtmpInRequestPkts, adspTimeoutCloseErrors=adspTimeoutCloseErrors, adspConnTable=adspConnTable, aspConnState=aspConnState, zipInObsoletes=zipInObsoletes, kipBCastAddr=kipBCastAddr, nbpTable=nbpTable, ddpForwardingNetEnd=ddpForwardingNetEnd, atpTResponseRetransmissions=atpTResponseRetransmissions, adspConnEntry=adspConnEntry, perPortNbpInLookUpRequests=perPortNbpInLookUpRequests, aspTickleTimeOutCloses=aspTickleTimeOutCloses, llapIfIndex=llapIfIndex, atportConflictPhysAddr=atportConflictPhysAddr, rtmpRangeEnd=rtmpRangeEnd, aspConnRemoteAddress=aspConnRemoteAddress, papServerAuthenticationFailures=papServerAuthenticationFailures, perPortTable=perPortTable, atportPtoPRemoteName=atportPtoPRemoteName, ATNetworkNumber=ATNetworkNumber, perPortZipInZipExtendedReplies=perPortZipInZipExtendedReplies, perPortNbpRegistrationFailures=perPortNbpRegistrationFailures, aarpLookups=aarpLookups, perPortAarpInProbes=perPortAarpInProbes, zipRouter=zipRouter, ddpInReceives=ddpInReceives, rtmpRoutingProto=rtmpRoutingProto, nbpType=nbpType, papOutOpenConns=papOutOpenConns, rtmpEntry=rtmpEntry, ddpListenerAddress=ddpListenerAddress, zipZoneInInvalids=zipZoneInInvalids, ddpListenerInPkts=ddpListenerInPkts, atportptop=atportptop, atportCurrentZone=atportCurrentZone, rtmpNextHop=rtmpNextHop, atportZonePort=atportZonePort, atportTable=atportTable, rtmpRoutingTableOverflows=rtmpRoutingTableOverflows, perPortDdpForwRequests=perPortDdpForwRequests, llapDefers=llapDefers, ddpForwardingProto=ddpForwardingProto, atportPtoPTable=atportPtoPTable, llapOutPkts=llapOutPkts, papServerGeneralFailures=papServerGeneralFailures, atportIndex=atportIndex, atpOutPkts=atpOutPkts, ddpForwRequests=ddpForwRequests, perPortDdpTooLongErrors=perPortDdpTooLongErrors, zipZoneIndex=zipZoneIndex, atportZoneConfig=atportZoneConfig, adspInOctets=adspInOctets, zipZoneFrom=zipZoneFrom, llapTable=llapTable, atportNetAddress=atportNetAddress, zipZoneNetEnd=zipZoneNetEnd, aspInOpenSessions=aspInOpenSessions, adspConnLocalAddress=adspConnLocalAddress, kipState=kipState, zipRouterNetInfoTable=zipRouterNetInfoTable, adspOutPkts=adspOutPkts, kipEntry=kipEntry, aarpPhysAddress=aarpPhysAddress, zipInGetNetInfos=zipInGetNetInfos, nbp=nbp, nbpInLookUpRequests=nbpInLookUpRequests, ddp=ddp, aspConnID=aspConnID, pToPProtoIpx=pToPProtoIpx, aarpEntry=aarpEntry, nbpIndex=nbpIndex, atportPtoPPortIndex=atportPtoPPortIndex, rtmpStub=rtmpStub, ddpChecksumErrors=ddpChecksumErrors, llapInLengthErrors=llapInLengthErrors, nbpInErrors=nbpInErrors, papServerTable=papServerTable, atportNetFrom=atportNetFrom, rtmpInErrors=rtmpInErrors, rtmpNextIREqualChanges=rtmpNextIREqualChanges, zipAddressInvalids=zipAddressInvalids, atport=atport, ddpForwardingNetStart=ddpForwardingNetStart, papServerIndex=papServerIndex, kipFrom=kipFrom, atportPtoPIndex=atportPtoPIndex, atportIfIndex=atportIfIndex, asp=asp, kipType=kipType, zipInZipReplies=zipInZipReplies, atpInPkts=atpInPkts, papServerBusyJobs=papServerBusyJobs, rtmpRangeStart=rtmpRangeStart, atportZoneStatus=atportZoneStatus, papServerStatus=papServerStatus, kipNextHop=kipNextHop, perPort=perPort, perPortNbpInErrors=perPortNbpInErrors, atecho=atecho, rtmpRouteDeletes=rtmpRouteDeletes, llapFCSErrors=llapFCSErrors, zipRouterNetInfoEntry=zipRouterNetInfoEntry, aspConnLocalAddress=aspConnLocalAddress, kipRoutingProto=kipRoutingProto, aspOutCloseSessions=aspOutCloseSessions, nbpInBroadcastRequests=nbpInBroadcastRequests, ddpForwardingEntry=ddpForwardingEntry, papTickleTimeoutCloses=papTickleTimeoutCloses, zipEntry=zipEntry, nbpState=nbpState, perPortRtmpOutDataPkts=perPortRtmpOutDataPkts, atportPtoPEntry=atportPtoPEntry, rtmpPort=rtmpPort, perPortNbpInLookUpReplies=perPortNbpInLookUpReplies, kipShare=kipShare, aspOutputTransactions=aspOutputTransactions, atportZoneEntry=atportZoneEntry, llapNoDataErrors=llapNoDataErrors, rtmpHops=rtmpHops, atpTRequestRetransmissions=atpTRequestRetransmissions, papServerCompletedJobs=papServerCompletedJobs, perPortZipInZipQueries=perPortZipInZipQueries, ddpShortDDPErrors=ddpShortDDPErrors, llapInErrors=llapInErrors, ddpOutLongs=ddpOutLongs, kipCore=kipCore, zipZoneConflictErrors=zipZoneConflictErrors, ddpOutNoRoutes=ddpOutNoRoutes, zipInGetNetInfoReplies=zipInGetNetInfoReplies, adsp=adsp)
mibBuilder.exportSymbols("APPLETALK-MIB", zipOutGetNetInfos=zipOutGetNetInfos, zipZoneState=zipZoneState, llap=llap, llapInPkts=llapInPkts, ddpForwardingUseCounts=ddpForwardingUseCounts, nbpOutLookUpReplies=nbpOutLookUpReplies, ATName=ATName, atpReleaseTimerExpiredCounts=atpReleaseTimerExpiredCounts, nbpRegistrationFailures=nbpRegistrationFailures, ddpForwardingModifiedTime=ddpForwardingModifiedTime, zipTable=zipTable, atportInPkts=atportInPkts, papOutCloseConns=papOutCloseConns, rtmpTable=rtmpTable, pToPProtoCaymanUdp=pToPProtoCaymanUdp, pToPProtoShivaIp=pToPProtoShivaIp, papServerLastStatusMsg=papServerLastStatusMsg, atportPtoPProtocol=atportPtoPProtocol, perPortRtmpInDataPkts=perPortRtmpInDataPkts, papInCloseConns=papInCloseConns, aspOutOpenSessions=aspOutOpenSessions, aspInCloseSessions=aspInCloseSessions, DdpSocketAddress=DdpSocketAddress, adspConnState=adspConnState, perPortAarpOutProbes=perPortAarpOutProbes, nbpInForwardRequests=nbpInForwardRequests, atportNetConfig=atportNetConfig, llapRandomCTSErrors=llapRandomCTSErrors, rtmpInDataPkts=rtmpInDataPkts, adspConnRemoteAddress=adspConnRemoteAddress, atportZoneName=atportZoneName, atpListenerEntry=atpListenerEntry, ddpNoProtocolHandlers=ddpNoProtocolHandlers)
