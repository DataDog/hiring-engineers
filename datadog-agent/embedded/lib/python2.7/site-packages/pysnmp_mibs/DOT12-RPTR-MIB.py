#
# PySNMP MIB module DOT12-RPTR-MIB (http://pysnmp.sf.net)
# ASN.1 source http://mibs.snmplabs.com:80/asn1/DOT12-RPTR-MIB
# Produced by pysmi-0.0.7 at Sun Feb 14 00:10:28 2016
# On host bldfarm platform Linux version 4.1.13-100.fc21.x86_64 by user goose
# Using Python version 3.5.0 (default, Jan  5 2016, 17:11:52) 
#
( ObjectIdentifier, Integer, OctetString, ) = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( NotificationGroup, ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
( ModuleIdentity, ObjectIdentity, Bits, mib_2, NotificationType, iso, Counter64, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, TimeTicks, IpAddress, Gauge32, Counter32, MibIdentifier, ) = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "ObjectIdentity", "Bits", "mib-2", "NotificationType", "iso", "Counter64", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "TimeTicks", "IpAddress", "Gauge32", "Counter32", "MibIdentifier")
( TimeStamp, DisplayString, MacAddress, TruthValue, TextualConvention, ) = mibBuilder.importSymbols("SNMPv2-TC", "TimeStamp", "DisplayString", "MacAddress", "TruthValue", "TextualConvention")
vgRptrMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 53))
if mibBuilder.loadTexts: vgRptrMIB.setLastUpdated('9705192256Z')
if mibBuilder.loadTexts: vgRptrMIB.setOrganization('IETF 100VG-AnyLAN Working Group')
if mibBuilder.loadTexts: vgRptrMIB.setContactInfo('WG E-mail: vgmib@hprnd.rose.hp.com\n\n                            Chair: Jeff Johnson\n                           Postal: RedBack Networks\n                                   2570 North First Street, Suite 410\n                                   San Jose, CA  95131\n                              Tel: +1 408 571 2699\n                              Fax: +1 408 571 2698\n                           E-mail: jeff@redbacknetworks.com\n\n                           Editor: John Flick\n                           Postal: Hewlett Packard Company\n                                   8000 Foothills Blvd. M/S 5556\n                                   Roseville, CA 95747-5556\n                              Tel: +1 916 785 4018\n                              Fax: +1 916 785 3583\n                           E-mail: johnf@hprnd.rose.hp.com')
if mibBuilder.loadTexts: vgRptrMIB.setDescription('This MIB module describes objects for managing\n                       IEEE 802.12 repeaters.')
vgRptrObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1))
vgRptrBasic = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 1))
vgRptrBasicRptr = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 1, 1))
vgRptrInfoTable = MibTable((1, 3, 6, 1, 2, 1, 53, 1, 1, 1, 1), )
if mibBuilder.loadTexts: vgRptrInfoTable.setDescription('A table of information about each 802.12 repeater\n                      in the managed system.')
vgRptrInfoEntry = MibTableRow((1, 3, 6, 1, 2, 1, 53, 1, 1, 1, 1, 1), ).setIndexNames((0, "DOT12-RPTR-MIB", "vgRptrInfoIndex"))
if mibBuilder.loadTexts: vgRptrInfoEntry.setDescription('An entry in the table, containing information\n                      about a single repeater.')
vgRptrInfoIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647)))
if mibBuilder.loadTexts: vgRptrInfoIndex.setDescription('A unique identifier for the repeater for which\n                      this entry contains information.  The numbering\n                      scheme for repeaters is implementation specific.')
vgRptrInfoMACAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 1, 1, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrInfoMACAddress.setDescription('The MAC address used by the repeater when it\n                      initiates training on the uplink port.  Repeaters\n                      are allowed to train with an assigned MAC address\n                      or a null (all zeroes) MAC address.')
vgRptrInfoCurrentFramingType = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("frameType88023", 1), ("frameType88025", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrInfoCurrentFramingType.setDescription('The type of framing (802.3 or 802.5) currently\n                      in use by the repeater.')
vgRptrInfoDesiredFramingType = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("frameType88023", 1), ("frameType88025", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vgRptrInfoDesiredFramingType.setDescription('The type of framing which will be used by the\n                      repeater after the next time it is reset.\n\n                      The value of this object should be preserved\n                      across repeater resets and power failures.')
vgRptrInfoFramingCapability = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("frameType88023", 1), ("frameType88025", 2), ("frameTypeEither", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrInfoFramingCapability.setDescription('The type of framing this repeater is capable of\n                      supporting.')
vgRptrInfoTrainingVersion = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrInfoTrainingVersion.setDescription('The highest version bits (vvv bits) supported by\n                      the repeater during training.')
vgRptrInfoOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("generalFailure", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrInfoOperStatus.setDescription('The vgRptrInfoOperStatus object indicates the\n                      operational state of the repeater.')
vgRptrInfoReset = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vgRptrInfoReset.setDescription('Setting this object to reset(2) causes the\n                      repeater to transition to its initial state as\n                      specified in clause 12 [IEEE Std 802.12].\n                      Setting this object to noReset(1) has no effect.\n                      The agent will always return the value noReset(1)\n                      when this object is read.\n\n                      After receiving a request to set this variable to\n                      reset(2), the agent is allowed to delay the reset\n                      for a short period.  For example, the implementor\n                      may choose to delay the reset long enough to\n                      allow the SNMP response to be transmitted.  In\n                      any event, the SNMP response must be transmitted.\n\n                      This action does not reset the management\n                      counters defined in this document nor does it\n                      affect the vgRptrPortAdminStatus parameters.\n                      Included in this action is the execution of a\n                      disruptive Self-Test with the following\n                      characteristics:\n\n                          1) The nature of the tests is not specified.\n                          2) The test resets the repeater but without\n                             affecting configurable management\n                             information about the repeater.\n                          3) Packets received during the test may or\n                             may not be transferred.\n                          4) The test does not interfere with\n                             management functions.\n\n                      After performing this self-test, the agent will\n                      update the repeater health information (including\n                      vgRptrInfoOperStatus), and send a\n                      vgRptrResetEvent.')
vgRptrInfoLastChange = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 1, 1, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrInfoLastChange.setDescription('The value of sysUpTime when any of the following\n                      conditions occurred:\n\n                          1) agent cold- or warm-started;\n                          2) this instance of repeater was created\n                             (such as when a device or module was\n                             added to the system);\n\n                          3) a change in the value of\n                             vgRptrInfoOperStatus;\n                          4) ports were added or removed as members of\n                             the repeater; or\n                          5) any of the counters associated with this\n                             repeater had a discontinuity.')
vgRptrBasicGroup = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 1, 2))
vgRptrBasicGroupTable = MibTable((1, 3, 6, 1, 2, 1, 53, 1, 1, 2, 1), )
if mibBuilder.loadTexts: vgRptrBasicGroupTable.setDescription('A table containing information about groups of\n                      ports.')
vgRptrBasicGroupEntry = MibTableRow((1, 3, 6, 1, 2, 1, 53, 1, 1, 2, 1, 1), ).setIndexNames((0, "DOT12-RPTR-MIB", "vgRptrGroupIndex"))
if mibBuilder.loadTexts: vgRptrBasicGroupEntry.setDescription('An entry in the vgRptrBasicGroupTable, containing\n                      information about a single group of ports.')
vgRptrGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2146483647)))
if mibBuilder.loadTexts: vgRptrGroupIndex.setDescription('This object identifies the group within the\n                      system for which this entry contains information.\n                      The numbering scheme for groups is implementation\n                      specific.')
vgRptrGroupObjectID = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 2, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrGroupObjectID.setDescription("The vendor's authoritative identification of the\n                      group.  This value may be allocated within the\n                      SMI enterprises subtree (1.3.6.1.4.1) and\n                      provides a straight-forward and unambiguous means\n                      for determining what kind of group is being\n                      managed.\n\n                      For example, this object could take the value\n                      1.3.6.1.4.1.4242.1.2.14 if vendor 'Flintstones,\n                      Inc.' was assigned the subtree 1.3.6.1.4.1.4242,\n                      and had assigned the identifier\n                      1.3.6.1.4.1.4242.1.2.14 to its 'Wilma Flintstone\n                      6-Port Plug-in Module.'")
vgRptrGroupOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6,))).clone(namedValues=NamedValues(("other", 1), ("operational", 2), ("malfunctioning", 3), ("notPresent", 4), ("underTest", 5), ("resetInProgress", 6),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrGroupOperStatus.setDescription('An object that indicates the operational status\n                      of the group.\n\n                      A status of notPresent(4) indicates that the\n                      group is temporarily or permanently physically\n                      and/or logically not a part of the system.  It\n                      is an implementation-specific matter as to\n                      whether the agent effectively removes notPresent\n                      entries from the table.\n\n                      A status of operational(2) indicates that the\n                      group is functioning, and a status of\n                      malfunctioning(3) indicates that the group is\n                      malfunctioning in some way.')
vgRptrGroupPortCapacity = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2146483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrGroupPortCapacity.setDescription('The vgRptrGroupPortCapacity is the number of\n                      ports that can be contained within the group.\n                      Valid range is 1-2147483647.  Within each group,\n                      the ports are uniquely numbered in the range from\n                      1 to vgRptrGroupPortCapacity.\n\n                      Some ports may not be present in the system, in\n                      which case the actual number of ports present will\n                      be less than the value of vgRptrGroupPortCapacity.\n                      The number of ports present is never greater than\n                      the value of vgRptrGroupPortCapacity.\n\n                      Note:  In practice, this will generally be the\n                      number of ports on a module, card, or board, and\n                      the port numbers will correspond to numbers marked\n                      on the physical embodiment.')
vgRptrGroupCablesBundled = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("someCablesBundled", 1), ("noCablesBundled", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vgRptrGroupCablesBundled.setDescription("This object is used to indicate whether there are\n                      any four-pair UTP links connected to this group\n                      that are contained in a cable bundle with multiple\n                      four-pair groups (e.g. a 25-pair bundle).  Bundled\n                      cable may only be used for repeater-to-end node\n                      links where the end node is not in promiscuous\n                      mode.\n\n                      When a broadcast or multicast packet is received\n                      from a port on this group that is not a\n                      promiscuous or cascaded port, the packet will be\n                      buffered completely before being repeated if\n                      this object is set to 'someCablesBundled(1)'.\n                      When this object is equal to 'noCablesBundled(2)',\n                      all packets received from ports on this group will\n                      be repeated as the frame is being received.\n\n                      Note that the value 'someCablesBundled(1)' will\n                      work in the vast majority of all installations,\n                      regardless of whether or not any cables are\n                      physically in a bundle, since packets received\n                      from promiscuous and cascaded ports automatically\n                      avoid the store and forward.  The main situation\n                      in which 'noCablesBundled(2)' is beneficial is\n                      when there is a large amount of multicast traffic\n                      and the cables are not in a bundle.\n\n                      The value of this object should be preserved\n                      across repeater resets and power failures.")
vgRptrBasicPort = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 1, 3))
vgRptrBasicPortTable = MibTable((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1), )
if mibBuilder.loadTexts: vgRptrBasicPortTable.setDescription('A table containing configuration and status\n                      information about 802.12 repeater ports in the\n                      system.  The number of entries is independent of\n                      the number of repeaters in the managed system.')
vgRptrBasicPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1), ).setIndexNames((0, "DOT12-RPTR-MIB", "vgRptrGroupIndex"), (0, "DOT12-RPTR-MIB", "vgRptrPortIndex"))
if mibBuilder.loadTexts: vgRptrBasicPortEntry.setDescription('An entry in the vgRptrBasicPortTable, containing\n                      information about a single port.')
vgRptrPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647)))
if mibBuilder.loadTexts: vgRptrPortIndex.setDescription('This object identifies the port within the group\n                      for which this entry contains information.  This\n                      identifies the port independently from the\n                      repeater it may be attached to.  The numbering\n                      scheme for ports is implementation specific;\n                      however, this value can never be greater than\n                      vgRptrGroupPortCapacity for the associated group.')
vgRptrPortType = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4,))).clone(namedValues=NamedValues(("cascadeExternal", 1), ("cascadeInternal", 2), ("localExternal", 3), ("localInternal", 4),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortType.setDescription("Describes the type of port.  One of the\n                      following:\n\n                          cascadeExternal - Port is an uplink with\n                                            physical connections which\n                                            are externally visible\n                          cascadeInternal - Port is an uplink with\n                                            physical connections which\n                                            are not externally visible,\n                                            such as a connection to an\n                                            internal backplane in a\n                                            chassis\n                          localExternal   - Port is a downlink or local\n                                            port with externally\n                                            visible connections\n                          localInternal   - Port is a downlink or local\n                                            port with connections which\n                                            are not externally visible,\n                                            such as a connection to an\n                                            internal agent\n\n                      'internal' is used to identify ports which place\n                      traffic into the repeater, but do not have any\n                      external connections.  Note that both DTE and\n                      cascaded repeater downlinks are considered\n                      'local' ports.")
vgRptrPortAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vgRptrPortAdminStatus.setDescription('Port enable/disable function.  Enabling a\n                      disabled port will cause training to be\n                      initiated by the training initiator (the slave\n                      mode device) on the link.  Setting this object to\n                      disabled(2) disables the port.\n\n                      A disabled port neither transmits nor receives.\n                      Once disabled, a port must be explicitly enabled\n                      to restore operation.  A port which is disabled\n                      when power is lost or when a reset is exerted\n                      shall remain disabled when normal operation\n                      resumes.\n\n                      The value of this object should be preserved\n                      across repeater resets and power failures.')
vgRptrPortOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2), ("training", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortOperStatus.setDescription("Current status for the port as specified by the\n                      PORT_META_STATE in the port process module of\n                      clause 12 [IEEE Std 802.12].\n\n                      During initialization or any link warning\n                      conditions, vgRptrPortStatus will be\n                      'inactive(2)'.\n\n                      When Training_Up is received by the repeater on a\n                      local port (or when Training_Down is received on\n                      a cascade port), vgRptrPortStatus will change to\n                      'training(3)' and vgRptrTrainingResult can be\n                      monitored to see the detailed status regarding\n                      training.\n\n                      When 24 consecutive good FCS packets are exchanged\n                      and the configuration bits are OK,\n                      vgRptrPortStatus will change to 'active(1)'.\n\n                      A disabled port shall have a port status of\n                      'inactive(2)'.")
vgRptrPortSupportedPromiscMode = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("singleModeOnly", 1), ("singleOrPromiscMode", 2), ("promiscModeOnly", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortSupportedPromiscMode.setDescription("This object describes whether the port hardware\n                      is capable of supporting promiscuous mode, single\n                      address mode (i.e., repeater filters unicasts not\n                      addressed to the end station attached to this\n                      port), or both.  A port for which vgRptrPortType\n                      is equal to 'cascadeInternal' or 'cascadeExternal'\n                      will always have a value of 'promiscModeOnly' for\n                      this object.")
vgRptrPortSupportedCascadeMode = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("endNodesOnly", 1), ("endNodesOrRepeaters", 2), ("cascadePort", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortSupportedCascadeMode.setDescription("This object describes whether the port hardware\n                      is capable of supporting cascaded repeaters, end\n                      nodes, or both.  A port for which vgRptrPortType\n                      is equal to 'cascadeInternal' or\n                      'cascadeExternal' will always have a value of\n                      'cascadePort' for this object.")
vgRptrPortAllowedTrainType = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4,))).clone(namedValues=NamedValues(("allowEndNodesOnly", 1), ("allowPromiscuousEndNodes", 2), ("allowEndNodesOrRepeaters", 3), ("allowAnything", 4),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vgRptrPortAllowedTrainType.setDescription("This security object is set by the network\n                      manager to configure what type of device is\n                      permitted to connect to the port.  One of the\n                      following values:\n                          allowEndNodesOnly        - only non-\n                                                     promiscuous end\n                                                     nodes permitted.\n                          allowPromiscuousEndNodes - promiscuous or\n                                                     non-promiscuous\n                                                     end nodes\n                                                     permitted\n                          allowEndNodesOrRepeaters - repeaters or non-\n                                                     promiscuous end\n                                                     nodes permitted\n                          allowAnything            - repeaters,\n                                                     promiscuous or\n                                                     non-promiscuous\n                                                     end nodes\n                                                     permitted\n\n                      For a port for which vgRptrPortType is equal to\n                      'cascadeInternal' or 'cascadeExternal', the\n                      corresponding instance of this object may not be\n                      set to 'allowEndNodesOnly' or\n                      'allowPromiscuousEndNodes'.\n\n                      The agent must reject a SET of this object if the\n                      value includes no capabilities that are\n                      supported by this port's hardware, as defined by\n                      the values of the corresponding instances of\n                      vgRptrPortSupportedPromiscMode and\n                      vgRptrPortSupportedCascadeMode.\n\n                      Note that vgRptrPortSupportPromiscMode and\n                      vgRptrPortSupportedCascadeMode represent what the\n                      port hardware is capable of supporting.\n                      vgRptrPortAllowedTrainType is used for setting an\n                      administrative policy for a port.  The actual set\n                      of training configurations that will be allowed\n                      to succeed on a port is the intersection of what\n                      the hardware will support and what is\n                      administratively allowed.  The above requirement\n                      on what values may be set to this object says that\n                      the intersection of what is supported and what is\n                      allowed must be non-empty.  In other words, it\n                      must not result in a situation in which nothing\n                      would be allowed to train on that port.  However,\n                      a value can be set to this object as long as the\n                      combination of this object and what is supported\n                      by the hardware would still leave at least one\n                      configuration that could successfully train on the\n                      port.\n                      The value of this object should be preserved\n                      across repeater resets and power failures.")
vgRptrPortLastTrainConfig = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2,2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortLastTrainConfig.setDescription("This object is a 16 bit field.  For local ports,\n                      this object contains the requested configuration\n                      field from the most recent error-free training\n                      request frame sent by the device connected to\n                      the port.  For cascade ports, this object contains\n                      the responder's allowed configuration field from\n                      the most recent error-free training response frame\n                      received in response to training initiated by this\n                      repeater.  The format of the current version of\n                      this field is described in section 3.2.  Please\n                      refer to the most recent version of the IEEE\n                      802.12 standard for the most up-to-date definition\n                      of the format of this object.")
vgRptrPortTrainingResult = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3,3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortTrainingResult.setDescription("This 18 bit field is used to indicate the result\n                      of training.  It contains two bits which indicate\n                      if error-free training frames have been received,\n                      and it also contains the 16 bits of the allowed\n                      configuration field from the most recent\n                      error-free training response frame on the port.\n\n                        First Octet:    Second and Third Octets:\n                        7 6 5 4 3 2 1 0\n                       +-+-+-+-+-+-+-+-+-----------------------------+\n                       |0|0|0|0|0|0|V|G| allowed configuration field |\n                       +-+-+-+-+-+-+-+-+-----------------------------+\n                          V:   Valid: set when at least one error-free\n                               training frame has been received.\n                               Indicates the 16 training configuration\n                               bits in vgRptrPortLastTrainConfig and\n                               vgRptrPortTrainingResult contain valid\n                               information.  This bit is cleared when\n                               vgRptrPortStatus transitions to the\n                               'inactive' or 'training' state.\n                          G:   LinkGood: indicates the link hardware is\n                               OK.  Set if 24 consecutive error-free\n                               training packets have been exchanged.\n                               Cleared when a training packet with\n                               errors is received, or when\n                               vgRptrPortStatus transitions to the\n                               'inactive' or 'training' state.\n\n                      The format of the current version of the allowed\n                      configuration field is described in section 3.2.\n                      Please refer to the most recent version of the\n                      IEEE 802.12 standard for the most up-to-date\n                      definition of the format of this field.\n\n                      If the port is in training, a management station\n                      can examine this object to see if any training\n                      packets have been passed successfully.  If there\n                      have been any good training packets, the Valid\n                      bit will be set and the management station can\n                      examine the allowed configuration field to see if\n                      there is a duplicate address, configuration, or\n                      security problem.\n\n                      Note that on a repeater local port, this repeater\n                      generates the training response bits, while on\n                      a cascade port, the device at the upper end of\n                      the link originated the training response bits.")
vgRptrPortPriorityEnable = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vgRptrPortPriorityEnable.setDescription("A configuration flag used to determine whether\n                      the repeater will service high priority requests\n                      received on the port as high priority or normal\n                      priority.  When 'false', high priority requests\n                      on this port will be serviced as normal priority.\n\n                      The setting of this object has no effect on a\n                      cascade port.  Also note that the setting of this\n                      object has no effect on a port connected to a\n                      cascaded repeater.  In both of these cases, this\n                      setting is treated as always 'true'.  The value\n                      'false' only has an effect when the port is a\n                      localInternal or localExternal port connected to\n                      an end node.\n\n                      The value of this object should be preserved\n                      across repeater resets and power failures.")
vgRptrPortRptrInfoIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortRptrInfoIndex.setDescription('This object identifies the repeater that this\n                      port is currently mapped to.  The repeater\n                      identified by a particular value of this object\n                      is the same as that identified by the same value\n                      of vgRptrInfoIndex.  A value of zero indicates\n                      that this port is not currently mapped to any\n                      repeater.')
vgRptrMonitor = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 2))
vgRptrMonRepeater = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 2, 1))
vgRptrMonitorTable = MibTable((1, 3, 6, 1, 2, 1, 53, 1, 2, 1, 1), )
if mibBuilder.loadTexts: vgRptrMonitorTable.setDescription('A table of performance and error statistics for\n                      each repeater in the system.  The instance of the\n                      vgRptrInfoLastChange associated with a repeater\n                      is used to indicate possible discontinuities of\n                      the counters in this table that are associated\n                      with the same repeater.')
vgRptrMonitorEntry = MibTableRow((1, 3, 6, 1, 2, 1, 53, 1, 2, 1, 1, 1), ).setIndexNames((0, "DOT12-RPTR-MIB", "vgRptrInfoIndex"))
if mibBuilder.loadTexts: vgRptrMonitorEntry.setDescription('An entry in the table, containing statistics\n                      for a single repeater.')
vgRptrMonTotalReadableFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 1, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrMonTotalReadableFrames.setDescription('The total number of good frames of valid frame\n                      length that have been received on all ports in\n                      this repeater.  If an implementation cannot\n                      obtain a count of frames as seen by the repeater\n                      itself, this counter may be implemented as the\n                      summation of the values of the\n                      vgRptrPortReadableFrames counters for all of the\n                      ports in this repeater.\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrInfoLastChange changes.')
vgRptrMonTotalReadableOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 1, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrMonTotalReadableOctets.setDescription('The total number of octets contained in good\n                      frames that have been received on all ports in\n                      this repeater.  If an implementation cannot\n                      obtain a count of octets as seen by the repeater\n                      itself, this counter may be implemented as the\n                      summation of the values of the\n                      vgRptrPortReadableOctets counters for all of the\n                      ports in this repeater.\n\n                      Note that this counter can roll over very\n                      quickly.  A management station is advised to\n                      also poll the vgRptrReadableOctetRollovers\n                      object, or to use the 64-bit counter defined by\n                      vgRptrMonHCTotalReadableOctets instead of the\n                      two 32-bit counters.\n\n                      This two-counter mechanism is provided for those\n                      network management protocols that do not support\n                      64-bit counters (e.g. SNMPv1).  Note that\n                      retrieval of these two counters in the same PDU\n                      is NOT guaranteed to be atomic.\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrInfoLastChange changes.')
vgRptrMonReadableOctetRollovers = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrMonReadableOctetRollovers.setDescription('The total number of times that the associated\n                      instance of the vgRptrMonTotalReadableOctets\n                      counter has rolled over.\n\n                      This two-counter mechanism is provided for those\n                      network management protocols that do not support\n                      64-bit counters (e.g. SNMPv1).  Note that\n                      retrieval of these two counters in the same PDU\n                      is NOT guaranteed to be atomic.\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrInfoLastChange changes.')
vgRptrMonHCTotalReadableOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 1, 1, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrMonHCTotalReadableOctets.setDescription('The total number of octets contained in good\n                      frames that have been received on all ports in\n                      this repeater.  If an implementation cannot\n                      obtain a count of octets as seen by the repeater\n                      itself, this counter may be implemented as the\n                      summation of the values of the\n                      vgRptrPortHCReadableOctets counters for all of the\n                      ports in this repeater.\n\n                      This counter is a 64 bit version of\n                      vgRptrMonTotalReadableOctets.  It should be used\n                      by Network Management protocols which support 64\n                      bit counters (e.g. SNMPv2).\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrInfoLastChange changes.')
vgRptrMonTotalErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrMonTotalErrors.setDescription('The total number of errors which have occurred on\n                      all of the ports in this repeater.  If an\n                      implementation cannot obtain a count of these\n                      errors as seen by the repeater itself, this\n                      counter may be implemented as the summation of the\n                      values of the vgRptrPortIPMFrames,\n                      vgRptrPortOversizeFrames, and\n                      vgRptrPortDataErrorFrames counters for all of the\n                      ports in this repeater.\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrInfoLastChange changes.')
vgRptrMonGroup = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 2, 2))
vgRptrMonPort = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 2, 3))
vgRptrMonPortTable = MibTable((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1), )
if mibBuilder.loadTexts: vgRptrMonPortTable.setDescription('A table of performance and error statistics for\n                      the ports.  The columnar object\n                      vgRptrPortLastChange is used to indicate possible\n                      discontinuities of counter type columnar objects\n                      in this table.')
vgRptrMonPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1), ).setIndexNames((0, "DOT12-RPTR-MIB", "vgRptrGroupIndex"), (0, "DOT12-RPTR-MIB", "vgRptrPortIndex"))
if mibBuilder.loadTexts: vgRptrMonPortEntry.setDescription('An entry in the vgRptrMonPortTable, containing\n                      performance and error statistics for a single\n                      port.')
vgRptrPortReadableFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortReadableFrames.setDescription('This object is the number of good frames of\n                      valid frame length that have been received on\n                      this port.  This counter is incremented by one\n                      for each frame received on the port which is not\n                      counted by any of the following error counters:\n                      vgRptrPortIPMFrames, vgRptrPortOversizeFrames,\n                      vgRptrPortNullAddressedFrames, or\n                      vgRptrPortDataErrorFrames.\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrPortLastChange changes.')
vgRptrPortReadableOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortReadableOctets.setDescription('This object is a count of the number of octets\n                      contained in good frames that have been received\n                      on this port.  This counter is incremented by\n                      OctetCount for each frame received on this port\n                      which has been determined to be a readable frame\n                      (i.e. each frame counted by\n                      vgRptrPortReadableFrames).\n\n                      Note that this counter can roll over very\n                      quickly.  A management station is advised to\n                      also poll the vgRptrPortReadOctetRollovers\n                      object, or to use the 64-bit counter defined by\n                      vgRptrPortHCReadableOctets instead of the two\n                      32-bit counters.\n\n                      This two-counter mechanism is provided for those\n                      network management protocols that do not support\n                      64-bit counters (e.g. SNMPv1).  Note that\n                      retrieval of these two counters in the same PDU\n                      is NOT guaranteed to be atomic.\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrPortLastChange changes.')
vgRptrPortReadOctetRollovers = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortReadOctetRollovers.setDescription('This object is a count of the number of times\n                      that the associated instance of the\n                      vgRptrPortReadableOctets counter has rolled over.\n\n                      This two-counter mechanism is provided for those\n                      network management protocols that do not support\n                      64-bit counters (e.g. SNMPv1).  Note that\n                      retrieval of these two counters in the same PDU\n                      is NOT guaranteed to be atomic.\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrPortLastChange changes.')
vgRptrPortHCReadableOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortHCReadableOctets.setDescription('This object is a count of the number of octets\n                      contained in good frames that have been received\n                      on this port.  This counter is incremented by\n                      OctetCount for each frame received on this port\n                      which has been determined to be a readable frame\n                      (i.e. each frame counted by\n                      vgRptrPortReadableFrames).\n\n                      This counter is a 64 bit version of\n                      vgRptrPortReadableOctets.  It should be used by\n                      Network Management protocols which support 64 bit\n                      counters (e.g. SNMPv2).\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrPortLastChange changes.')
vgRptrPortUnreadableOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortUnreadableOctets.setDescription('This object is a count of the number of octets\n                      contained in invalid frames that have been\n                      received on this port.  This counter is\n                      incremented by OctetCount for each frame received\n                      on this port which is counted by\n                      vgRptrPortIPMFrames, vgRptrPortOversizeFrames,\n                      vgRptrPortNullAddressedFrames, or\n                      vgRptrPortDataErrorFrames.  This counter can be\n                      combined with vgRptrPortReadableOctets to\n                      calculate network utilization.\n\n                      Note that this counter can roll over very\n                      quickly.  A management station is advised to\n                      also poll the vgRptrPortUnreadOctetRollovers\n                      object, or to use the 64-bit counter defined by\n                      vgRptrPortHCUnreadableOctets instead of the two\n                      32-bit counters.\n\n                      This two-counter mechanism is provided for those\n                      network management protocols that do not support\n                      64-bit counters (e.g. SNMPv1).  Note that\n                      retrieval of these two counters in the same PDU\n                      is NOT guaranteed to be atomic.\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrPortLastChange changes.')
vgRptrPortUnreadOctetRollovers = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortUnreadOctetRollovers.setDescription('This object is a count of the number of times\n                      that the associated instance of the\n                      vgRptrPortUnreadableOctets counter has rolled\n                      over.\n\n                      This two-counter mechanism is provided for those\n                      network management protocols that do not support\n                      64-bit counters (e.g. SNMPv1).  Note that\n                      retrieval of these two counters in the same PDU\n                      is NOT guaranteed to be atomic.\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrPortLastChange changes.')
vgRptrPortHCUnreadableOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortHCUnreadableOctets.setDescription('This object is a count of the number of octets\n                      contained in invalid frames that have been\n                      received on this port.  This counter is\n                      incremented by OctetCount for each frame received\n                      on this port which is counted by\n                      vgRptrPortIPMFrames, vgRptrPortOversizeFrames,\n                      vgRptrPortNullAddressedFrames, or\n                      vgRptrPortDataErrorFrames.  This counter can be\n                      combined with vgRptrPortHCReadableOctets to\n                      calculate network utilization.\n\n                      This counter is a 64 bit version of\n                      vgRptrPortUnreadableOctets.  It should be used\n                      by Network Management protocols which support 64\n                      bit counters (e.g. SNMPv2).\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrPortLastChange changes.')
vgRptrPortHighPriorityFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortHighPriorityFrames.setDescription('This object is a count of high priority frames\n                      that have been received on this port.  This\n                      counter is incremented by one for each high\n                      priority frame received on this port.  This\n                      counter includes both good and bad high priority\n                      frames, as well as high priority training frames.\n                      This counter does not include normal priority\n                      frames which were priority promoted.\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrPortLastChange changes.')
vgRptrPortHighPriorityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortHighPriorityOctets.setDescription('This object is a count of the number of octets\n                      contained in high priority frames that have been\n                      received on this port.  This counter is\n                      incremented by OctetCount for each frame received\n                      on this port which is counted by\n                      vgRptrPortHighPriorityFrames.\n\n                      Note that this counter can roll over very\n                      quickly.  A management station is advised to\n                      also poll the vgRptrPortHighPriOctetRollovers\n                      object, or to use the 64-bit counter defined by\n                      vgRptrPortHCHighPriorityOctets instead of the two\n                      32-bit counters.\n\n                      This two-counter mechanism is provided for those\n                      network management protocols that do not support\n                      64-bit counters (e.g. SNMPv1).  Note that\n                      retrieval of these two counters in the same PDU\n                      is NOT guaranteed to be atomic.\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrPortLastChange changes.')
vgRptrPortHighPriOctetRollovers = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortHighPriOctetRollovers.setDescription('This object is a count of the number of times\n                      that the associated instance of the\n                      vgRptrPortHighPriorityOctets counter has rolled\n                      over.\n\n                      This two-counter mechanism is provided for those\n                      network management protocols that do not support\n                      64-bit counters (e.g. SNMPv1).  Note that\n                      retrieval of these two counters in the same PDU\n                      is NOT guaranteed to be atomic.\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrPortLastChange changes.')
vgRptrPortHCHighPriorityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortHCHighPriorityOctets.setDescription('This object is a count of the number of octets\n                      contained in high priority frames that have been\n                      received on this port.  This counter is\n                      incremented by OctetCount for each frame received\n                      on this port which is counted by\n                      vgRptrPortHighPriorityFrames.\n\n                      This counter is a 64 bit version of\n                      vgRptrPortHighPriorityOctets.  It should be used\n                      by Network Management protocols which support\n                      64 bit counters (e.g. SNMPv2).\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrPortLastChange changes.')
vgRptrPortNormPriorityFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortNormPriorityFrames.setDescription('This object is a count of normal priority frames\n                      that have been received on this port.  This\n                      counter is incremented by one for each normal\n                      priority frame received on this port. This\n                      counter includes both good and bad normal\n                      priority frames, as well as normal priority\n                      training frames and normal priority frames which\n                      were priority promoted.\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrPortLastChange changes.')
vgRptrPortNormPriorityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortNormPriorityOctets.setDescription('This object is a count of the number of octets\n                      contained in normal priority frames that have\n                      been received on this port.  This counter is\n                      incremented by OctetCount for each frame received\n                      on this port which is counted by\n                      vgRptrPortNormPriorityFrames.\n\n                      Note that this counter can roll over very\n                      quickly.  A management station is advised to\n                      also poll the vgRptrPortNormPriOctetRollovers\n                      object, or to use the 64-bit counter defined by\n                      vgRptrPortHCNormPriorityOctets instead of the two\n                      32-bit counters.\n                      This two-counter mechanism is provided for those\n                      network management protocols that do not support\n                      64-bit counters (e.g. SNMPv1).  Note that\n                      retrieval of these two counters in the same PDU\n                      is NOT guaranteed to be atomic.\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrPortLastChange changes.')
vgRptrPortNormPriOctetRollovers = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortNormPriOctetRollovers.setDescription('This object is a count of the number of times\n                      that the associated instance of the\n                      vgRptrPortNormPriorityOctets counter has rolled\n                      over.\n\n                      This two-counter mechanism is provided for those\n                      network management protocols that do not support\n                      64-bit counters (e.g. SNMPv1).  Note that\n                      retrieval of these two counters in the same PDU\n                      is NOT guaranteed to be atomic.\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrPortLastChange changes.')
vgRptrPortHCNormPriorityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortHCNormPriorityOctets.setDescription('This object is a count of the number of octets\n                      contained in normal priority frames that have\n                      been received on this port.  This counter is\n                      incremented by OctetCount for each frame received\n                      on this port which is counted by\n                      vgRptrPortNormPriorityFrames.\n\n                      This counter is a 64 bit version of\n                      vgRptrPortNormPriorityOctets.  It should be used\n                      by Network Management protocols which support\n                      64 bit counters (e.g. SNMPv2).\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrPortLastChange changes.')
vgRptrPortBroadcastFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortBroadcastFrames.setDescription('This object is a count of broadcast packets that\n                      have been received on this port.  This counter is\n                      incremented by one for each readable frame\n                      received on this port whose destination MAC\n                      address is the broadcast address.  Frames\n                      counted by this counter are also counted by\n                      vgRptrPortReadableFrames.\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrPortLastChange changes.')
vgRptrPortMulticastFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortMulticastFrames.setDescription("This object is a count of multicast packets that\n                      have been received on this port.  This counter is\n                      incremented by one for each readable frame\n                      received on this port whose destination MAC\n                      address has the group address bit set, but is not\n                      the broadcast address.  Frames counted by this\n                      counter are also counted by\n                      vgRptrPortReadableFrames, but not by\n                      vgRptrPortBroadcastFrames.  Note that when the\n                      value of the instance vgRptrInfoCurrentFramingType\n                      for the repeater that this port is associated\n                      with is equal to 'frameType88025', this count\n                      includes packets addressed to functional\n                      addresses.\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrPortLastChange changes.")
vgRptrPortNullAddressedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortNullAddressedFrames.setDescription('This object is a count of null addressed packets\n                      that have been received on this port.  This\n                      counter is incremented by one for each frame\n                      received on this port with a destination MAC\n                      address consisting of all zero bits.  Both void\n                      and training frames are included in this\n                      counter.\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrPortLastChange changes.')
vgRptrPortIPMFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortIPMFrames.setDescription('This object is a count of the number of frames\n                      that have been received on this port with an\n                      invalid packet marker and no PMI errors.  A\n                      repeater will write an invalid packet marker to\n                      the end of a frame containing errors as it is\n                      forwarded through the repeater to the other\n                      ports.  This counter is incremented by one for\n                      each frame received on this port which has had an\n                      invalid packet marker added to the end of the\n                      frame.\n\n                      This counter indicates problems occurring in the\n                      domain of other repeaters, as opposed to problems\n                      with cables or devices directly attached to this\n                      repeater.\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrPortLastChange changes.')
vgRptrPortOversizeFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortOversizeFrames.setDescription('This object is a count of oversize frames\n                      received on this port.  This counter is\n                      incremented by one for each frame received on\n                      this port whose OctetCount is larger than the\n                      maximum legal frame size.\n\n                      The frame size which causes this counter to\n                      increment is dependent on the current value of\n                      vgRptrInfoCurrentFramingType for the repeater that\n                      the port is associated with.  When\n                      vgRptrInfoCurrentFramingType is equal to\n                      frameType88023 this counter will increment for\n                      frames that are 1519 octets or larger.  When\n                      vgRptrInfoCurrentFramingType is equal to\n                      frameType88025 this counter will increment for\n                      frames that are 4521 octets or larger.\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrPortLastChange changes.')
vgRptrPortDataErrorFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortDataErrorFrames.setDescription('This object is a count of errored frames\n                      received on this port.  This counter is\n                      incremented by one for each frame received on\n                      this port with any of the following errors: bad\n                      FCS (with no IPM), PMI errors (excluding frames\n                      with an IPM error as the only PMI error), or\n                      undersize (with no IPM).  Does not include\n                      packets counted by vgRptrPortIPMFrames,\n                      vgRptrPortOversizeFrames, or\n                      vgRptrPortNullAddressedFrames.\n\n                      This counter indicates problems with cables or\n                      devices directly connected to this repeater, while\n                      vgRptrPortIPMFrames indicates problems occurring\n                      in the domain of other repeaters.\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrPortLastChange changes.')
vgRptrPortPriorityPromotions = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortPriorityPromotions.setDescription('This counter is incremented by one each time the\n                      priority promotion timer has expired on this port\n                      and a normal priority frame is priority\n                      promoted.\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrPortLastChange changes.')
vgRptrPortTransitionToTrainings = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortTransitionToTrainings.setDescription("This counter is incremented by one each time the\n                      vgRptrPortStatus object for this port transitions\n                      into the 'training' state.\n\n                      This counter may experience a discontinuity when\n                      the value of the corresponding instance of\n                      vgRptrPortLastChange changes.")
vgRptrPortLastChange = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 24), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortLastChange.setDescription('The value of sysUpTime when the last of the\n                      following occurred:\n                        1) the agent cold- or warm-started;\n                        2) the row for the port was created\n                           (such as when a device or module was\n                           added to the system); or\n                        3) any condition that would cause one of\n                           the counters for the row to experience\n                           a discontinuity.')
vgRptrAddrTrack = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 3))
vgRptrAddrTrackRptr = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 3, 1))
vgRptrAddrTrackGroup = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 3, 2))
vgRptrAddrTrackPort = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 3, 3))
vgRptrAddrTrackTable = MibTable((1, 3, 6, 1, 2, 1, 53, 1, 3, 3, 1), )
if mibBuilder.loadTexts: vgRptrAddrTrackTable.setDescription('Table of address mapping information about the\n                  ports.')
vgRptrAddrTrackEntry = MibTableRow((1, 3, 6, 1, 2, 1, 53, 1, 3, 3, 1, 1), ).setIndexNames((0, "DOT12-RPTR-MIB", "vgRptrGroupIndex"), (0, "DOT12-RPTR-MIB", "vgRptrPortIndex"))
if mibBuilder.loadTexts: vgRptrAddrTrackEntry.setDescription('An entry in the table, containing address mapping\n                  information about a single port.')
vgRptrAddrLastTrainedAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 3, 3, 1, 1, 1), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0,0),ValueSizeConstraint(6,6),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrAddrLastTrainedAddress.setDescription('This object is the MAC address of the last\n                      station which succeeded in training on this port.\n                      A cascaded repeater may train using the null\n                      address.  If no stations have succeeded in\n                      training on this port since the agent began\n                      monitoring the port activity, the agent shall\n                      return a string of length zero.')
vgRptrAddrTrainedAddrChanges = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 3, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrAddrTrainedAddrChanges.setDescription('This counter is incremented by one for each time\n                      that the vgRptrAddrLastTrainedAddress object for\n                      this port changes.')
vgRptrRptrDetectedDupAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 3, 3, 1, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrRptrDetectedDupAddress.setDescription("This object is used to indicate that the\n                      repeater detected an error-free training frame on\n                      this port with a non-null source MAC address which\n                      matches the value of vgRptrAddrLastTrainedAddress\n                      of another active port in the same repeater.  This\n                      is reset to 'false' when an error-free training\n                      frame is received with a non-null source MAC\n                      address which does not match\n                      vgRptrAddrLastTrainedAddress of another port which\n                      is active in the same repeater.\n\n                      For the cascade port, this object will be 'true'\n                      if the 'D' bit in the most recently received\n                      error-free training response frame was set,\n                      indicating the device at the other end of the link\n                      believes that this repeater's cascade port is\n                      using a duplicate address.  This may be because\n                      the device at the other end of the link detected a\n                      duplicate address itself, or, if the other device\n                      is also a repeater, it could be because\n                      vgRptrMgrDetectedDupAddress was set to 'true' on\n                      the port that this repeater's cascade port is\n                      connected to.")
vgRptrMgrDetectedDupAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 3, 3, 1, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vgRptrMgrDetectedDupAddress.setDescription("This object can be set by a management station\n                      when it detects that there is a duplicate MAC\n                      address.  This object is OR'd with\n                      vgRptrRptrDetectedDupAddress to form the value of\n                      the 'D' bit in training response frames on this\n                      port.\n\n                      The purpose of this object is to provide a means\n                      for network management software to inform an end\n                      station that it is using a duplicate station\n                      address.  Setting this object does not affect the\n                      current state of the link; the end station will\n                      not be informed of the duplicate address until it\n                      retrains for some reason.  Note that regardless\n                      of its station address, the end station will not\n                      be able to train successfully until the network\n                      management software has set this object back to\n                      'false'.  Although this object exists on\n                      cascade ports, it does not perform any function\n                      since this repeater is the initiator of training\n                      on a cascade port.")
vgRptrTraps = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 2))
vgRptrTrapPrefix = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 2, 0))
vgRptrHealth = NotificationType((1, 3, 6, 1, 2, 1, 53, 2, 0, 1)).setObjects(*(("DOT12-RPTR-MIB", "vgRptrInfoOperStatus"),))
if mibBuilder.loadTexts: vgRptrHealth.setDescription("A vgRptrHealth trap conveys information related\n                      to the operational state of a repeater.  This trap\n                      is sent when the value of an instance of\n                      vgRptrInfoOperStatus changes.  The vgRptrHealth\n                      trap is not sent as a result of powering up a\n                      repeater.\n\n                      The vgRptrHealth trap must contain the instance of\n                      the vgRptrInfoOperStatus object associated with\n                      the affected repeater.\n\n                      The agent must throttle the generation of\n                      consecutive vgRptrHealth traps so that there is at\n                      least a five-second gap between traps of this\n                      type.  When traps are throttled, they are dropped,\n                      not queued for sending at a future time.  (Note\n                      that 'generating' a trap means sending to all\n                      configured recipients.)")
vgRptrResetEvent = NotificationType((1, 3, 6, 1, 2, 1, 53, 2, 0, 2)).setObjects(*(("DOT12-RPTR-MIB", "vgRptrInfoOperStatus"),))
if mibBuilder.loadTexts: vgRptrResetEvent.setDescription("A vgRptrResetEvent trap conveys information\n                      related to the operational state of a repeater.\n                      This trap is sent on completion of a repeater\n                      reset action.  A repeater reset action is defined\n                      as a transition to its initial state as specified\n                      in clause 12 [IEEE Std 802.12] when triggered by\n                      a management command.\n\n                      The vgRptrResetEvent trap is not sent when the\n                      agent restarts and sends an SNMP coldStart or\n                      warmStart trap.\n\n                      The vgRptrResetEvent trap must contain the\n                      instance of the vgRptrInfoOperStatus object\n                      associated with the affected repeater.\n\n                      The agent must throttle the generation of\n                      consecutive vgRptrResetEvent traps so that there\n                      is at least a five-second gap between traps of\n                      this type.  When traps are throttled, they are\n                      dropped, not queued for sending at a future time.\n                      (Note that 'generating' a trap means sending to\n                      all configured recipients.)")
vgRptrConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 3))
vgRptrCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 3, 1))
vgRptrGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 3, 2))
vgRptrCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 53, 3, 1, 1)).setObjects(*(("DOT12-RPTR-MIB", "vgRptrConfigGroup"), ("DOT12-RPTR-MIB", "vgRptrStatsGroup"), ("DOT12-RPTR-MIB", "vgRptrAddrGroup"), ("DOT12-RPTR-MIB", "vgRptrNotificationsGroup"), ("DOT12-RPTR-MIB", "vgRptrStats64Group"), ("SNMP-REPEATER-MIB", "snmpRptrGrpRptrAddrSearch"),))
if mibBuilder.loadTexts: vgRptrCompliance.setDescription('The compliance statement for managed 802.12\n                      repeaters.')
vgRptrConfigGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 53, 3, 2, 1)).setObjects(*(("DOT12-RPTR-MIB", "vgRptrInfoMACAddress"), ("DOT12-RPTR-MIB", "vgRptrInfoCurrentFramingType"), ("DOT12-RPTR-MIB", "vgRptrInfoDesiredFramingType"), ("DOT12-RPTR-MIB", "vgRptrInfoFramingCapability"), ("DOT12-RPTR-MIB", "vgRptrInfoTrainingVersion"), ("DOT12-RPTR-MIB", "vgRptrInfoOperStatus"), ("DOT12-RPTR-MIB", "vgRptrInfoReset"), ("DOT12-RPTR-MIB", "vgRptrInfoLastChange"), ("DOT12-RPTR-MIB", "vgRptrGroupObjectID"), ("DOT12-RPTR-MIB", "vgRptrGroupOperStatus"), ("DOT12-RPTR-MIB", "vgRptrGroupPortCapacity"), ("DOT12-RPTR-MIB", "vgRptrGroupCablesBundled"), ("DOT12-RPTR-MIB", "vgRptrPortType"), ("DOT12-RPTR-MIB", "vgRptrPortAdminStatus"), ("DOT12-RPTR-MIB", "vgRptrPortOperStatus"), ("DOT12-RPTR-MIB", "vgRptrPortSupportedPromiscMode"), ("DOT12-RPTR-MIB", "vgRptrPortSupportedCascadeMode"), ("DOT12-RPTR-MIB", "vgRptrPortAllowedTrainType"), ("DOT12-RPTR-MIB", "vgRptrPortLastTrainConfig"), ("DOT12-RPTR-MIB", "vgRptrPortTrainingResult"), ("DOT12-RPTR-MIB", "vgRptrPortPriorityEnable"), ("DOT12-RPTR-MIB", "vgRptrPortRptrInfoIndex"),))
if mibBuilder.loadTexts: vgRptrConfigGroup.setDescription('A collection of objects for managing the status\n                      and configuration of IEEE 802.12 repeaters.')
vgRptrStatsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 53, 3, 2, 2)).setObjects(*(("DOT12-RPTR-MIB", "vgRptrMonTotalReadableFrames"), ("DOT12-RPTR-MIB", "vgRptrMonTotalReadableOctets"), ("DOT12-RPTR-MIB", "vgRptrMonReadableOctetRollovers"), ("DOT12-RPTR-MIB", "vgRptrMonTotalErrors"), ("DOT12-RPTR-MIB", "vgRptrPortReadableFrames"), ("DOT12-RPTR-MIB", "vgRptrPortReadableOctets"), ("DOT12-RPTR-MIB", "vgRptrPortReadOctetRollovers"), ("DOT12-RPTR-MIB", "vgRptrPortUnreadableOctets"), ("DOT12-RPTR-MIB", "vgRptrPortUnreadOctetRollovers"), ("DOT12-RPTR-MIB", "vgRptrPortHighPriorityFrames"), ("DOT12-RPTR-MIB", "vgRptrPortHighPriorityOctets"), ("DOT12-RPTR-MIB", "vgRptrPortHighPriOctetRollovers"), ("DOT12-RPTR-MIB", "vgRptrPortNormPriorityFrames"), ("DOT12-RPTR-MIB", "vgRptrPortNormPriorityOctets"), ("DOT12-RPTR-MIB", "vgRptrPortNormPriOctetRollovers"), ("DOT12-RPTR-MIB", "vgRptrPortBroadcastFrames"), ("DOT12-RPTR-MIB", "vgRptrPortMulticastFrames"), ("DOT12-RPTR-MIB", "vgRptrPortNullAddressedFrames"), ("DOT12-RPTR-MIB", "vgRptrPortIPMFrames"), ("DOT12-RPTR-MIB", "vgRptrPortOversizeFrames"), ("DOT12-RPTR-MIB", "vgRptrPortDataErrorFrames"), ("DOT12-RPTR-MIB", "vgRptrPortPriorityPromotions"), ("DOT12-RPTR-MIB", "vgRptrPortTransitionToTrainings"), ("DOT12-RPTR-MIB", "vgRptrPortLastChange"),))
if mibBuilder.loadTexts: vgRptrStatsGroup.setDescription('A collection of objects for providing statistics\n                      for IEEE 802.12 repeaters.  Systems which support\n                      Counter64 should also implement\n                      vgRptrStats64Group.')
vgRptrStats64Group = ObjectGroup((1, 3, 6, 1, 2, 1, 53, 3, 2, 3)).setObjects(*(("DOT12-RPTR-MIB", "vgRptrMonHCTotalReadableOctets"), ("DOT12-RPTR-MIB", "vgRptrPortHCReadableOctets"), ("DOT12-RPTR-MIB", "vgRptrPortHCUnreadableOctets"), ("DOT12-RPTR-MIB", "vgRptrPortHCHighPriorityOctets"), ("DOT12-RPTR-MIB", "vgRptrPortHCNormPriorityOctets"),))
if mibBuilder.loadTexts: vgRptrStats64Group.setDescription('A collection of objects for providing statistics\n                      for IEEE 802.12 repeaters in a system that\n                      supports Counter64.')
vgRptrAddrGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 53, 3, 2, 4)).setObjects(*(("DOT12-RPTR-MIB", "vgRptrAddrLastTrainedAddress"), ("DOT12-RPTR-MIB", "vgRptrAddrTrainedAddrChanges"), ("DOT12-RPTR-MIB", "vgRptrRptrDetectedDupAddress"), ("DOT12-RPTR-MIB", "vgRptrMgrDetectedDupAddress"),))
if mibBuilder.loadTexts: vgRptrAddrGroup.setDescription('A collection of objects for tracking addresses\n                      on IEEE 802.12 repeaters.')
vgRptrNotificationsGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 53, 3, 2, 5)).setObjects(*(("DOT12-RPTR-MIB", "vgRptrHealth"), ("DOT12-RPTR-MIB", "vgRptrResetEvent"),))
if mibBuilder.loadTexts: vgRptrNotificationsGroup.setDescription('A collection of notifications used to indicate\n                      802.12 repeater general status changes.')
mibBuilder.exportSymbols("DOT12-RPTR-MIB", vgRptrPortAllowedTrainType=vgRptrPortAllowedTrainType, vgRptrPortHighPriorityFrames=vgRptrPortHighPriorityFrames, vgRptrMIB=vgRptrMIB, vgRptrStats64Group=vgRptrStats64Group, vgRptrAddrLastTrainedAddress=vgRptrAddrLastTrainedAddress, vgRptrTrapPrefix=vgRptrTrapPrefix, vgRptrStatsGroup=vgRptrStatsGroup, vgRptrPortNormPriorityOctets=vgRptrPortNormPriorityOctets, vgRptrMonTotalErrors=vgRptrMonTotalErrors, vgRptrAddrTrackTable=vgRptrAddrTrackTable, vgRptrGroups=vgRptrGroups, vgRptrPortAdminStatus=vgRptrPortAdminStatus, vgRptrPortHCUnreadableOctets=vgRptrPortHCUnreadableOctets, vgRptrResetEvent=vgRptrResetEvent, vgRptrGroupIndex=vgRptrGroupIndex, vgRptrAddrTrackPort=vgRptrAddrTrackPort, vgRptrPortMulticastFrames=vgRptrPortMulticastFrames, vgRptrPortHCReadableOctets=vgRptrPortHCReadableOctets, vgRptrMgrDetectedDupAddress=vgRptrMgrDetectedDupAddress, vgRptrBasicPortTable=vgRptrBasicPortTable, vgRptrMonTotalReadableFrames=vgRptrMonTotalReadableFrames, vgRptrPortReadableFrames=vgRptrPortReadableFrames, vgRptrGroupCablesBundled=vgRptrGroupCablesBundled, vgRptrPortLastChange=vgRptrPortLastChange, vgRptrRptrDetectedDupAddress=vgRptrRptrDetectedDupAddress, vgRptrBasicPort=vgRptrBasicPort, vgRptrPortUnreadOctetRollovers=vgRptrPortUnreadOctetRollovers, PYSNMP_MODULE_ID=vgRptrMIB, vgRptrBasicRptr=vgRptrBasicRptr, vgRptrMonitorEntry=vgRptrMonitorEntry, vgRptrPortBroadcastFrames=vgRptrPortBroadcastFrames, vgRptrPortUnreadableOctets=vgRptrPortUnreadableOctets, vgRptrAddrTrackEntry=vgRptrAddrTrackEntry, vgRptrConformance=vgRptrConformance, vgRptrPortHighPriOctetRollovers=vgRptrPortHighPriOctetRollovers, vgRptrPortRptrInfoIndex=vgRptrPortRptrInfoIndex, vgRptrCompliances=vgRptrCompliances, vgRptrPortTransitionToTrainings=vgRptrPortTransitionToTrainings, vgRptrBasicGroupTable=vgRptrBasicGroupTable, vgRptrPortOperStatus=vgRptrPortOperStatus, vgRptrInfoOperStatus=vgRptrInfoOperStatus, vgRptrMonPortTable=vgRptrMonPortTable, vgRptrPortPriorityPromotions=vgRptrPortPriorityPromotions, vgRptrGroupPortCapacity=vgRptrGroupPortCapacity, vgRptrBasic=vgRptrBasic, vgRptrInfoFramingCapability=vgRptrInfoFramingCapability, vgRptrMonitorTable=vgRptrMonitorTable, vgRptrPortPriorityEnable=vgRptrPortPriorityEnable, vgRptrBasicPortEntry=vgRptrBasicPortEntry, vgRptrPortNullAddressedFrames=vgRptrPortNullAddressedFrames, vgRptrCompliance=vgRptrCompliance, vgRptrInfoLastChange=vgRptrInfoLastChange, vgRptrAddrTrainedAddrChanges=vgRptrAddrTrainedAddrChanges, vgRptrPortTrainingResult=vgRptrPortTrainingResult, vgRptrBasicGroup=vgRptrBasicGroup, vgRptrPortIndex=vgRptrPortIndex, vgRptrPortType=vgRptrPortType, vgRptrPortNormPriOctetRollovers=vgRptrPortNormPriOctetRollovers, vgRptrInfoMACAddress=vgRptrInfoMACAddress, vgRptrPortDataErrorFrames=vgRptrPortDataErrorFrames, vgRptrInfoEntry=vgRptrInfoEntry, vgRptrAddrTrack=vgRptrAddrTrack, vgRptrPortReadOctetRollovers=vgRptrPortReadOctetRollovers, vgRptrGroupObjectID=vgRptrGroupObjectID, vgRptrMonTotalReadableOctets=vgRptrMonTotalReadableOctets, vgRptrInfoReset=vgRptrInfoReset, vgRptrMonPortEntry=vgRptrMonPortEntry, vgRptrAddrGroup=vgRptrAddrGroup, vgRptrHealth=vgRptrHealth, vgRptrPortOversizeFrames=vgRptrPortOversizeFrames, vgRptrMonReadableOctetRollovers=vgRptrMonReadableOctetRollovers, vgRptrPortReadableOctets=vgRptrPortReadableOctets, vgRptrBasicGroupEntry=vgRptrBasicGroupEntry, vgRptrPortHighPriorityOctets=vgRptrPortHighPriorityOctets, vgRptrInfoTrainingVersion=vgRptrInfoTrainingVersion, vgRptrPortHCNormPriorityOctets=vgRptrPortHCNormPriorityOctets, vgRptrInfoIndex=vgRptrInfoIndex, vgRptrPortIPMFrames=vgRptrPortIPMFrames, vgRptrAddrTrackGroup=vgRptrAddrTrackGroup, vgRptrConfigGroup=vgRptrConfigGroup, vgRptrInfoDesiredFramingType=vgRptrInfoDesiredFramingType, vgRptrMonRepeater=vgRptrMonRepeater, vgRptrMonPort=vgRptrMonPort, vgRptrObjects=vgRptrObjects, vgRptrPortSupportedPromiscMode=vgRptrPortSupportedPromiscMode, vgRptrPortSupportedCascadeMode=vgRptrPortSupportedCascadeMode, vgRptrAddrTrackRptr=vgRptrAddrTrackRptr, vgRptrNotificationsGroup=vgRptrNotificationsGroup, vgRptrMonGroup=vgRptrMonGroup, vgRptrGroupOperStatus=vgRptrGroupOperStatus, vgRptrPortLastTrainConfig=vgRptrPortLastTrainConfig, vgRptrMonHCTotalReadableOctets=vgRptrMonHCTotalReadableOctets, vgRptrMonitor=vgRptrMonitor, vgRptrInfoTable=vgRptrInfoTable, vgRptrInfoCurrentFramingType=vgRptrInfoCurrentFramingType, vgRptrTraps=vgRptrTraps, vgRptrPortHCHighPriorityOctets=vgRptrPortHCHighPriorityOctets, vgRptrPortNormPriorityFrames=vgRptrPortNormPriorityFrames)
