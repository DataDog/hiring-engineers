#
# PySNMP MIB module DISMAN-SCRIPT-MIB (http://pysnmp.sf.net)
# ASN.1 source http://mibs.snmplabs.com:80/asn1/DISMAN-SCRIPT-MIB
# Produced by pysmi-0.0.7 at Sun Feb 14 00:08:15 2016
# On host bldfarm platform Linux version 4.1.13-100.fc21.x86_64 by user goose
# Using Python version 3.5.0 (default, Jan  5 2016, 17:11:52) 
#
( OctetString, Integer, ObjectIdentifier, ) = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint")
( SnmpAdminString, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
( NotificationGroup, ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
( MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, MibIdentifier, ModuleIdentity, Integer32, Counter64, Unsigned32, ObjectIdentity, IpAddress, mib_2, Gauge32, TimeTicks, Bits, iso, NotificationType, ) = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "MibIdentifier", "ModuleIdentity", "Integer32", "Counter64", "Unsigned32", "ObjectIdentity", "IpAddress", "mib-2", "Gauge32", "TimeTicks", "Bits", "iso", "NotificationType")
( TimeInterval, StorageType, TextualConvention, DisplayString, RowStatus, DateAndTime, ) = mibBuilder.importSymbols("SNMPv2-TC", "TimeInterval", "StorageType", "TextualConvention", "DisplayString", "RowStatus", "DateAndTime")
scriptMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 64)).setRevisions(("2001-08-21 00:00", "1999-02-22 18:00",))
if mibBuilder.loadTexts: scriptMIB.setLastUpdated('200108210000Z')
if mibBuilder.loadTexts: scriptMIB.setOrganization('IETF Distributed Management Working Group')
if mibBuilder.loadTexts: scriptMIB.setContactInfo('WG EMail:  disman@dorothy.bmc.com\n         Subscribe: disman-request@dorothy.bmc.com\n\n         Chair:     Randy Presuhn\n                    BMC Software, Inc.\n\n         Postal:    Office 1-3141\n                    2141 North First Street\n                    San Jose,  California 95131\n                    USA\n         EMail:     rpresuhn@bmc.com\n         Phone:     +1 408 546-1006\n\n         Editor:    David B. Levi\n                    Nortel Networks\n         Postal:    4401 Great America Parkway\n                    Santa Clara, CA 95052-8185\n                    USA\n         EMail:     dlevi@nortelnetworks.com\n         Phone:     +1 423 686 0432\n\n         Editor:    Juergen Schoenwaelder\n                    TU Braunschweig\n         Postal:    Bueltenweg 74/75\n                    38106 Braunschweig\n                    Germany\n         EMail:     schoenw@ibr.cs.tu-bs.de\n         Phone:     +49 531 391-3283')
if mibBuilder.loadTexts: scriptMIB.setDescription('This MIB module defines a set of objects that allow to\n         delegate management scripts to distributed managers.')
smObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 64, 1))
smNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 64, 2))
smConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 64, 3))
smLangTable = MibTable((1, 3, 6, 1, 2, 1, 64, 1, 1), )
if mibBuilder.loadTexts: smLangTable.setDescription('This table lists supported script languages.')
smLangEntry = MibTableRow((1, 3, 6, 1, 2, 1, 64, 1, 1, 1), ).setIndexNames((0, "DISMAN-SCRIPT-MIB", "smLangIndex"))
if mibBuilder.loadTexts: smLangEntry.setDescription('An entry describing a particular language.')
smLangIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647)))
if mibBuilder.loadTexts: smLangIndex.setDescription("The locally arbitrary, but unique identifier associated\n         with this language entry.\n\n         The value is expected to remain constant at least from one\n         re-initialization of the entity's network management system\n         to the next re-initialization.\n\n         Note that the data type and the range of this object must\n         be consistent with the definition of smScriptLanguage.")
smLangLanguage = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smLangLanguage.setDescription('The globally unique identification of the language.')
smLangVersion = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 1, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0,32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smLangVersion.setDescription('The version number of the language. The zero-length string\n         shall be used if the language does not have a version\n         number.\n\n         It is suggested that the version number consist of one or\n         more decimal numbers separated by dots, where the first\n         number is called the major version number.')
smLangVendor = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 1, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smLangVendor.setDescription('An object identifier which identifies the vendor who\n         provides the implementation of the language. This object\n         identifier SHALL point to the object identifier directly\n         below the enterprise object identifier {1 3 6 1 4 1}\n         allocated for the vendor. The value must be the object\n         identifier {0 0} if the vendor is not known.')
smLangRevision = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 1, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0,32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smLangRevision.setDescription('The version number of the language implementation.\n         The value of this object must be an empty string if\n         version number of the implementation is unknown.\n\n         It is suggested that the value consist of one or more\n         decimal numbers separated by dots, where the first\n         number is called the major version number.')
smLangDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 1, 1, 6), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smLangDescr.setDescription('A textual description of the language.')
smExtsnTable = MibTable((1, 3, 6, 1, 2, 1, 64, 1, 2), )
if mibBuilder.loadTexts: smExtsnTable.setDescription('This table lists supported language extensions.')
smExtsnEntry = MibTableRow((1, 3, 6, 1, 2, 1, 64, 1, 2, 1), ).setIndexNames((0, "DISMAN-SCRIPT-MIB", "smLangIndex"), (0, "DISMAN-SCRIPT-MIB", "smExtsnIndex"))
if mibBuilder.loadTexts: smExtsnEntry.setDescription('An entry describing a particular language extension.')
smExtsnIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647)))
if mibBuilder.loadTexts: smExtsnIndex.setDescription("The locally arbitrary, but unique identifier associated\n         with this language extension entry.\n\n         The value is expected to remain constant at least from one\n         re-initialization of the entity's network management system\n         to the next re-initialization.")
smExtsnExtension = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smExtsnExtension.setDescription('The globally unique identification of the language\n         extension.')
smExtsnVersion = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 2, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0,32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smExtsnVersion.setDescription('The version number of the language extension.\n         It is suggested that the version number consist of one or\n         more decimal numbers separated by dots, where the first\n         number is called the major version number.')
smExtsnVendor = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 2, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smExtsnVendor.setDescription('An object identifier which identifies the vendor who\n         provides the implementation of the extension. The\n         object identifier value should point to the OID node\n         directly below the enterprise OID {1 3 6 1 4 1}\n         allocated for the vendor. The value must by the object\n         identifier {0 0} if the vendor is not known.')
smExtsnRevision = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 2, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0,32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smExtsnRevision.setDescription('The version number of the extension implementation.\n         The value of this object must be an empty string if\n         version number of the implementation is unknown.\n\n         It is suggested that the value consist of one or more\n         decimal numbers separated by dots, where the first\n         number is called the major version number.')
smExtsnDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 2, 1, 6), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smExtsnDescr.setDescription('A textual description of the language extension.')
smScriptObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 64, 1, 3))
smScriptTable = MibTable((1, 3, 6, 1, 2, 1, 64, 1, 3, 1), )
if mibBuilder.loadTexts: smScriptTable.setDescription('This table lists and describes locally known scripts.')
smScriptEntry = MibTableRow((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1), ).setIndexNames((0, "DISMAN-SCRIPT-MIB", "smScriptOwner"), (0, "DISMAN-SCRIPT-MIB", "smScriptName"))
if mibBuilder.loadTexts: smScriptEntry.setDescription('An entry describing a particular script. Every script that\n         is stored in non-volatile memory is required to appear in\n         this script table.')
smScriptOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0,32)))
if mibBuilder.loadTexts: smScriptOwner.setDescription('The manager who owns this row in the smScriptTable.')
smScriptName = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1,32)))
if mibBuilder.loadTexts: smScriptName.setDescription('The locally-unique, administratively assigned name for this\n         script. This object allows an smScriptOwner to have multiple\n         entries in the smScriptTable.\n\n         This value of this object may be used to derive the name\n         (e.g. a file name) which is used by the Script MIB\n         implementation to access the script in non-volatile\n         storage. The details of this mapping are implementation\n         specific. However, the mapping needs to ensure that scripts\n         created by different owners with the same script name do not\n         map to the same name in non-volatile storage.')
smScriptDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1, 3), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smScriptDescr.setDescription('A description of the purpose of the script.')
smScriptLanguage = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smScriptLanguage.setDescription("The value of this object type identifies an entry in the\n         smLangTable which is used to execute this script.\n         The special value 0 may be used by hard-wired scripts\n         that can not be modified and that are executed by\n         internal functions.\n\n         Set requests to change this object are invalid if the\n         value of smScriptOperStatus is `enabled' or `compiling'\n         and will result in an inconsistentValue error.\n\n         Note that the data type and the range of this object must\n         be consistent with the definition of smLangIndex.")
smScriptSource = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1, 5), DisplayString().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smScriptSource.setDescription("This object either contains a reference to the script\n         source or an empty string. A reference must be given\n         in the form of a Uniform Resource Locator (URL) as\n         defined in RFC 2396. The allowed character sets and the\n         encoding rules defined in RFC 2396 section 2 apply.\n\n         When the smScriptAdminStatus object is set to `enabled',\n         the Script MIB implementation will `pull' the script\n         source from the URL contained in this object if the URL\n         is not empty.\n\n         An empty URL indicates that the script source is loaded\n         from local storage. The script is read from the smCodeTable\n         if the value of smScriptStorageType is volatile. Otherwise,\n         the script is read from non-volatile storage.\n\n         Note: This document does not mandate implementation of any\n         specific URL scheme. An attempt to load a script from a\n         nonsupported URL scheme will cause the smScriptOperStatus\n         to report an `unknownProtocol' error.\n\n\n         Set requests to change this object are invalid if the\n         value of smScriptOperStatus is `enabled', `editing',\n         `retrieving' or `compiling' and will result in an\n         inconsistentValue error.")
smScriptAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("editing", 3),)).clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smScriptAdminStatus.setDescription("The value of this object indicates the desired status of\n         the script. See the definition of smScriptOperStatus for\n         a description of the values.\n\n         When the smScriptAdminStatus object is set to `enabled' and\n         the smScriptOperStatus is `disabled' or one of the error\n         states, the Script MIB implementation will `pull' the script\n         source from the URL contained in the smScriptSource object\n         if the URL is not empty.")
smScriptOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("editing", 3), ("retrieving", 4), ("compiling", 5), ("noSuchScript", 6), ("accessDenied", 7), ("wrongLanguage", 8), ("wrongVersion", 9), ("compilationFailed", 10), ("noResourcesLeft", 11), ("unknownProtocol", 12), ("protocolFailure", 13), ("genericError", 14),)).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: smScriptOperStatus.setDescription("The actual status of the script in the runtime system. The\n         value of this object is only meaningful when the value of\n         the smScriptRowStatus object is `active'.\n\n         The smScriptOperStatus object may have the following values:\n\n         - `enabled' indicates that the script is available and can\n            be started by a launch table entry.\n\n         - `disabled' indicates that the script can not be used.\n\n         - `editing' indicates that the script can be modified in the\n           smCodeTable.\n\n         - `retrieving' indicates that the script is currently being\n           loaded from non-volatile storage or a remote system.\n\n         - `compiling' indicates that the script is currently being\n           compiled by the runtime system.\n\n         - `noSuchScript' indicates that the script does not exist\n           at the smScriptSource.\n\n         - `accessDenied' indicates that the script can not be loaded\n           from the smScriptSource due to a lack of permissions.\n\n         - `wrongLanguage' indicates that the script can not be\n            loaded from the smScriptSource because of a language\n            mismatch.\n\n         - `wrongVersion' indicates that the script can not be loaded\n           from the smScriptSource because of a language version\n           mismatch.\n\n         - `compilationFailed' indicates that the compilation failed.\n\n         - `noResourcesLeft' indicates that the runtime system does\n           not have enough resources to load the script.\n\n         - `unknownProtocol' indicates that the script could not be\n           loaded from the smScriptSource because the requested\n           protocol is not supported.\n\n         - `protocolFailure' indicates that the script could not be\n           loaded from the smScriptSource because of a protocol\n           failure.\n\n         - `genericError' indicates that the script could not be\n\n           loaded due to an error condition not listed above.\n\n         The `retrieving' and `compiling' states are transient states\n         which will either lead to one of the error states or the\n         `enabled' state. The `disabled' and `editing' states are\n         administrative states which are only reached by explicit\n         management operations.\n\n         All launch table entries that refer to this script table\n         entry shall have an smLaunchOperStatus value of `disabled'\n         when the value of this object is not `enabled'.")
smScriptStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1, 8), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smScriptStorageType.setDescription("This object defines whether this row and the script\n         controlled by this row are kept in volatile storage and\n         lost upon reboot or if this row is backed up by\n         non-volatile or permanent storage.\n\n         The storage type of this row always complies with the value\n         of this entry if the value of the corresponding RowStatus\n         object is `active'.\n\n         However, the storage type of the script controlled by this\n         row may be different, if the value of this entry is\n         `non-volatile'. The script controlled by this row is written\n         into local non-volatile storage if the following condition\n         becomes true:\n\n         (a) the URL contained in the smScriptSource object is empty\n             and\n         (b) the smScriptStorageType is `nonVolatile'\n             and\n         (c) the smScriptOperStatus is `enabled'\n\n         Setting this object to `volatile' removes a script from\n         non-volatile storage if the script controlled by this row\n         has been in non-volatile storage before. Attempts to set\n         this object to permanent will always fail with an\n         inconsistentValue error.\n\n         The value of smScriptStorageType is only meaningful if the\n         value of the corresponding RowStatus object is `active'.\n\n         If smScriptStorageType has the value permanent(4), then all\n         objects whose MAX-ACCESS value is read-create must be\n         writable, with the exception of the smScriptStorageType and\n         smScriptRowStatus objects, which shall be read-only.")
smScriptRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smScriptRowStatus.setDescription("A control that allows entries to be added and removed from\n         this table.\n\n         Changing the smScriptRowStatus from `active' to\n         `notInService' will remove the associated script from the\n         runtime system.\n\n         Deleting conceptual rows from this table may affect the\n         deletion of other resources associated with this row. For\n         example, a script stored in non-volatile storage may be\n         removed from non-volatile storage.\n\n         An entry may not exist in the `active' state unless all\n         required objects in the entry have appropriate values. Rows\n         that are not complete or not in service are not known by the\n         script runtime system.\n\n         Attempts to `destroy' a row or to set a row `notInService'\n         while the smScriptOperStatus is `enabled' will result in an\n         inconsistentValue error.\n\n         Attempts to `destroy' a row or to set a row `notInService'\n         where the value of the smScriptStorageType object is\n         `permanent' or `readOnly' will result in an\n         inconsistentValue error.\n\n         The value of this object has no effect on whether other\n         objects in this conceptual row can be modified.")
smScriptError = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1, 10), SnmpAdminString().clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: smScriptError.setDescription("This object contains a descriptive error message if the\n\n         transition into the operational status `enabled' failed.\n         Implementations must reset the error message to a\n         zero-length string when a new attempt to change the\n         script status to `enabled' is started.")
smScriptLastChange = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1, 11), DateAndTime().clone(hexValue="0000000000000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: smScriptLastChange.setDescription("The date and time when this script table entry was last\n         modified. The value '0000000000000000'H is returned if\n         the script table entry has not yet been modified.\n\n         Note that the resetting of smScriptError is not considered\n         a change of the script table entry.")
smCodeTable = MibTable((1, 3, 6, 1, 2, 1, 64, 1, 3, 2), )
if mibBuilder.loadTexts: smCodeTable.setDescription('This table contains the script code for scripts that are\n         written via SNMP write operations.')
smCodeEntry = MibTableRow((1, 3, 6, 1, 2, 1, 64, 1, 3, 2, 1), ).setIndexNames((0, "DISMAN-SCRIPT-MIB", "smScriptOwner"), (0, "DISMAN-SCRIPT-MIB", "smScriptName"), (0, "DISMAN-SCRIPT-MIB", "smCodeIndex"))
if mibBuilder.loadTexts: smCodeEntry.setDescription('An entry describing a particular fragment of a script.')
smCodeIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1,4294967295)))
if mibBuilder.loadTexts: smCodeIndex.setDescription('The index value identifying this code fragment.')
smCodeText = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1,1024))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smCodeText.setDescription('The code that makes up a fragment of a script. The format\n         of this code fragment depends on the script language which\n         is identified by the associated smScriptLanguage object.')
smCodeRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 2, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smCodeRowStatus.setDescription('A control that allows entries to be added and removed from\n         this table.\n\n         The value of this object has no effect on whether other\n         objects in this conceptual row can be modified.')
smRunObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 64, 1, 4))
smLaunchTable = MibTable((1, 3, 6, 1, 2, 1, 64, 1, 4, 1), )
if mibBuilder.loadTexts: smLaunchTable.setDescription('This table lists and describes scripts that are ready\n         to be executed together with their parameters.')
smLaunchEntry = MibTableRow((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1), ).setIndexNames((0, "DISMAN-SCRIPT-MIB", "smLaunchOwner"), (0, "DISMAN-SCRIPT-MIB", "smLaunchName"))
if mibBuilder.loadTexts: smLaunchEntry.setDescription('An entry describing a particular executable script.')
smLaunchOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0,32)))
if mibBuilder.loadTexts: smLaunchOwner.setDescription('The manager who owns this row in the smLaunchTable. Every\n         instance of a running script started from a particular entry\n         in the smLaunchTable (i.e. entries in the smRunTable) will\n         be owned by the same smLaunchOwner used to index the entry\n         in the smLaunchTable. This owner is not necessarily the same\n         as the owner of the script itself (smLaunchScriptOwner).')
smLaunchName = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1,32)))
if mibBuilder.loadTexts: smLaunchName.setDescription('The locally-unique, administratively assigned name for this\n         launch table entry. This object allows an smLaunchOwner to\n         have multiple entries in the smLaunchTable. The smLaunchName\n         is an arbitrary name that must be different from any other\n         smLaunchTable entries with the same smLaunchOwner but can be\n         the same as other entries in the smLaunchTable with\n         different smLaunchOwner values. Note that the value of\n         smLaunchName is not related in any way to the name of the\n         script being launched.')
smLaunchScriptOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0,32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchScriptOwner.setDescription("The value of this object in combination with the value of\n         smLaunchScriptName identifies the script that can be\n         launched from this smLaunchTable entry. Attempts to write\n         this object will fail with an inconsistentValue error if\n         the value of smLaunchOperStatus is `enabled'.")
smLaunchScriptName = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0,32)).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchScriptName.setDescription("The value of this object in combination with the value of\n         the smLaunchScriptOwner identifies the script that can be\n         launched from this smLaunchTable entry. The zero-length\n         string may be used to point to a non-existing script.\n\n         Attempts to write this object will fail with an\n         inconsistentValue error if the value of smLaunchOperStatus\n         is `enabled'.")
smLaunchArgument = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 5), OctetString().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchArgument.setDescription('The argument supplied to the script. When a script is\n         invoked, the value of this object is used to initialize\n         the smRunArgument object.')
smLaunchMaxRunning = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1,4294967295)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchMaxRunning.setDescription('The maximum number of concurrently running scripts that may\n         be invoked from this entry in the smLaunchTable. Lowering\n         the current value of this object does not affect any scripts\n         that are already executing.')
smLaunchMaxCompleted = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1,4294967295)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchMaxCompleted.setDescription('The maximum number of finished scripts invoked from this\n         entry in the smLaunchTable allowed to be retained in the\n         smRunTable. Whenever the value of this object is changed\n         and whenever a script terminates, entries in the smRunTable\n         are deleted if necessary until the number of completed\n         scripts is smaller than the value of this object. Scripts\n         whose smRunEndTime value indicates the oldest completion\n         time are deleted first.')
smLaunchLifeTime = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 8), TimeInterval().clone(360000)).setUnits('centi-seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchLifeTime.setDescription('The default maximum amount of time a script launched\n         from this entry may run. The value of this object is used\n         to initialize the smRunLifeTime object when a script is\n         launched. Changing the value of an smLaunchLifeTime\n         instance does not affect scripts previously launched from\n\n         this entry.')
smLaunchExpireTime = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 9), TimeInterval().clone(360000)).setUnits('centi-seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchExpireTime.setDescription('The default maximum amount of time information about a\n         script launched from this entry is kept in the smRunTable\n         after the script has completed execution.  The value of\n         this object is used to initialize the smRunExpireTime\n         object when a script is launched. Changing the value of an\n         smLaunchExpireTime instance does not affect scripts\n         previously launched from this entry.')
smLaunchStart = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchStart.setDescription("This object is used to start the execution of scripts.\n         When retrieved, the value will be the value of smRunIndex\n         for the last script that started execution by manipulating\n         this object. The value will be zero if no script started\n         execution yet.\n\n         A script is started by setting this object to an unused\n         smRunIndex value. A new row in the smRunTable will be\n         created which is indexed by the value supplied by the\n         set-request in addition to the value of smLaunchOwner and\n         smLaunchName. An unused value can be obtained by reading\n         the smLaunchRunIndexNext object.\n\n         Setting this object to the special value 0 will start\n         the script with a self-generated smRunIndex value. The\n         consequence is that the script invoker has no reliable\n         way to determine the smRunIndex value for this script\n         invocation and that the invoker has therefore no way\n         to obtain the results from this script invocation. The\n         special value 0 is however useful for scheduled script\n         invocations.\n\n         If this object is set, the following checks must be\n\n         performed:\n\n         1) The value of the smLaunchOperStatus object in this\n            entry of the smLaunchTable must be `enabled'.\n         2) The values of smLaunchScriptOwner and\n            smLaunchScriptName of this row must identify an\n            existing entry in the smScriptTable.\n         3) The value of smScriptOperStatus of this entry must\n            be `enabled'.\n         4) The principal performing the set operation must have\n            read access to the script. This must be checked by\n            calling the isAccessAllowed abstract service interface\n            defined in RFC 2271 on the row in the smScriptTable\n            identified by smLaunchScriptOwner and smLaunchScriptName.\n            The isAccessAllowed abstract service interface must be\n            called on all columnar objects in the smScriptTable with\n            a MAX-ACCESS value different than `not-accessible'. The\n            test fails as soon as a call indicates that access is\n            not allowed.\n         5) If the value provided by the set operation is not 0,\n            a check must be made that the value is currently not\n            in use. Otherwise, if the value provided by the set\n            operation is 0, a suitable unused value must be\n            generated.\n         6) The number of currently executing scripts invoked\n            from this smLaunchTable entry must be less than\n            smLaunchMaxRunning.\n\n         Attempts to start a script will fail with an\n         inconsistentValue error if one of the checks described\n         above fails.\n\n         Otherwise, if all checks have been passed, a new entry\n         in the smRunTable will be created indexed by smLaunchOwner,\n         smLaunchName and the new value for smRunIndex. The value\n         of smLaunchArgument will be copied into smRunArgument,\n         the value of smLaunchLifeTime will be copied to\n         smRunLifeTime, and the value of smLaunchExpireTime\n         will be copied to smRunExpireTime.\n\n         The smRunStartTime will be set to the current time and\n         the smRunState will be set to `initializing' before the\n         script execution is initiated in the appropriate runtime\n         system.\n\n         Note that the data type and the range of this object must\n         be consistent with the smRunIndex object. Since this\n         object might be written from the scheduling MIB, the\n\n         data type Integer32 rather than Unsigned32 is used.")
smLaunchControl = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4,))).clone(namedValues=NamedValues(("abort", 1), ("suspend", 2), ("resume", 3), ("nop", 4),)).clone('nop')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchControl.setDescription("This object is used to request a state change for all\n         running scripts in the smRunTable that were started from\n         this row in the smLaunchTable.\n\n         Setting this object to abort(1), suspend(2) or resume(3)\n         will set the smRunControl object of all applicable rows\n         in the smRunTable to abort(1), suspend(2) or resume(3)\n         respectively. The phrase `applicable rows' means the set of\n         rows which were created from this entry in the smLaunchTable\n         and whose value of smRunState allows the corresponding\n         state change as described in the definition of the\n         smRunControl object. Setting this object to nop(4) has no\n         effect.\n\n         Attempts to set this object lead to an inconsistentValue\n         error only if all implicated sets on all the applicable\n         rows lead to inconsistentValue errors. It is not allowed\n         to return an inconsistentValue error if at least one state\n         change on one of the applicable rows was successful.")
smLaunchAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("autostart", 3),)).clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchAdminStatus.setDescription("The value of this object indicates the desired status of\n         this launch table entry. The values enabled(1) and\n         autostart(3) both indicate that the launch table entry\n\n         should transition into the operational enabled(1) state as\n         soon as the associated script table entry is enabled(1).\n\n         The value autostart(3) further indicates that the script\n         is started automatically by conceptually writing the\n         value 0 into the associated smLaunchStart object during\n         the transition from the `disabled' into the `enabled'\n         operational state. This is useful for scripts that are\n         to be launched on system start-up.")
smLaunchOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("expired", 3),)).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: smLaunchOperStatus.setDescription("The value of this object indicates the actual status of\n         this launch table entry.  The smLaunchOperStatus object\n         may have the following values:\n\n         - `enabled' indicates that the launch table entry is\n           available and can be used to start scripts.\n\n         - `disabled' indicates that the launch table entry can\n           not be used to start scripts.\n\n         - `expired' indicates that the launch table entry can\n           not be used to start scripts and will disappear as\n           soon as all smRunTable entries associated with this\n           launch table entry have disappeared.\n\n         The value `enabled' requires that the smLaunchRowStatus\n         object is active. The value `disabled' requires that there\n         are no entries in the smRunTable associated with this\n         smLaunchTable entry.")
smLaunchRunIndexNext = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smLaunchRunIndexNext.setDescription('This variable is used for creating rows in the smRunTable.\n         The value of this variable is a currently unused value\n         for smRunIndex, which can be written into the smLaunchStart\n         object associated with this row to launch a script.\n\n         The value returned when reading this variable must be unique\n         for the smLaunchOwner and smLaunchName associated with this\n         row. Subsequent attempts to read this variable must return\n         different values.\n\n         This variable will return the special value 0 if no new rows\n         can be created.\n\n         Note that the data type and the range of this object must be\n         consistent with the definition of smRunIndex.')
smLaunchStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 15), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchStorageType.setDescription('This object defines if this row is kept in volatile storage\n         and lost upon reboot or if this row is backed up by stable\n         storage.\n\n         The value of smLaunchStorageType is only meaningful if the\n         value of the corresponding RowStatus object is active.\n\n         If smLaunchStorageType has the value permanent(4), then all\n         objects whose MAX-ACCESS value is read-create must be\n         writable, with the exception of the smLaunchStorageType and\n         smLaunchRowStatus objects, which shall be read-only.')
smLaunchRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 16), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchRowStatus.setDescription("A control that allows entries to be added and removed from\n         this table.\n\n         Attempts to `destroy' a row or to set a row `notInService'\n         while the smLaunchOperStatus is `enabled' will result in\n         an inconsistentValue error.\n\n\n         Attempts to `destroy' a row or to set a row `notInService'\n         where the value of the smLaunchStorageType object is\n         `permanent' or `readOnly' will result in an\n         inconsistentValue error.\n\n         The value of this object has no effect on whether other\n         objects in this conceptual row can be modified.")
smLaunchError = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 17), SnmpAdminString().clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: smLaunchError.setDescription('This object contains a descriptive error message if an\n         attempt to launch a script fails. Implementations must reset\n         the error message to a zero-length string when a new attempt\n         to launch a script is started.')
smLaunchLastChange = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 18), DateAndTime().clone(hexValue="0000000000000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: smLaunchLastChange.setDescription("The date and time when this launch table entry was last\n         modified. The value '0000000000000000'H is returned if\n         the launch table entry has not yet been modified.\n\n         Note that a change of smLaunchStart, smLaunchControl,\n         smLaunchRunIndexNext, smLaunchRowExpireTime, or the\n         resetting of smLaunchError is not considered a change\n         of this launch table entry.")
smLaunchRowExpireTime = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 19), TimeInterval().clone(2147483647)).setUnits('centi-seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchRowExpireTime.setDescription("The value of this object specifies how long this row remains\n         in the `enabled' or `disabled' operational state. The value\n         reported by this object ticks backwards. When the value\n         reaches 0, it stops ticking backward and the row is\n         deleted if there are no smRunTable entries associated with\n\n         this smLaunchTable entry. Otherwise, the smLaunchOperStatus\n         changes to `expired' and the row deletion is deferred\n         until there are no smRunTable entries associated with this\n         smLaunchTable entry.\n\n         The smLaunchRowExpireTime will not tick backwards if it is\n         set to its maximum value (2147483647). In other words,\n         setting this object to its maximum value turns the timer\n         off.\n\n         The value of this object may be set in order to increase\n         or reduce the remaining time that the launch table entry\n         may be used. Setting the value to 0 will cause an immediate\n         row deletion or transition into the `expired' operational\n         state.\n\n         It is not possible to set this object while the operational\n         status is `expired'. Attempts to modify this object while\n         the operational status is `expired' leads to an\n         inconsistentValue error.\n\n         Note that the timer ticks backwards independent of the\n         operational state of the launch table entry.")
smRunTable = MibTable((1, 3, 6, 1, 2, 1, 64, 1, 4, 2), )
if mibBuilder.loadTexts: smRunTable.setDescription('This table lists and describes scripts that are currently\n         running or have been running in the past.')
smRunEntry = MibTableRow((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1), ).setIndexNames((0, "DISMAN-SCRIPT-MIB", "smLaunchOwner"), (0, "DISMAN-SCRIPT-MIB", "smLaunchName"), (0, "DISMAN-SCRIPT-MIB", "smRunIndex"))
if mibBuilder.loadTexts: smRunEntry.setDescription('An entry describing a particular running or finished\n         script.')
smRunIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647)))
if mibBuilder.loadTexts: smRunIndex.setDescription('The locally arbitrary, but unique identifier associated\n         with this running or finished script. This value must be\n         unique for all rows in the smRunTable with the same\n         smLaunchOwner and smLaunchName.\n\n         Note that the data type and the range of this object must\n         be consistent with the definition of smLaunchRunIndexNext\n         and smLaunchStart.')
smRunArgument = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 2), OctetString().clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: smRunArgument.setDescription('The argument supplied to the script when it started.')
smRunStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 3), DateAndTime().clone(hexValue="0000000000000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: smRunStartTime.setDescription("The date and time when the execution started. The value\n         '0000000000000000'H is returned if the script has not\n         started yet.")
smRunEndTime = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 4), DateAndTime().clone(hexValue="0000000000000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: smRunEndTime.setDescription("The date and time when the execution terminated. The value\n         '0000000000000000'H is returned if the script has not\n         terminated yet.")
smRunLifeTime = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 5), TimeInterval()).setUnits('centi-seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: smRunLifeTime.setDescription("This object specifies how long the script can execute.\n         This object returns the remaining time that the script\n         may run. The object is initialized with the value of the\n         associated smLaunchLifeTime object and ticks backwards.\n         The script is aborted immediately when the value reaches 0.\n\n         The value of this object may be set in order to increase or\n         reduce the remaining time that the script may run. Setting\n         this value to 0 will abort script execution immediately,\n         and, if the value of smRunExpireTime is also 0, will remove\n         this entry from the smRunTable once it has terminated.\n\n         If smRunLifeTime is set to its maximum value (2147483647),\n         either by a set operation or by its initialization from the\n         smLaunchLifeTime object, then it will not tick backwards.\n         A running script with a maximum smRunLifeTime value will\n         thus never be terminated with a `lifeTimeExceeded' exit\n         code.\n\n         The value of smRunLifeTime reflects the real-time execution\n         time as seen by the outside world. The value of this object\n         will always be 0 for a script that finished execution, that\n         is smRunState has the value `terminated'.\n\n         The value of smRunLifeTime does not change while a script\n         is suspended, that is smRunState has the value `suspended'.\n         Note that this does not affect set operations. It is legal\n         to modify smRunLifeTime via set operations while a script\n         is suspended.")
smRunExpireTime = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 6), TimeInterval()).setUnits('centi-seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: smRunExpireTime.setDescription("The value of this object specifies how long this row can\n         exist in the smRunTable after the script has terminated.\n         This object returns the remaining time that the row may\n         exist before it is aged out. The object is initialized with\n         the value of the associated smLaunchExpireTime object and\n         ticks backwards. The entry in the smRunTable is destroyed\n         when the value reaches 0 and the smRunState has the value\n         `terminated'.\n\n         The value of this object may be set in order to increase or\n         reduce the remaining time that the row may exist.  Setting\n         the value to 0 will destroy this entry as soon as the\n         smRunState has the value `terminated'.")
smRunExitCode = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9,))).clone(namedValues=NamedValues(("noError", 1), ("halted", 2), ("lifeTimeExceeded", 3), ("noResourcesLeft", 4), ("languageError", 5), ("runtimeError", 6), ("invalidArgument", 7), ("securityViolation", 8), ("genericError", 9),)).clone('noError')).setMaxAccess("readonly")
if mibBuilder.loadTexts: smRunExitCode.setDescription("The value of this object indicates the reason why a\n         script finished execution. The smRunExitCode code may have\n         one of the following values:\n\n         - `noError', which indicates that the script completed\n            successfully without errors;\n\n         - `halted', which indicates that the script was halted\n            by a request from an authorized manager;\n\n         - `lifeTimeExceeded', which indicates that the script\n            exited because a time limit was exceeded;\n\n         - `noResourcesLeft', which indicates that the script\n            exited because it ran out of resources (e.g. memory);\n\n         - `languageError', which indicates that the script exited\n            because of a language error (e.g. a syntax error in an\n            interpreted language);\n\n         - `runtimeError', which indicates that the script exited\n            due to a runtime error (e.g. a division by zero);\n\n         - `invalidArgument', which indicates that the script could\n            not be run because of invalid script arguments;\n\n         - `securityViolation', which indicates that the script\n            exited due to a security violation;\n\n         - `genericError', which indicates that the script exited\n            for an unspecified reason.\n\n         If the script has not yet begun running, or is currently\n         running, the value will be `noError'.")
smRunResult = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 8), OctetString().clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: smRunResult.setDescription('The result value produced by the running script. Note that\n         the result may change while the script is executing.')
smRunControl = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4,))).clone(namedValues=NamedValues(("abort", 1), ("suspend", 2), ("resume", 3), ("nop", 4),)).clone('nop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smRunControl.setDescription("The value of this object indicates the desired status of the\n         script execution defined by this row.\n\n         Setting this object to `abort' will abort execution if the\n\n         value of smRunState is `initializing', `executing',\n         `suspending', `suspended' or `resuming'. Setting this object\n         to `abort' when the value of smRunState is `aborting' or\n         `terminated', or if the implementation can determine that\n         the attempt to abort the execution would fail, will result\n         in an inconsistentValue error.\n\n         Setting this object to `suspend' will suspend execution\n         if the value of smRunState is `executing'. Setting this\n         object to `suspend' will cause an inconsistentValue error\n         if the value of smRunState is not `executing' or if the\n         implementation can determine that the attempt to suspend\n         the execution would fail.\n\n         Setting this object to `resume' will resume execution\n         if the value of smRunState is `suspending' or\n         `suspended'. Setting this object to `resume' will cause an\n         inconsistentValue error if the value of smRunState is\n         not `suspended' or if the implementation can determine\n         that the attempt to resume the execution would fail.\n\n         Setting this object to nop(4) has no effect.")
smRunState = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7,))).clone(namedValues=NamedValues(("initializing", 1), ("executing", 2), ("suspending", 3), ("suspended", 4), ("resuming", 5), ("aborting", 6), ("terminated", 7),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smRunState.setDescription("The value of this object indicates the script's execution\n         state. If the script has been invoked but has not yet\n         begun execution, the value will be `initializing'. If the\n         script is running, the value will be `executing'.\n\n         A running script which received a request to suspend\n         execution first transitions into a temporary `suspending'\n         state.  The temporary `suspending' state changes to\n         `suspended' when the script has actually been suspended. The\n         temporary `suspending' state changes back to `executing' if\n\n         the attempt to suspend the running script fails.\n\n         A suspended script which received a request to resume\n         execution first transitions into a temporary `resuming'\n         state. The temporary `resuming' state changes to `running'\n         when the script has actually been resumed. The temporary\n         `resuming' state changes back to `suspended' if the attempt\n         to resume the suspended script fails.\n\n         A script which received a request to abort execution but\n         which is still running first transitions into a temporary\n         `aborting' state.\n\n         A script which has finished its execution is `terminated'.")
smRunError = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 11), SnmpAdminString().clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: smRunError.setDescription("This object contains a descriptive error message if the\n         script startup or execution raised an abnormal condition.\n         An implementation must store a descriptive error message\n         in this object if the script exits with the smRunExitCode\n         `genericError'.")
smRunResultTime = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 12), DateAndTime().clone(hexValue="0000000000000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: smRunResultTime.setDescription("The date and time when the smRunResult was last updated.\n         The value '0000000000000000'H is returned if smRunResult\n         has not yet been updated after the creation of this\n         smRunTable entry.")
smRunErrorTime = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 13), DateAndTime().clone(hexValue="0000000000000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: smRunErrorTime.setDescription("The date and time when the smRunError was last updated.\n         The value '0000000000000000'H is returned if smRunError\n\n         has not yet been updated after the creation of this\n         smRunTable entry.")
smTraps = MibIdentifier((1, 3, 6, 1, 2, 1, 64, 2, 0))
smScriptAbort = NotificationType((1, 3, 6, 1, 2, 1, 64, 2, 0, 1)).setObjects(*(("DISMAN-SCRIPT-MIB", "smRunExitCode"), ("DISMAN-SCRIPT-MIB", "smRunEndTime"), ("DISMAN-SCRIPT-MIB", "smRunError"),))
if mibBuilder.loadTexts: smScriptAbort.setDescription("This notification is generated whenever a running script\n         terminates with an smRunExitCode unequal to `noError'.")
smScriptResult = NotificationType((1, 3, 6, 1, 2, 1, 64, 2, 0, 2)).setObjects(*(("DISMAN-SCRIPT-MIB", "smRunResult"),))
if mibBuilder.loadTexts: smScriptResult.setDescription('This notification can be used by scripts to notify other\n         management applications about results produced by the\n         script.\n\n         This notification is not automatically generated by the\n         Script MIB implementation. It is the responsibility of\n         the executing script to emit this notification where it\n         is appropriate to do so.')
smScriptException = NotificationType((1, 3, 6, 1, 2, 1, 64, 2, 0, 3)).setObjects(*(("DISMAN-SCRIPT-MIB", "smRunError"),))
if mibBuilder.loadTexts: smScriptException.setDescription('This notification can be used by scripts to notify other\n         management applications about script errors.\n\n         This notification is not automatically generated by the\n         Script MIB implementation. It is the responsibility of\n         the executing script or the runtime system to emit this\n         notification where it is appropriate to do so.')
smCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 64, 3, 1))
smGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 64, 3, 2))
smCompliance2 = ModuleCompliance((1, 3, 6, 1, 2, 1, 64, 3, 1, 2)).setObjects(*(("DISMAN-SCRIPT-MIB", "smLanguageGroup"), ("DISMAN-SCRIPT-MIB", "smScriptGroup2"), ("DISMAN-SCRIPT-MIB", "smLaunchGroup2"), ("DISMAN-SCRIPT-MIB", "smRunGroup2"), ("DISMAN-SCRIPT-MIB", "smNotificationsGroup2"), ("DISMAN-SCRIPT-MIB", "smCodeGroup"),))
if mibBuilder.loadTexts: smCompliance2.setDescription('The compliance statement for SNMP entities which implement\n         the Script MIB.')
smLanguageGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 64, 3, 2, 1)).setObjects(*(("DISMAN-SCRIPT-MIB", "smLangLanguage"), ("DISMAN-SCRIPT-MIB", "smLangVersion"), ("DISMAN-SCRIPT-MIB", "smLangVendor"), ("DISMAN-SCRIPT-MIB", "smLangRevision"), ("DISMAN-SCRIPT-MIB", "smLangDescr"), ("DISMAN-SCRIPT-MIB", "smExtsnExtension"), ("DISMAN-SCRIPT-MIB", "smExtsnVersion"), ("DISMAN-SCRIPT-MIB", "smExtsnVendor"), ("DISMAN-SCRIPT-MIB", "smExtsnRevision"), ("DISMAN-SCRIPT-MIB", "smExtsnDescr"),))
if mibBuilder.loadTexts: smLanguageGroup.setDescription('A collection of objects providing information about the\n         capabilities of the scripting engine.')
smScriptGroup2 = ObjectGroup((1, 3, 6, 1, 2, 1, 64, 3, 2, 7)).setObjects(*(("DISMAN-SCRIPT-MIB", "smScriptDescr"), ("DISMAN-SCRIPT-MIB", "smScriptLanguage"), ("DISMAN-SCRIPT-MIB", "smScriptSource"), ("DISMAN-SCRIPT-MIB", "smScriptAdminStatus"), ("DISMAN-SCRIPT-MIB", "smScriptOperStatus"), ("DISMAN-SCRIPT-MIB", "smScriptStorageType"), ("DISMAN-SCRIPT-MIB", "smScriptRowStatus"), ("DISMAN-SCRIPT-MIB", "smScriptError"), ("DISMAN-SCRIPT-MIB", "smScriptLastChange"),))
if mibBuilder.loadTexts: smScriptGroup2.setDescription('A collection of objects providing information about\n         installed scripts.')
smCodeGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 64, 3, 2, 3)).setObjects(*(("DISMAN-SCRIPT-MIB", "smCodeText"), ("DISMAN-SCRIPT-MIB", "smCodeRowStatus"),))
if mibBuilder.loadTexts: smCodeGroup.setDescription('A collection of objects used to download or modify scripts\n         by using SNMP set requests.')
smLaunchGroup2 = ObjectGroup((1, 3, 6, 1, 2, 1, 64, 3, 2, 8)).setObjects(*(("DISMAN-SCRIPT-MIB", "smLaunchScriptOwner"), ("DISMAN-SCRIPT-MIB", "smLaunchScriptName"), ("DISMAN-SCRIPT-MIB", "smLaunchArgument"), ("DISMAN-SCRIPT-MIB", "smLaunchMaxRunning"), ("DISMAN-SCRIPT-MIB", "smLaunchMaxCompleted"), ("DISMAN-SCRIPT-MIB", "smLaunchLifeTime"), ("DISMAN-SCRIPT-MIB", "smLaunchExpireTime"), ("DISMAN-SCRIPT-MIB", "smLaunchStart"), ("DISMAN-SCRIPT-MIB", "smLaunchControl"), ("DISMAN-SCRIPT-MIB", "smLaunchAdminStatus"), ("DISMAN-SCRIPT-MIB", "smLaunchOperStatus"), ("DISMAN-SCRIPT-MIB", "smLaunchRunIndexNext"), ("DISMAN-SCRIPT-MIB", "smLaunchStorageType"), ("DISMAN-SCRIPT-MIB", "smLaunchRowStatus"), ("DISMAN-SCRIPT-MIB", "smLaunchError"), ("DISMAN-SCRIPT-MIB", "smLaunchLastChange"), ("DISMAN-SCRIPT-MIB", "smLaunchRowExpireTime"),))
if mibBuilder.loadTexts: smLaunchGroup2.setDescription('A collection of objects providing information about scripts\n         that can be launched.')
smRunGroup2 = ObjectGroup((1, 3, 6, 1, 2, 1, 64, 3, 2, 9)).setObjects(*(("DISMAN-SCRIPT-MIB", "smRunArgument"), ("DISMAN-SCRIPT-MIB", "smRunStartTime"), ("DISMAN-SCRIPT-MIB", "smRunEndTime"), ("DISMAN-SCRIPT-MIB", "smRunLifeTime"), ("DISMAN-SCRIPT-MIB", "smRunExpireTime"), ("DISMAN-SCRIPT-MIB", "smRunExitCode"), ("DISMAN-SCRIPT-MIB", "smRunResult"), ("DISMAN-SCRIPT-MIB", "smRunState"), ("DISMAN-SCRIPT-MIB", "smRunControl"), ("DISMAN-SCRIPT-MIB", "smRunError"), ("DISMAN-SCRIPT-MIB", "smRunResultTime"), ("DISMAN-SCRIPT-MIB", "smRunErrorTime"),))
if mibBuilder.loadTexts: smRunGroup2.setDescription('A collection of objects providing information about running\n         scripts.')
smNotificationsGroup2 = NotificationGroup((1, 3, 6, 1, 2, 1, 64, 3, 2, 10)).setObjects(*(("DISMAN-SCRIPT-MIB", "smScriptAbort"), ("DISMAN-SCRIPT-MIB", "smScriptResult"), ("DISMAN-SCRIPT-MIB", "smScriptException"),))
if mibBuilder.loadTexts: smNotificationsGroup2.setDescription('The notifications emitted by the Script MIB.')
smCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 64, 3, 1, 1)).setObjects(*(("DISMAN-SCRIPT-MIB", "smLanguageGroup"), ("DISMAN-SCRIPT-MIB", "smScriptGroup"), ("DISMAN-SCRIPT-MIB", "smLaunchGroup"), ("DISMAN-SCRIPT-MIB", "smRunGroup"), ("DISMAN-SCRIPT-MIB", "smCodeGroup"),))
if mibBuilder.loadTexts: smCompliance.setDescription('The compliance statement for SNMP entities which implement\n         the Script MIB.')
smScriptGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 64, 3, 2, 2)).setObjects(*(("DISMAN-SCRIPT-MIB", "smScriptDescr"), ("DISMAN-SCRIPT-MIB", "smScriptLanguage"), ("DISMAN-SCRIPT-MIB", "smScriptSource"), ("DISMAN-SCRIPT-MIB", "smScriptAdminStatus"), ("DISMAN-SCRIPT-MIB", "smScriptOperStatus"), ("DISMAN-SCRIPT-MIB", "smScriptStorageType"), ("DISMAN-SCRIPT-MIB", "smScriptRowStatus"),))
if mibBuilder.loadTexts: smScriptGroup.setDescription('A collection of objects providing information about\n         installed scripts.')
smLaunchGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 64, 3, 2, 4)).setObjects(*(("DISMAN-SCRIPT-MIB", "smLaunchScriptOwner"), ("DISMAN-SCRIPT-MIB", "smLaunchScriptName"), ("DISMAN-SCRIPT-MIB", "smLaunchArgument"), ("DISMAN-SCRIPT-MIB", "smLaunchMaxRunning"), ("DISMAN-SCRIPT-MIB", "smLaunchMaxCompleted"), ("DISMAN-SCRIPT-MIB", "smLaunchLifeTime"), ("DISMAN-SCRIPT-MIB", "smLaunchExpireTime"), ("DISMAN-SCRIPT-MIB", "smLaunchStart"), ("DISMAN-SCRIPT-MIB", "smLaunchControl"), ("DISMAN-SCRIPT-MIB", "smLaunchAdminStatus"), ("DISMAN-SCRIPT-MIB", "smLaunchOperStatus"), ("DISMAN-SCRIPT-MIB", "smLaunchRunIndexNext"), ("DISMAN-SCRIPT-MIB", "smLaunchStorageType"), ("DISMAN-SCRIPT-MIB", "smLaunchRowStatus"),))
if mibBuilder.loadTexts: smLaunchGroup.setDescription('A collection of objects providing information about scripts\n         that can be launched.')
smRunGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 64, 3, 2, 5)).setObjects(*(("DISMAN-SCRIPT-MIB", "smRunArgument"), ("DISMAN-SCRIPT-MIB", "smRunStartTime"), ("DISMAN-SCRIPT-MIB", "smRunEndTime"), ("DISMAN-SCRIPT-MIB", "smRunLifeTime"), ("DISMAN-SCRIPT-MIB", "smRunExpireTime"), ("DISMAN-SCRIPT-MIB", "smRunExitCode"), ("DISMAN-SCRIPT-MIB", "smRunResult"), ("DISMAN-SCRIPT-MIB", "smRunState"), ("DISMAN-SCRIPT-MIB", "smRunControl"), ("DISMAN-SCRIPT-MIB", "smRunError"),))
if mibBuilder.loadTexts: smRunGroup.setDescription('A collection of objects providing information about running\n         scripts.')
smNotificationsGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 64, 3, 2, 6)).setObjects(*(("DISMAN-SCRIPT-MIB", "smScriptAbort"), ("DISMAN-SCRIPT-MIB", "smScriptResult"),))
if mibBuilder.loadTexts: smNotificationsGroup.setDescription('The notifications emitted by the Script MIB.')
mibBuilder.exportSymbols("DISMAN-SCRIPT-MIB", smLaunchLifeTime=smLaunchLifeTime, smRunGroup=smRunGroup, smRunArgument=smRunArgument, smLaunchError=smLaunchError, PYSNMP_MODULE_ID=scriptMIB, smCodeGroup=smCodeGroup, smExtsnDescr=smExtsnDescr, smLaunchTable=smLaunchTable, smScriptStorageType=smScriptStorageType, smExtsnIndex=smExtsnIndex, smLaunchGroup=smLaunchGroup, smRunExitCode=smRunExitCode, smRunTable=smRunTable, smGroups=smGroups, smExtsnVersion=smExtsnVersion, smLaunchArgument=smLaunchArgument, smScriptResult=smScriptResult, smLaunchLastChange=smLaunchLastChange, smNotifications=smNotifications, smLangRevision=smLangRevision, smCodeText=smCodeText, smScriptOwner=smScriptOwner, smScriptGroup=smScriptGroup, smLangTable=smLangTable, smScriptRowStatus=smScriptRowStatus, smScriptName=smScriptName, smRunLifeTime=smRunLifeTime, smLaunchControl=smLaunchControl, smLaunchStorageType=smLaunchStorageType, smCodeIndex=smCodeIndex, smObjects=smObjects, smConformance=smConformance, smExtsnRevision=smExtsnRevision, smScriptDescr=smScriptDescr, smLangVersion=smLangVersion, smScriptError=smScriptError, smExtsnExtension=smExtsnExtension, smRunState=smRunState, smRunControl=smRunControl, smLaunchOperStatus=smLaunchOperStatus, smExtsnEntry=smExtsnEntry, smLaunchAdminStatus=smLaunchAdminStatus, smLangEntry=smLangEntry, smLaunchMaxCompleted=smLaunchMaxCompleted, smScriptLanguage=smScriptLanguage, smScriptGroup2=smScriptGroup2, smScriptOperStatus=smScriptOperStatus, smLangDescr=smLangDescr, smLaunchEntry=smLaunchEntry, smLaunchStart=smLaunchStart, smRunIndex=smRunIndex, smLaunchRowExpireTime=smLaunchRowExpireTime, smLaunchRunIndexNext=smLaunchRunIndexNext, smScriptLastChange=smScriptLastChange, smCompliances=smCompliances, smTraps=smTraps, smScriptException=smScriptException, smLaunchScriptName=smLaunchScriptName, smCodeEntry=smCodeEntry, smScriptSource=smScriptSource, smRunObjects=smRunObjects, scriptMIB=scriptMIB, smExtsnTable=smExtsnTable, smRunErrorTime=smRunErrorTime, smCompliance2=smCompliance2, smLangVendor=smLangVendor, smLanguageGroup=smLanguageGroup, smRunResultTime=smRunResultTime, smScriptAbort=smScriptAbort, smRunGroup2=smRunGroup2, smLangLanguage=smLangLanguage, smNotificationsGroup=smNotificationsGroup, smNotificationsGroup2=smNotificationsGroup2, smRunExpireTime=smRunExpireTime, smExtsnVendor=smExtsnVendor, smScriptObjects=smScriptObjects, smLaunchRowStatus=smLaunchRowStatus, smRunEndTime=smRunEndTime, smLaunchGroup2=smLaunchGroup2, smLaunchOwner=smLaunchOwner, smCodeRowStatus=smCodeRowStatus, smLangIndex=smLangIndex, smRunError=smRunError, smLaunchName=smLaunchName, smScriptAdminStatus=smScriptAdminStatus, smRunResult=smRunResult, smCompliance=smCompliance, smLaunchExpireTime=smLaunchExpireTime, smLaunchScriptOwner=smLaunchScriptOwner, smRunStartTime=smRunStartTime, smLaunchMaxRunning=smLaunchMaxRunning, smScriptTable=smScriptTable, smRunEntry=smRunEntry, smCodeTable=smCodeTable, smScriptEntry=smScriptEntry)
