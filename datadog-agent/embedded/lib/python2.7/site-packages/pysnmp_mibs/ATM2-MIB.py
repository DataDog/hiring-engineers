#
# PySNMP MIB module ATM2-MIB (http://pysnmp.sf.net)
# ASN.1 source http://mibs.snmplabs.com:80/asn1/ATM2-MIB
# Produced by pysmi-0.0.7 at Sun Feb 14 00:06:16 2016
# On host bldfarm platform Linux version 4.1.13-100.fc21.x86_64 by user goose
# Using Python version 3.5.0 (default, Jan  5 2016, 17:11:52) 
#
( ObjectIdentifier, Integer, OctetString, ) = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint")
( atmMIBObjects, atmInterfaceConfEntry, atmVplEntry, atmVplVpi, atmVclVpi, atmVclEntry, atmVclVci, atmVcCrossConnectEntry, atmVpCrossConnectEntry, ) = mibBuilder.importSymbols("ATM-MIB", "atmMIBObjects", "atmInterfaceConfEntry", "atmVplEntry", "atmVplVpi", "atmVclVpi", "atmVclEntry", "atmVclVci", "atmVcCrossConnectEntry", "atmVpCrossConnectEntry")
( AtmIlmiNetworkPrefix, AtmAddr, AtmTrafficDescrParamIndex, AtmInterfaceType, AtmVpIdentifier, AtmSigDescrParamIndex, AtmVcIdentifier, ) = mibBuilder.importSymbols("ATM-TC-MIB", "AtmIlmiNetworkPrefix", "AtmAddr", "AtmTrafficDescrParamIndex", "AtmInterfaceType", "AtmVpIdentifier", "AtmSigDescrParamIndex", "AtmVcIdentifier")
( ifIndex, InterfaceIndex, InterfaceIndexOrZero, ) = mibBuilder.importSymbols("IF-MIB", "ifIndex", "InterfaceIndex", "InterfaceIndexOrZero")
( NotificationGroup, ObjectGroup, ModuleCompliance, ) = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
( ObjectIdentity, MibIdentifier, Gauge32, Counter32, ModuleIdentity, Counter64, Bits, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, NotificationType, IpAddress, Unsigned32, Integer32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "MibIdentifier", "Gauge32", "Counter32", "ModuleIdentity", "Counter64", "Bits", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "NotificationType", "IpAddress", "Unsigned32", "Integer32")
( TextualConvention, TimeStamp, DisplayString, RowStatus, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TimeStamp", "DisplayString", "RowStatus", "TruthValue")
atm2MIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 37, 1, 14)).setRevisions(("1999-09-16 12:00",))
if mibBuilder.loadTexts: atm2MIB.setLastUpdated('9909161200Z')
if mibBuilder.loadTexts: atm2MIB.setOrganization('IETF AToMMIB Working Group')
if mibBuilder.loadTexts: atm2MIB.setContactInfo('          Faye Ly\n                       Postal:  Copper Mountain Networks\n                                2470 Embarcadero Way\n                                Palo Alto, CA 94303\n                                USA\n                       Tel:     +1 650 858 8500 ext.240\n                       E-Mail:  faye@coppermountain.com\n\n                                Michael Noto\n                       Postal:  Cisco Systems\n                                170 W. Tasman Drive\n                                San Jose, CA 95134-1706\n                                USA\n                       E-mail:  mnoto@cisco.com\n                                Andrew Smith\n                       Postal:  Extreme Networks\n                                10460 Bandley Drive\n                                Cupertino, CA 95014\n                                USA\n                       Tel:     +1 408 863 2821\n                       Fax:     +1 408 342 0990\n                       E-Mail:  ansmith@extremenetworks.com\n\n                                Ethan Mickey Spiegel\n                       Postal:  Cisco Systems\n                                170 W. Tasman Drive\n                                San Jose, CA 95134-1706\n                                USA\n                       Tel:     +1 408 526 6408\n                       Fax:     +1 408 526 6488\n                       E-Mail:  mspiegel@cisco.com\n\n                                Kaj Tesink\n                       Postal:  Telcordia Technologies\n                                331 Newman Springs Road\n                                Red Bank, NJ 07701\n                                USA\n                       Tel:     +1 732 758 5254\n                       Fax:     +1 732 758 2269\n                       E-mail:  kaj@research.telcordia.com')
if mibBuilder.loadTexts: atm2MIB.setDescription('This MIB Module is a supplement to the ATM-MIB\n                     defined in RFC 2515.')
atm2MIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 1))
atm2MIBTraps = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 2))
atmSvcVpCrossConnectTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1), )
if mibBuilder.loadTexts: atmSvcVpCrossConnectTable.setDescription('The ATM SVPC Cross-Connect table.  A\n                     bi-directional VP cross-connect between two\n                     switched VPLs is modeled as one entry in this\n                     table.  A Soft PVPC cross-connect, between a\n                     soft permanent VPL and a switched VPL, is\n                     also modeled as one entry in this table.')
atmSvcVpCrossConnectEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1), ).setIndexNames((0, "ATM2-MIB", "atmSvcVpCrossConnectIndex"), (0, "ATM2-MIB", "atmSvcVpCrossConnectLowIfIndex"), (0, "ATM2-MIB", "atmSvcVpCrossConnectLowVpi"), (0, "ATM2-MIB", "atmSvcVpCrossConnectHighIfIndex"), (0, "ATM2-MIB", "atmSvcVpCrossConnectHighVpi"))
if mibBuilder.loadTexts: atmSvcVpCrossConnectEntry.setDescription('An entry in the ATM SVPC Cross-Connect table.\n                     This entry is used to model a bi-directional\n                     ATM VP cross-connect between two VPLs.')
atmSvcVpCrossConnectIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647)))
if mibBuilder.loadTexts: atmSvcVpCrossConnectIndex.setDescription('A unique value to identify this SVPC\n                     cross-connect.')
atmSvcVpCrossConnectLowIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: atmSvcVpCrossConnectLowIfIndex.setDescription('The value of this object is equal to the\n                     ifIndex value of the ATM interface port for this\n                     SVPC cross-connect.  The term low implies\n                     that this ATM interface has the numerically lower\n                     ifIndex value than the other ATM interface\n                     identified in the same atmSvcVpCrossConnectEntry.')
atmSvcVpCrossConnectLowVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 3), AtmVpIdentifier())
if mibBuilder.loadTexts: atmSvcVpCrossConnectLowVpi.setDescription('The value of this object is equal to the VPI\n                     value associated with the SVPC cross-connect\n                     at the ATM interface that is identified by\n                     atmSvcVpCrossConnectLowIfIndex.  The VPI value\n                     cannot exceed the number supported by the\n                     atmInterfaceMaxVpiBits at the low ATM interface\n                     port.')
atmSvcVpCrossConnectHighIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 4), InterfaceIndex())
if mibBuilder.loadTexts: atmSvcVpCrossConnectHighIfIndex.setDescription('The value of this object is equal to the\n                     ifIndex value of the ATM interface port for\n                     this SVC VP cross-connect.  The term high\n                     implies that this ATM interface has the\n                     numerically higher ifIndex value than the\n                     other ATM interface identified in the same\n                     atmSvcVpCrossConnectEntry.')
atmSvcVpCrossConnectHighVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 5), AtmVpIdentifier())
if mibBuilder.loadTexts: atmSvcVpCrossConnectHighVpi.setDescription('The value of this object is equal to the VPI\n                     value associated with the SVPC cross-connect\n                     at the ATM interface that is identified by\n                     atmSvcVpCrossConnectHighIfIndex.  The VPI value\n                     cannot exceed the number supported by the\n                     atmInterfaceMaxVpiBits at the high ATM interface\n                     port.')
atmSvcVpCrossConnectCreationTime = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSvcVpCrossConnectCreationTime.setDescription('The value of the sysUpTime object\n                     at the time this bi-directional SVPC\n                     cross-connect was created.  If the current\n                     state was entered prior to the last\n                     re-initialization of the agent, then this\n                     object contains a zero value.')
atmSvcVpCrossConnectRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 1, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSvcVpCrossConnectRowStatus.setDescription('This object is used to delete rows in the\n                      atmSvcVpCrossConnectTable.')
atmSvcVcCrossConnectTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2), )
if mibBuilder.loadTexts: atmSvcVcCrossConnectTable.setDescription('The ATM SVCC Cross-Connect table.  A\n                    bi-directional VC cross-connect between two\n                    switched VCLs is modeled as one entry in\n                    this table.  A Soft PVCC cross-connect,\n                    between a soft permanent VCL and a switched\n                    VCL, is also modeled as one entry in this\n                    table.')
atmSvcVcCrossConnectEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1), ).setIndexNames((0, "ATM2-MIB", "atmSvcVcCrossConnectIndex"), (0, "ATM2-MIB", "atmSvcVcCrossConnectLowIfIndex"), (0, "ATM2-MIB", "atmSvcVcCrossConnectLowVpi"), (0, "ATM2-MIB", "atmSvcVcCrossConnectLowVci"), (0, "ATM2-MIB", "atmSvcVcCrossConnectHighIfIndex"), (0, "ATM2-MIB", "atmSvcVcCrossConnectHighVpi"), (0, "ATM2-MIB", "atmSvcVcCrossConnectHighVci"))
if mibBuilder.loadTexts: atmSvcVcCrossConnectEntry.setDescription('An entry in the ATM SVCC Cross-Connect table.\n                    This entry is used to model a bi-directional ATM\n                    VC cross-connect between two VCLs.')
atmSvcVcCrossConnectIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647)))
if mibBuilder.loadTexts: atmSvcVcCrossConnectIndex.setDescription('A unique value to identify this SVCC cross-connect.')
atmSvcVcCrossConnectLowIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: atmSvcVcCrossConnectLowIfIndex.setDescription('The value of this object is equal to the\n                    ifIndex value of the ATM interface port for this\n                    SVCC cross-connect.  The term low implies that\n                    this ATM interface has the numerically lower\n                    ifIndex value than the other ATM interface\n                    identified in the same atmSvcVcCrossConnectEntry.')
atmSvcVcCrossConnectLowVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 3), AtmVpIdentifier())
if mibBuilder.loadTexts: atmSvcVcCrossConnectLowVpi.setDescription('The value of this object is equal to the VPI\n                    value associated with the SVCC cross-connect\n                    at the ATM interface that is identified by\n                    atmSvcVcCrossConnectLowIfIndex.  The VPI value\n                    cannot exceed the number supported by the\n                    atmInterfaceMaxVpiBits at the low ATM interface\n                    port.')
atmSvcVcCrossConnectLowVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 4), AtmVcIdentifier())
if mibBuilder.loadTexts: atmSvcVcCrossConnectLowVci.setDescription('The value of this object is equal to the VCI\n                    value associated with the SVCC cross-connect\n                    at the ATM interface that is identified by\n                    atmSvcVcCrossConnectLowIfIndex.  The VCI value\n                    cannot exceed the number supported by the\n                    atmInterfaceMaxVciBits at the low ATM interface\n                    port.')
atmSvcVcCrossConnectHighIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 5), InterfaceIndex())
if mibBuilder.loadTexts: atmSvcVcCrossConnectHighIfIndex.setDescription('The value of this object is equal to the\n                    ifIndex value for the ATM interface port for\n                    this SVCC cross-connect.  The term high implies\n                    that this ATM interface has the numerically\n                    higher ifIndex value than the other ATM interface\n                    identified in the same atmSvcVcCrossConnectEntry.')
atmSvcVcCrossConnectHighVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 6), AtmVpIdentifier())
if mibBuilder.loadTexts: atmSvcVcCrossConnectHighVpi.setDescription('The value of this object is equal to the VPI\n                    value associated with the SVCC cross-connect\n                    at the ATM interface that is identified by\n                    atmSvcVcCrossConnectHighIfIndex.  The VPI value\n                    cannot exceed the number supported by the\n                    atmInterfaceMaxVpiBits at the high ATM interface\n                    port.')
atmSvcVcCrossConnectHighVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 7), AtmVcIdentifier())
if mibBuilder.loadTexts: atmSvcVcCrossConnectHighVci.setDescription('The value of this object is equal to the VCI\n                    value associated with the SVCC cross-connect\n                    at the ATM interface that is identified by\n                    atmSvcVcCrossConnectHighIfIndex.  The VCI value\n                    cannot exceed the number supported by the\n                    atmInterfaceMaxVciBits at the high ATM interface\n                    port.')
atmSvcVcCrossConnectCreationTime = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSvcVcCrossConnectCreationTime.setDescription('The value of the sysUpTime object\n                    at the time this bi-directional SVCC\n                    cross-connect was created.  If the current\n                    state was entered prior to the last\n                    re-initialization of the agent, then this\n                    object contains a zero value.')
atmSvcVcCrossConnectRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 2, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSvcVcCrossConnectRowStatus.setDescription('This object is used to delete rows in the\n                     atmSvcVcCrossConnectTable.')
atmSigStatTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3), )
if mibBuilder.loadTexts: atmSigStatTable.setDescription('This table contains ATM interface signalling\n                  statistics, one entry per ATM signalling\n                  interface.')
atmSigStatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmSigStatEntry.setDescription('This list contains signalling statistics variables.')
atmSigSSCOPConEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigSSCOPConEvents.setDescription('SSCOP Connection Events Counter.  This\n                    counter counts the sum of the following errors:\n\n                    1) SSCOP Connection Disconnect Counter\n\n                    The abnormal occurrence of this event is\n                    characterized by the expiry of Timer_NO_RESPONSE.\n                    (This event is communicated to the layer management\n                    with MAA-ERROR code P.  See ITU-T Q.2110.)\n\n                    2) SSCOP Connection Initiation Failure\n\n                    This condition indicates the inability to establish\n                    an SSCOP connection.  This event occurs whenever the\n                    number of expiries of the connection control timer\n                    (Timer_CC) equals or exceeds the MaxCC, or upon\n                    receipt of a connection reject message BGREJ PDU.\n                    (This event is communicated to layer management with\n                    MAA-ERROR code O.  See ITU-T Q.2110.)\n\n                    3) SSCOP Connection Re-Establ/Resynch\n\n                    This event occurs upon receipt of a BGN PDU or\n                    RS PDU.')
atmSigSSCOPErrdPdus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigSSCOPErrdPdus.setDescription('SSCOP Errored PDUs Counter.  This counter counts the\n                   sum of the following errors:\n\n                   1) Invalid PDUs.\n                      These are defined in SSCOP and consist of PDUs\n                      with an incorrect length (MAA-ERROR code U), an\n                      undefined PDU type code, or that are not 32-bit\n                      aligned.\n\n                   2) PDUs that result in MAA-ERROR codes and are\n                      discarded.\n\n                   See MAA-ERROR codes A-D, F-M, and Q-T defined in\n                   ITU-T Q.2110.')
atmSigDetectSetupAttempts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectSetupAttempts.setDescription('Call Setup Attempts Counter.  This counter counts\n                  the number of call setup attempts (both successful\n                  and unsuccessful) detected on this interface.')
atmSigEmitSetupAttempts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitSetupAttempts.setDescription('Call Setup Attempts Counter.  This counter counts the\n                 number of call setup attempts (both successful and\n                 unsuccessful) transmitted on this interface.')
atmSigDetectUnavailRoutes = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectUnavailRoutes.setDescription('Number of Route Unavailability detected on this\n                 interface.  This counter is incremented when a RELEASE,\n                 RELEASE COMPLETE (only when not preceded by a RELEASE\n                 message for the same call), ADD PARTY REJECT, or STATUS\n                 message that contains one of the following cause code\n                 values is received (Note: These cause values apply to\n                 both UNI3.0 and UNI3.1):\n\n                 Cause Value            Meaning\n\n                    1            unallocated (unassigned) number\n                    2            no route to specified transit network\n                    3            no route to destination\n\n                 NOTE:  For this counter, RELEASE COMPLETE\n                 messages that are a reply to a previous RELEASE\n                 message and contain the same cause value, are\n                 redundant (for counting purposes) and should not\n                 be counted.')
atmSigEmitUnavailRoutes = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitUnavailRoutes.setDescription('Number of Route Unavailability transmitted from this\n                 interface.  This counter is incremented when a RELEASE,\n                 RELEASE COMPLETE (only when not preceded by a RELEASE\n                 message for the same call), ADD PARTY REJECT, or STATUS\n                 message that contains one of the following cause code\n                 values is transmitted (Note: These cause values apply\n                 to both UNI3.0 and UNI3.1):\n\n                 Cause Value            Meaning\n                    1            unallocated (unassigned) number\n                    2            no route to specified transit network\n                    3            no route to destination\n\n                 NOTE:  For this counter, RELEASE COMPLETE\n                 messages that are a reply to a previous RELEASE\n                 message and contain the same cause value, are\n                 redundant (for counting purposes) and should not\n                 be counted.')
atmSigDetectUnavailResrcs = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectUnavailResrcs.setDescription('Number of Resource Unavailability detected on this\n                 interface.  This counter is incremented when a RELEASE,\n                 RELEASE COMPLETE (only when not preceded by a RELEASE\n                 message for the same call), ADD PARTY REJECT, or STATUS\n                 message that contains one of the following cause code\n                 values is received (Note: These cause values apply to\n                 both UNI3.0 and UNI3.1 unless otherwise stated):\n\n                 Cause Value          Meaning\n\n                    35          requested VPCI/VCI not available\n                    37          user cell rate not available (UNI3.1\n                                only)\n                    38          network out of order\n                    41          temporary failure\n                    45          no VPCI/VCI available\n                    47          resource unavailable, unspecified\n                    49          Quality of Service unavailable\n                    51          user cell rate not available (UNI3.0\n                                only)\n                    58          bearer capability not presently\n                                available\n                    63          Service or option not available,\n                                unspecified\n                    92          too many pending add party requests\n\n                 NOTE:  For this counter, RELEASE COMPLETE\n                 messages that are a reply to a previous RELEASE\n                 message and contain the same cause value, are\n                 redundant (for counting purposes) and should not\n                 be counted.')
atmSigEmitUnavailResrcs = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitUnavailResrcs.setDescription('Number of Resource Unavailability transmitted from\n                 this interface.  This counter is incremented when a\n                 RELEASE, RELEASE COMPLETE (only when not preceded by a\n                 RELEASE message for the same call), ADD PARTY REJECT,\n                 or STATUS message that contains one of the following\n                 cause code values is transmitted (Note: These cause\n                 values apply to both UNI3.0 and UNI3.1 unless otherwise\n                 stated):\n\n                 Cause Value          Meaning\n\n                    35          requested VPCI/VCI not available\n                    37          user cell rate not available (UNI3.1\n                                only)\n                    38          network out of order\n                    41          temporary failure\n                    45          no VPCI/VCI available\n                    47          resource unavailable, unspecified\n                    49          Quality of Service unavailable\n                    51          user cell rate not available (UNI3.0\n                                only)\n                    58          bearer capability not presently\n                                available\n                    63          Service or option not available,\n                                unspecified\n                    92          too many pending add party requests\n\n                 NOTE:  For this counter, RELEASE COMPLETE\n                 messages that are a reply to a previous RELEASE\n                 message and contain the same cause value, are\n                 redundant (for counting purposes) and should not\n                 be counted.')
atmSigDetectCldPtyEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectCldPtyEvents.setDescription("Number of Called Party Responsible For Unsuccessful\n                 Call detected on this interface.  This counter is\n                 incremented when a RELEASE, RELEASE COMPLETE (only when\n                 not preceded by a RELEASE message for the same call),\n                 ADD PARTY REJECT, or STATUS message that contains one\n                 of the following cause code values is received (Note:\n                 These cause values apply to both UNI3.0 and UNI3.1):\n\n                 Cause Value         Meaning\n\n                    17           user busy\n                    18           no user responding\n                    21           call rejected\n                    22           number changed\n                    23           user rejects all calls with calling\n                                 line identification restriction (CLIR)\n                    27           destination out of order\n                    31           normal, unspecified\n                    88           incompatible destination\n\n                 NOTE:  For this counter, RELEASE COMPLETE\n                 messages that are a reply to a previous RELEASE\n                 message and contain the same cause value, are\n                 redundant (for counting purposes) and should not\n                 be counted.\n\n                 Note: Cause Value #30 'response to STATUS ENQUIRY'\n                 was not included in this memo since it did not apply\n                 to a hard failure.")
atmSigEmitCldPtyEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitCldPtyEvents.setDescription("Number of Called Party Responsible For Unsuccessful\n                 Call transmitted from this interface.  This counter is\n                 incremented when a RELEASE, RELEASE COMPLETE (only\n                 when not preceded by a RELEASE message for the same call),\n                 ADD PARTY REJECT, or STATUS message that contains one\n                 of the following cause code values is\n                 transmitted (Note: These cause values apply to both\n                 UNI3.0 and UNI3.1):\n\n                 Cause Value         Meaning\n\n                    17           user busy\n                    18           no user responding\n                    21           call rejected\n                    22           number changed\n                    23           user rejects all calls with calling\n                                 line identification restriction (CLIR)\n                    27           destination out of order\n                    31           normal, unspecified\n                    88           incompatible destination\n\n                 NOTE:  For this counter, RELEASE COMPLETE\n                 messages that are a reply to a previous RELEASE\n                 message and contain the same cause value, are\n                 redundant (for counting purposes) and should not\n                 be counted.\n\n                 Note: Cause Value #30 'response to STATUS ENQUIRY'\n                 was not included in this memo since it did not apply\n                 to a hard failure.")
atmSigDetectMsgErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectMsgErrors.setDescription("Number of Incorrect Messages detected on this\n                 interface.  The Incorrect Messages Counter reflects any\n                 sort of incorrect information in a message.  This\n                 includes:\n\n                 - RELEASE, RELEASE COMPLETE, ADD PARTY REJECT,\n                   and STATUS messages transmitted, that contain any of\n                   the Cause values listed below.\n\n                 - Ignored messages.  These messages are dropped\n                   because the message was so damaged that it could\n                   not be further processed.  A list of dropped\n                   messages is compiled below:\n\n                    1.  Message with invalid protocol discriminator\n\n                    2.  Message with errors in the call reference I.E.\n                         - Bits 5-8 of the first octet not equal to\n                           '0000'\n                         - Bits 1-4 of the first octet indicating a\n                           length other than 3 octets\n                         - RELEASE COMPLETE message received with a\n                           call reference that does not relate to a\n                           call active or in progress\n                         - SETUP message received with call reference\n                           flag incorrectly set to 1\n                         - SETUP message received with a call\n                           reference for a call that is already\n                           active or in progress.\n\n                    3.  Message too short\n\n\n                 The following cause values are monitored by this\n                 counter (Note: These cause values apply to both UNI3.0\n                 and UNI3.1 unless otherwise stated):\n\n                 Cause Value     Meaning\n\n                    10     VPCI/VCI unacceptable (UNI3.0 only)\n                    36     VPCI/VCI assignment failure (UNI3.1 only)\n                    81     invalid call reference value\n                    82     identified channel does not exist\n                    89     invalid endpoint reference\n                    96     mandatory information element is missing\n                    97     message type non-existent or not\n                           implemented\n                    99     information element non-existent or not\n                           implemented\n                    100    invalid information element contents\n                    101    message not compatible with call state\n                    104    incorrect message length\n                    111    protocol error, unspecified\n                    NOTE:  For this counter, RELEASE COMPLETE\n                    messages that are a reply to a previous RELEASE\n                    message and contain the same cause value, are\n                    redundant (for counting purposes) and should not\n                    be counted.")
atmSigEmitMsgErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitMsgErrors.setDescription("Number of Incorrect Messages transmitted on this\n                 interface.  The Incorrect Messages Counter reflects any\n                 sort of incorrect information in a message.  This\n                 includes:\n\n\n                 - RELEASE, RELEASE COMPLETE, ADD PARTY REJECT,\n                   and STATUS messages transmitted or\n                   received, that contain any of the Cause values\n                   listed below.\n\n                 - Ignored messages.  These messages are dropped\n                   because the message was so damaged that it could\n                   not be further processed.  A list of dropped\n                   messages is compiled below:\n\n                    1.  Message with invalid protocol discriminator\n\n                    2.  Message with errors in the call reference I.E.\n                         - Bits 5-8 of the first octet not equal to\n                           '0000'\n                         - Bits 1-4 of the first octet indicating a\n                           length other than 3 octets\n                         - RELEASE COMPLETE message received with a\n                           call reference that does not relate to a\n                           call active or in progress\n                         - SETUP message received with call reference\n                           flag incorrectly set to 1\n                         - SETUP message received with a call\n                           reference for a call that is already\n                           active or in progress.\n\n                    3.  Message too short\n\n\n                 The following cause values are monitored by this\n                 counter (Note: These cause values apply to both UNI3.0\n                 and UNI3.1 unless otherwise stated):\n\n                 Cause Value     Meaning\n\n                    10     VPCI/VCI unacceptable (UNI3.0 only)\n                    36     VPCI/VCI assignment failure (UNI3.1 only)\n                    81     invalid call reference value\n                    82     identified channel does not exist\n                    89     invalid endpoint reference\n                    96     mandatory information element is missing\n                    97     message type non-existent or not\n                           implemented\n                    99     information element non-existent or not\n                           implemented\n                    100    invalid information element contents\n                    101    message not compatible with call state\n                    104    incorrect message length\n                    111    protocol error, unspecified\n\n                    NOTE:  For this counter, RELEASE COMPLETE\n                    messages that are a reply to a previous RELEASE\n                    message and contain the same cause value, are\n                    redundant (for counting purposes) and should not\n                    be counted.")
atmSigDetectClgPtyEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectClgPtyEvents.setDescription('Number of Calling Party Events detected on this\n                 interface.  This counter monitors error events that\n                 occur due to the originating user doing something\n                 wrong.  This counter is incremented when a RELEASE,\n                 RELEASE COMPLETE (only when not preceded by a RELEASE\n                 message for the same call), ADD PARTY REJECT, or STATUS\n                 message that contains one of the following cause code\n                 values is received (Note: These cause values apply to\n                 both UNI3.0 and UNI3.1):\n\n                 Cause Value     Meaning\n\n                    28     invalid number format (address incomplete)\n                    43     access information discarded\n                    57     bearer capability not authorized\n                    65     bearer capability not implemented\n                    73     unsupported combination of traffic\n                           parameters\n                    78     AAL parameters cannot be supported (UNI3.1\n                           only)\n                    91     invalid transit network selection\n                    93     AAL parameters cannot be supported (UNI3.0\n                           only)\n\n                    NOTE:  For this counter, RELEASE COMPLETE\n                    messages that are a reply to a previous RELEASE\n                    message and contain the same cause value, are\n                    redundant (for counting purposes) and should not\n                    be counted.')
atmSigEmitClgPtyEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitClgPtyEvents.setDescription('Number of Calling Party Events transmitted from this\n                 interface.  This counter monitors error events that\n                 occur due to the originating user doing something\n                 wrong.  This counter is incremented when a RELEASE,\n                 RELEASE COMPLETE (only when not preceded by a RELEASE\n                 message for the same call), ADD PARTY REJECT, or STATUS\n                 message that contains one of the following cause code\n                 values is transmitted (Note: These cause values apply\n                 to both UNI3.0 and UNI3.1):\n\n                 Cause Value     Meaning\n\n                    28     invalid number format (address incomplete)\n                    43     access information discarded\n                    57     bearer capability not authorized\n                    65     bearer capability not implemented\n                    73     unsupported combination of traffic\n                           parameters\n                    78     AAL parameters cannot be supported (UNI3.1\n                           only)\n                    91     invalid transit network selection\n                    93     AAL parameters cannot be supported (UNI3.0\n                           only)\n\n                    NOTE:  For this counter, RELEASE COMPLETE\n                    messages that are a reply to a previous RELEASE\n                    message and contain the same cause value, are\n                    redundant (for counting purposes) and should not\n                    be counted.')
atmSigDetectTimerExpireds = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectTimerExpireds.setDescription("Number of Timer Expiries detected on this interface.\n                 The Timer Expiries Counter provides a count of network\n                 timer expiries, and to some extent, host or switch\n                 timer expiries.  The conditions for incrementing this\n                 counter are:\n                    - Expiry of any network timer\n\n                    - Receipt of a RELEASE or RELEASE COMPLETE\n                      message with Cause #102, 'recovery on\n                      timer expiry'.\n\n                 NOTE:  For this counter, RELEASE COMPLETE messages\n                 that are a reply to a previous RELEASE message and\n                 contain the same cause value, are redundant (for\n                 counting purposes) and should not be counted.")
atmSigEmitTimerExpireds = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitTimerExpireds.setDescription("Number of Timer Expiries transmitted from this\n                 interface.  The Timer Expiries Counter provides a count\n                 of network timer expiries, and to some extent, host or\n                 switch timer expiries.  The conditions for incrementing\n                 this counter are:\n                    - Expiry of any network timer\n\n                    - Receipt of a RELEASE or RELEASE COMPLETE\n                      message with Cause #102, 'recovery on\n                      timer expiry'.\n\n                 NOTE:  For this counter, RELEASE COMPLETE messages\n                 that are a reply to a previous RELEASE message and\n                 contain the same cause value, are redundant (for\n                 counting purposes) and should not be counted.")
atmSigDetectRestarts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigDetectRestarts.setDescription('Number of Restart Activity errors detected on this\n                 interface.  The Restart Activity Counter provides a\n                 count of host, switch, or network restart activity.\n                 This counter is incremented when receiving a RESTART\n                 message.')
atmSigEmitRestarts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigEmitRestarts.setDescription('Number of Restart Activity errors transmitted from\n                 this interface.  The Restart Activity Counter provides\n                 a count of host, switch, or network restart activity.\n                 This counter is incremented when transmitting a RESTART\n                 message.')
atmSigInEstabls = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigInEstabls.setDescription('Number of SVC VCCs established at this signalling\n                 entity for incoming connections.')
atmSigOutEstabls = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSigOutEstabls.setDescription('Number of SVC VCCs established at this signalling\n                 entity for outgoing connections.')
atmSigSupportTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4), )
if mibBuilder.loadTexts: atmSigSupportTable.setDescription('This table contains ATM local interface configuration\n                 parameters, one entry per ATM signalling interface.')
atmSigSupportEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmSigSupportEntry.setDescription('This list contains signalling configuration parameters\n                 and state variables.')
atmSigSupportClgPtyNumDel = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportClgPtyNumDel.setDescription('This object indicates whether the Calling Party Number\n                 Information Element is transferred to the called party\n                 address.  The value of this object can be:\n                   - enabled(1)  This Information Element is transferred\n                                 to the called party\n\n                   - disabled(2) This Information Element is NOT\n                                 transferred to the called party.')
atmSigSupportClgPtySubAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportClgPtySubAddr.setDescription("This object indicates whether to accept and transfer\n                 the Calling Party Subaddress Information Element from\n                 the calling party to the called party.  Calling party\n                 subaddress information shall only be transferred to the\n                 called party if calling party number delivery is\n                 enabled (i.e., atmSigSupportClgPtyNumDel =\n                 'enabled(1)'.  The value of this object can be:\n                   - enabled(1)  This Information Element is transferred\n                                 to the called party\n\n                   - disabled(2) This Information Element is NOT\n                                 transferred to the called party.")
atmSigSupportCldPtySubAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportCldPtySubAddr.setDescription('This object indicates whether to accept, transfer, and\n                 deliver the Called Party Subaddress Information Element\n                 from the calling party to the called party.  The value\n                 of this object can be:\n                   - enabled(1)  This Information Element is transferred\n                                 to the called party\n\n                   - disabled(2) This Information Element is NOT\n                                 transferred to the called party.')
atmSigSupportHiLyrInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportHiLyrInfo.setDescription('This object indicates whether to accept, transfer, and\n                 deliver the Broadband High Layer Information Element\n                 from the calling party to the called party.  The value\n                 of this object can be:\n                   - enabled(1)  This Information Element is transferred\n                                 to the called party\n\n                   - disabled(2) This Information Element is NOT\n                                 transferred to the called party.')
atmSigSupportLoLyrInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportLoLyrInfo.setDescription('This object indicates whether to accept, transfer, and\n                 deliver the Broadband Low Layer Information Element\n                 from the calling party to the called party.  The value\n                 of this object can be:\n                   - enabled(1)  This Information Element is transferred\n                                 to the called party\n\n                   - disabled(2) This Information Element is NOT\n                                 transferred to the called party.')
atmSigSupportBlliRepeatInd = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportBlliRepeatInd.setDescription("This object indicates whether to accept, transfer, and\n                 deliver the Broadband Repeat Indicator with two or\n                 three instances of the Broadband Low Layer Information\n                 Element for low layer information selection from the\n                 calling party to the called party.  This object shall\n                 only be transferred if atmSigSupportLoLyrInfo =\n                 'enabled(1)'.  The value of this object can be:\n                   - enabled(1)  This Information Element is transferred\n                                 to the called party\n\n                   - disabled(2) This Information Element is NOT\n                                 transferred to the called party.")
atmSigSupportAALInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportAALInfo.setDescription('This object indicates whether to accept, transfer, and\n                 deliver the ATM Adaptation Layer Parameters Information\n                 Element from the calling party to the called party.\n                 The value of this object can be:\n                   - enabled(1)  This Information Element is transferred\n                                 to the called party\n\n                   - disabled(2) This Information Element is NOT\n                                 transferred to the called party.')
atmSigSupportPrefCarrier = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 4, 1, 8), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0,0),ValueSizeConstraint(4,4),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSigSupportPrefCarrier.setDescription("This parameter identifies the carrier to which\n                 intercarrier calls originated from this interface are\n                 routed when transit network selection information is\n                 not provided by the calling party.  If a Carrier\n                 Identification Code (CIC) is used the parameter shall\n                 contain the CIC.  For three-digit CICs, the first octet\n                 shall be '0' and the CIC is contained in the three\n                 following octets.  If the preferred carrier feature is\n                 not supported the value is a zero-length string.")
atmSigDescrParamTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5), )
if mibBuilder.loadTexts: atmSigDescrParamTable.setDescription('A table contains signalling capabilities of VCLs\n                      except the Traffic Descriptor.  Traffic\n                      descriptors are described in the\n                      atmTrafficDescrParamTable.')
atmSigDescrParamEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1), ).setIndexNames((0, "ATM2-MIB", "atmSigDescrParamIndex"))
if mibBuilder.loadTexts: atmSigDescrParamEntry.setDescription('Each entry in this table represents a set of\n                      signalling capabilities that can be applied to a\n                      VCL.  There is no requirement for unique entries,\n                      except that the index must be unique.  Objects\n                      atmSigDescrParamRowStatus is required during\n                      creation.')
atmSigDescrParamIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 1), AtmSigDescrParamIndex())
if mibBuilder.loadTexts: atmSigDescrParamIndex.setDescription('The value of this object is used by the\n                      atmVclGenSigDescrIndex object in the\n                      atmVclGenTable to identify a row in this table.')
atmSigDescrParamAalType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6,))).clone(namedValues=NamedValues(("other", 1), ("aal1", 2), ("aal34", 3), ("aal5", 4), ("userDefined", 5), ("aal2", 6),)).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamAalType.setDescription('The AAL type.  The value of this object is set to\n                      other(1) when not defined.')
atmSigDescrParamAalSscsType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("other", 1), ("assured", 2), ("nonassured", 3), ("frameRelay", 4), ("null", 5),)).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamAalSscsType.setDescription('The SSCS type used by this entry.')
atmSigDescrParamBhliType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("other", 1), ("iso", 2), ("user", 3), ("hiProfile", 4), ("vendorSpecific", 5),)).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBhliType.setDescription('The Broadband high layer type.')
atmSigDescrParamBhliInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0,8)).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBhliInfo.setDescription('The Broadband high layer information.  When\n                      atmSigDescrParamBhliType is set to iso(2), the\n                      value of this object is a zero length string.\n                      When atmSigDescrParamBhliType is set to user(3),\n                      the value of this object is an octet string with\n                      length ranging from 0 to 8.  When\n                      atmSigDescrParamBhliType is set to hiProfile(4),\n                      the value of this object is a length of 4 octet\n                      string containing user to user profile identifier.\n                      When atmSigDescrParamBhliType is set to\n                      vendorSpecific(5), the value of this object is a\n                      length of 7 octet string, where the most\n                      significant 3 octets consist of a globally-\n                      administered OUI, and the least significant 4\n                      octets are the vender administered application\n                      OUI.')
atmSigDescrParamBbcConnConf = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("ptp", 1), ("ptmp", 2),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBbcConnConf.setDescription('The Broadband bearer capability user plane\n                      connection configuration parameter.')
atmSigDescrParamBlliLayer2 = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,))).clone(namedValues=NamedValues(("other", 1), ("iso1745", 2), ("q921", 3), ("x25linklayer", 4), ("x25multilink", 5), ("lapb", 6), ("hdlcArm", 7), ("hdlcNrm", 8), ("hdlcAbm", 9), ("iso88022", 10), ("x75slp", 11), ("q922", 12), ("userDef", 13), ("iso7776", 14),)).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBlliLayer2.setDescription('The Broadband low layer information, protocol\n                      type of layer 2.  The value of this object is\n                      other(1) if layer 2 protocol is not used.')
atmSigDescrParamBlliLayer3 = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8,))).clone(namedValues=NamedValues(("other", 1), ("x25pkt", 2), ("isoiec8208", 3), ("x223iso8878", 4), ("isoiec8473", 5), ("t70", 6), ("tr9577", 7), ("userDef", 8),)).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBlliLayer3.setDescription('The Broadband low layer information, protocol\n                      type of layer 3.  The value of this object is\n                      other(1) if layer 3 protocol is not used.')
atmSigDescrParamBlliPktSize = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10,))).clone(namedValues=NamedValues(("other", 1), ("s16", 2), ("s32", 3), ("s64", 4), ("s128", 5), ("s256", 6), ("s512", 7), ("s1024", 8), ("s2048", 9), ("s4096", 10),)).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBlliPktSize.setDescription('The default packet size defined in B-LLI.')
atmSigDescrParamBlliSnapId = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("other", 1), ("true", 2), ("false", 3),)).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBlliSnapId.setDescription('The SNAP ID used for Broadband low layer protocol\n                      layer 3.  The value of this object is other(1) if\n                      atmSigDescrParamBlliLayer3 is set to other(1).')
atmSigDescrParamBlliOuiPid = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 11), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0,0),ValueSizeConstraint(5,5),)).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamBlliOuiPid.setDescription('The OUI/PID encoding for Broadband low layer\n                      protocol layer 3.  The value of this object is a\n                      zero length string if atmSigDescrParamBlliLayer3\n                      is set to other(1).  When used, it is always 5\n                      octets with the most significant octet as the OUI\n                      Octet 1 and the least significant octet as the PID\n                      Octet 2.')
atmSigDescrParamRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 5, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSigDescrParamRowStatus.setDescription('This object is used to create and delete rows in\n                      the atmSigDescrParamTable.')
atmIfRegisteredAddrTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6), )
if mibBuilder.loadTexts: atmIfRegisteredAddrTable.setDescription('This table contains a list of ATM addresses that can\n                 be used for calls to and from a given interface by a\n                 switch or service.  The ATM addresses are either\n                 registered by the endsystem via ILMI or statically\n                 configured.  This table does not expose PNNI\n                 reachability information.  ILMI registered addresses\n                 cannot be deleted using this table.  This table only\n                 applies to switches and network services.')
atmIfRegisteredAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM2-MIB", "atmIfRegAddrAddress"))
if mibBuilder.loadTexts: atmIfRegisteredAddrEntry.setDescription('An entry in the ATM Interface Registered Address\n                 table.')
atmIfRegAddrAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6, 1, 1), AtmAddr())
if mibBuilder.loadTexts: atmIfRegAddrAddress.setDescription('An address registered for a given switch or service\n                 interface.')
atmIfRegAddrAddressSource = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("other", 1), ("static", 2), ("dynamic", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfRegAddrAddressSource.setDescription('The type of address source for a given ATM Address.\n                 The value dynamic(3) is indicated when ILMI is used.')
atmIfRegAddrOrgScope = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,))).clone(namedValues=NamedValues(("localNetwork", 1), ("localNetworkPlusOne", 2), ("localNetworkPlusTwo", 3), ("siteMinusOne", 4), ("intraSite", 5), ("sitePlusOne", 6), ("organizationMinusOne", 7), ("intraOrganization", 8), ("organizationPlusOne", 9), ("communityMinusOne", 10), ("intraCommunity", 11), ("communityPlusOne", 12), ("regional", 13), ("interRegional", 14), ("global", 15),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIfRegAddrOrgScope.setDescription('This object indicates the organizational scope for\n                  the referenced address.  The information of the\n                  referenced address shall not be distributed outside\n                  the indicated scope.   Refer to Annex 5.3 of ATM\n                  Forum UNI Signalling 4.0 for guidelines regarding\n                  the use of organizational scopes.\n\n                  This value cannot be configured for ILMI-registered\n                  addresses.\n\n                  The default values for organizational scope are\n                  localNetwork(1) for ATM group addresses, and\n                  global(15) for individual addresses.')
atmIfRegAddrRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 6, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIfRegAddrRowStatus.setDescription('This object is used to create and delete rows in the\n                 atmIfRegisteredAddrTable.  Rows created dynamically\n                 (e.g., ILMI-registered addresses) cannot be deleted\n                 using this object.')
atmVclAddrTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 7), )
if mibBuilder.loadTexts: atmVclAddrTable.setDescription('This table provides a mapping between the\n                      atmVclTable and the ATM called party/calling party\n                      address.  This table can be used to retrieve the\n                      calling party and called party ATM address pair\n                      for a given VCL.  Note that there can be more than\n                      one pair of calling party and called party ATM\n                      addresses for a VCL in a point to multi-point\n                      call.')
atmVclAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"), (0, "ATM2-MIB", "atmVclAddrAddr"))
if mibBuilder.loadTexts: atmVclAddrEntry.setDescription('Each entry in this table represents a binding\n                      between a VCL and an ATM address associated with\n                      this call.  This ATM address can be either the\n                      called party address or the calling party address.\n                      There can be more than one pair of calling/called\n                      party ATM addresses associated with the VCL entry\n                      for point to multi-point calls.  Objects\n                      atmVclAddrAddr, atmVclAddrType, and\n                      atmVclAddrRowStatus are required during row\n                      creation.')
atmVclAddrAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 7, 1, 1), AtmAddr())
if mibBuilder.loadTexts: atmVclAddrAddr.setDescription('An ATM address on one end of the VCL.  For SVCs,\n                      the agent supplies the value of this object at\n                      creation time.  For PVCs, the manager can supply\n                      the value of this object during or after the PVC\n                      creation.')
atmVclAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("callingParty", 1), ("calledParty", 2),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVclAddrType.setDescription('The type of ATM Address represented by the object\n                      atmVclAddrAddr.  Choices are either the calling\n                      party ATM address or the called party ATM\n                      address.')
atmVclAddrRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 7, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVclAddrRowStatus.setDescription('This object is used to create or destroy an entry\n                      from this table.')
atmAddrVclTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8), )
if mibBuilder.loadTexts: atmAddrVclTable.setDescription('This table provides an alternative way to\n                      retrieve the atmVclTable.  This table can be used\n                      to retrieve the indexing to the atmVclTable by an\n                      ATM address.')
atmAddrVclEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8, 1), ).setIndexNames((0, "ATM2-MIB", "atmVclAddrAddr"), (0, "ATM2-MIB", "atmAddrVclAtmIfIndex"), (0, "ATM2-MIB", "atmAddrVclVpi"), (0, "ATM2-MIB", "atmAddrVclVci"))
if mibBuilder.loadTexts: atmAddrVclEntry.setDescription('Each entry in this table represents an entry in\n                      the atmVclTable of the ATM-MIB by its ATM address.\n                      The ATM address is either the calling or called\n                      party ATM address of the call.  Entries in this\n                      table are read only.  They show up when entries\n                      are created in the atmVclAddrTable.')
atmAddrVclAtmIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: atmAddrVclAtmIfIndex.setDescription('The interface index of the ATM interface to which\n                      this VCL pertains.  This object combined with the\n                      atmAddrVclVpi and atmAddrVclVci objects serves as\n                      an index to the atmVclTable.')
atmAddrVclVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8, 1, 2), AtmVpIdentifier())
if mibBuilder.loadTexts: atmAddrVclVpi.setDescription('The VPI value of the VCL.  This object combined\n                      with the atmAddrVclAtmIfIndex and atmAddrVclVci\n                      objects serves as an index to the atmVclTable.')
atmAddrVclVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8, 1, 3), AtmVcIdentifier())
if mibBuilder.loadTexts: atmAddrVclVci.setDescription('The VCI value of the VCL.  This object combined\n                      with the atmAddrVclAtmIfIndex and atmAddrVclVpi\n                      objects serves as an index to the atmVclTable.')
atmAddrVclAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("callingParty", 1), ("calledParty", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAddrVclAddrType.setDescription('The type of ATM Address represented by the object\n                      atmVclAddrAddr.  Choices are either calling party\n                      address or called party address.')
atmVplStatTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9), )
if mibBuilder.loadTexts: atmVplStatTable.setDescription('This table contains all statistics counters per\n                      VPL.  It is used to monitor the usage of the VPL\n                      in terms of incoming cells and outgoing cells.')
atmVplStatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVplVpi"))
if mibBuilder.loadTexts: atmVplStatEntry.setDescription('Each entry in this table represents a VPL.')
atmVplStatTotalCellIns = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatTotalCellIns.setDescription('The total number of valid ATM cells received by\n                      this VPL including both CLP=0 and CLP=1 cells.\n                      The cells are counted prior to the application of\n                      the traffic policing.')
atmVplStatClp0CellIns = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatClp0CellIns.setDescription('The number of valid ATM cells received by this\n                      VPL with CLP=0.  The cells are counted prior to\n                      the application of the traffic policing.')
atmVplStatTotalDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatTotalDiscards.setDescription('The total number of valid ATM cells discarded by\n                      the traffic policing entity.  This includes cells\n                      originally received with CLP=0 and CLP=1.')
atmVplStatClp0Discards = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatClp0Discards.setDescription('The total number of valid ATM cells received with\n                      CLP=0 and discarded by the traffic policing\n                      entity.')
atmVplStatTotalCellOuts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatTotalCellOuts.setDescription('The total number of valid ATM cells transmitted\n                      by this VPL.  This includes both CLP=0 and CLP=1\n                      cells.')
atmVplStatClp0CellOuts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatClp0CellOuts.setDescription('The total number of valid ATM cells transmitted\n                      with CLP=0 by this VPL.')
atmVplStatTaggedOuts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 9, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplStatTaggedOuts.setDescription('The total number of valid ATM cells tagged by the\n                      traffic policing entity from CLP=0 to CLP=1 and\n                      transmitted by this VPL.')
atmVplLogicalPortTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 10), )
if mibBuilder.loadTexts: atmVplLogicalPortTable.setDescription('Indicates whether the VPL is an ATM Logical Port\n                      interface (ifType=80).')
atmVplLogicalPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 10, 1), )
atmVplEntry.registerAugmentions(("ATM2-MIB", "atmVplLogicalPortEntry"))
atmVplLogicalPortEntry.setIndexNames(*atmVplEntry.getIndexNames())
if mibBuilder.loadTexts: atmVplLogicalPortEntry.setDescription('An entry with information about the ATM Logical\n                      Port interface.')
atmVplLogicalPortDef = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("notLogicalIf", 1), ("isLogicalIf", 2),)).clone('notLogicalIf')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVplLogicalPortDef.setDescription('Indicates whether the VPC at this VPL interface\n                      is an ATM Logical Port interface.')
atmVplLogicalPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 10, 1, 2), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplLogicalPortIndex.setDescription('The ifTable index of the ATM logical port\n                      interface associated with this VPL. The\n                      distinguished value of zero indicates that the\n                      agent has not (yet) assigned such an ifTable\n                      Index. The zero value must be assigned by the\n                      agent if the value of atmVplLogicalPortDef is set\n                      to notLogicalIf, or if the VPL row is not active.')
atmVclStatTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11), )
if mibBuilder.loadTexts: atmVclStatTable.setDescription('This table contains all statistics counters per\n                      VCL.  It is used to monitor the usage of the VCL\n                      in terms of incoming cells and outgoing cells.')
atmVclStatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"))
if mibBuilder.loadTexts: atmVclStatEntry.setDescription('Each entry in this table represents a VCL.')
atmVclStatTotalCellIns = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatTotalCellIns.setDescription('The total number of valid ATM cells received by\n                      this VCL including both CLP=0 and CLP=1 cells.\n                      The cells are counted prior to the application of\n                      the traffic policing.')
atmVclStatClp0CellIns = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatClp0CellIns.setDescription('The number of valid ATM cells received by this\n                      VCL with CLP=0.  The cells are counted prior to\n                      the application of the traffic policing.')
atmVclStatTotalDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatTotalDiscards.setDescription('The total number of valid ATM cells discarded by\n                      the traffic policing entity.  This includes cells\n                      originally received with CLP=0 and CLP=1.')
atmVclStatClp0Discards = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatClp0Discards.setDescription('The total number of valid ATM cells received with\n                      CLP=0 and discarded by the traffic policing\n                      entity.')
atmVclStatTotalCellOuts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatTotalCellOuts.setDescription('The total number of valid ATM cells transmitted\n                      by this VCL.  This includes both CLP=0 and CLP=1\n                      cells.')
atmVclStatClp0CellOuts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatClp0CellOuts.setDescription('The total number of valid ATM cells transmitted\n                      with CLP=0 by this VCL.')
atmVclStatTaggedOuts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclStatTaggedOuts.setDescription('The total number of valid ATM cells tagged by the\n                      traffic policing entity from CLP=0 to CLP=1 and\n                      transmitted by this VCL.')
atmAal5VclStatTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12), )
if mibBuilder.loadTexts: atmAal5VclStatTable.setDescription('This table provides a collection of objects\n                      providing AAL5 configuration and performance\n                      statistics of a VCL.')
atmAal5VclStatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"))
if mibBuilder.loadTexts: atmAal5VclStatEntry.setDescription('Each entry in this table represents an AAL5 VCL,\n                      and is indexed by ifIndex values of AAL5\n                      interfaces and the associated VPI/VCI values.')
atmAal5VclInPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAal5VclInPkts.setDescription('The number of AAL5 CPCS PDUs received on the AAL5\n                      VCC at the interface identified by the ifIndex.')
atmAal5VclOutPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAal5VclOutPkts.setDescription('The number of AAL5 CPCS PDUs transmitted on the\n                      AAL5 VCC at the interface identified by the\n                      ifIndex.')
atmAal5VclInOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAal5VclInOctets.setDescription('The number of octets contained in AAL5 CPCS PDUs\n                      received on the AAL5 VCC at the interface\n                      identified by the ifIndex.')
atmAal5VclOutOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmAal5VclOutOctets.setDescription('The number of octets contained in AAL5 CPCS PDUs\n                      transmitted on the AAL5 VCC at the interface\n                      identified by the ifIndex.')
atmVclGenTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 13), )
if mibBuilder.loadTexts: atmVclGenTable.setDescription('General Information for each VC.')
atmVclGenEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 13, 1), )
atmVclEntry.registerAugmentions(("ATM2-MIB", "atmVclGenEntry"))
atmVclGenEntry.setIndexNames(*atmVclEntry.getIndexNames())
if mibBuilder.loadTexts: atmVclGenEntry.setDescription('An entry with general information about the ATM\n                      VC.')
atmVclGenSigDescrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 13, 1, 1), AtmSigDescrParamIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVclGenSigDescrIndex.setDescription('The value of this object identifies the row in\n                      the ATM Signalling Descriptor Parameter Table\n                      which applies to this VCL.')
atmInterfaceExtTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14), )
if mibBuilder.loadTexts: atmInterfaceExtTable.setDescription('This table contains ATM interface configuration and\n                 monitoring information not defined in the\n                 atmInterfaceConfTable from the ATM-MIB.  This includes\n                 the type of connection setup procedures, ILMI\n                 information, and information on the VPI/VCI range.')
atmInterfaceExtEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1), )
atmInterfaceConfEntry.registerAugmentions(("ATM2-MIB", "atmInterfaceExtEntry"))
atmInterfaceExtEntry.setIndexNames(*atmInterfaceConfEntry.getIndexNames())
if mibBuilder.loadTexts: atmInterfaceExtEntry.setDescription('An entry extends the atmInterfaceConfEntry defined in\n                 the ATM-MIB.  Each entry corresponds to an ATM\n                 interface.')
atmIntfConfigType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 1), AtmInterfaceType().clone('autoConfig')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfConfigType.setDescription("The type of connection setup procedures configured for\n                 the ATM interface.  Setting this variable to a value of\n                 'other' is not allowed.")
atmIntfActualType = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 2), AtmInterfaceType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfActualType.setDescription("The type of connection setup procedures currently\n                 being used on the interface.  This may reflect a\n                 manually configured value for the interface type, or\n                 may be determined by other means such as auto-\n                 configuration.  A value of `autoConfig' indicates that\n                 auto-configuration was requested but has not yet been\n                 completed.")
atmIntfConfigSide = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("other", 1), ("user", 2), ("network", 3),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfConfigSide.setDescription("The configured role of the managed entity as one side\n                 of the ATM interface.  This value does not apply when\n                 the object atmIntfConfigType is set to `autoConfig',\n                 `atmfPnni1Dot0', or `atmfBici2Dot0'.")
atmIntfActualSide = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4,))).clone(namedValues=NamedValues(("other", 1), ("user", 2), ("network", 3), ("symmetric", 4),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfActualSide.setDescription('The current role used by the managed entity to\n                 represent one side of the ATM interface.')
atmIntfIlmiAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 5), Bits().clone(namedValues=NamedValues(("ilmi", 0), ("ilmiAddressRegistration", 1), ("ilmiConnectivity", 2), ("ilmiPvcPvpMgmt", 3), ("ilmiSigVccParamNegotiation", 4),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfIlmiAdminStatus.setDescription("Indicates which components of ILMI are\n                 administratively enabled on this interface.  If the\n                 'ilmi' bit is not set, then no ILMI components are\n                 operational.  ILMI components other than auto-\n                 configuration that are not represented in the value\n                 have their administrative status determined according\n                 to the 'ilmi' bit.  The ILMI auto-configuration\n                 component is enabled/disabled by the atmIntfConfigType\n                 object.")
atmIntfIlmiOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 6), Bits().clone(namedValues=NamedValues(("ilmi", 0), ("ilmiAddressRegistration", 1), ("ilmiConnectivity", 2), ("ilmiPvcPvpMgmt", 3), ("ilmiSigVccParamNegotiation", 4),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfIlmiOperStatus.setDescription('Indicates which components of ILMI are operational on\n                 this interface.')
atmIntfIlmiFsmState = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9,))).clone(namedValues=NamedValues(("stopped", 1), ("linkFailing", 2), ("establishing", 3), ("configuring", 4), ("retrievingNetworkPrefixes", 5), ("registeringNetworkPrefixes", 6), ("retrievingAddresses", 7), ("registeringAddresses", 8), ("verifying", 9),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfIlmiFsmState.setDescription('Indicates the state of the ILMI Finite State Machine\n                 associated with this interface.')
atmIntfIlmiEstablishConPollIntvl = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535)).clone(1)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfIlmiEstablishConPollIntvl.setDescription('The amount of time S between successive transmissions\n                 of ILMI messages on this interface for the purpose of\n                 detecting establishment of ILMI connectivity.')
atmIntfIlmiCheckConPollIntvl = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,65535)).clone(5)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfIlmiCheckConPollIntvl.setDescription('The amount of time T between successive transmissions\n                 of ILMI messages on this interface for the purpose of\n                 detecting loss of ILMI connectivity.  The distinguished\n                 value zero disables ILMI connectivity procedures on\n                 this interface.')
atmIntfIlmiConPollInactFactor = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,65535)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfIlmiConPollInactFactor.setDescription('The number K of consecutive polls on this interface\n                 for which no ILMI response message is received before\n                 ILMI connectivity is declared lost.')
atmIntfIlmiPublicPrivateIndctr = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("other", 1), ("public", 2), ("private", 3),)).clone('private')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfIlmiPublicPrivateIndctr.setDescription("Specifies whether this end of the interface is\n                 advertised in ILMI as a device of the `public' or\n                 `private' type.")
atmInterfaceConfMaxSvpcVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceConfMaxSvpcVpi.setDescription('The maximum VPI that the signalling stack on the ATM\n                 interface is configured to support for allocation to\n                 switched virtual path connections.')
atmInterfaceCurrentMaxSvpcVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceCurrentMaxSvpcVpi.setDescription("The maximum VPI that the signalling stack on the ATM\n                 interface may currently allocate to switched virtual\n                 path connections.  This value is the minimum of\n                 atmInterfaceConfMaxSvpcVpi, and the\n                 atmInterfaceMaxSvpcVpi of the interface's UNI/NNI peer.\n\n                 If the interface does not negotiate with its peer to\n                 determine the maximum VPI that can be allocated to\n                 SVPCs on the interface, then the value of this object\n                 must equal atmInterfaceConfMaxSvpcVpi. ")
atmInterfaceConfMaxSvccVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceConfMaxSvccVpi.setDescription('The maximum VPI that the signalling stack on the ATM\n                 interface is configured to support for allocation to\n                 switched virtual channel connections.')
atmInterfaceCurrentMaxSvccVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceCurrentMaxSvccVpi.setDescription("The maximum VPI that the signalling stack on the ATM\n                 interface may currently allocate to switched virtual\n                 channel connections.  This value is the minimum of\n                 atmInterfaceConfMaxSvccVpi, and the\n                 atmInterfaceConfMaxSvccVpi of the interface's UNI/NNI\n                 peer.\n\n                 If the interface does not negotiate with its peer to\n                 determine the maximum VPI that can be allocated to\n                 SVCCs on the interface, then the value of this object\n                 must equal atmInterfaceConfMaxSvccVpi.")
atmInterfaceConfMinSvccVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceConfMinSvccVci.setDescription('The minimum VCI that the signalling stack on the ATM\n                 interface is configured to support for allocation to\n                 switched virtual channel connections.')
atmInterfaceCurrentMinSvccVci = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceCurrentMinSvccVci.setDescription("The minimum VCI that the signalling stack on the ATM\n                 interface may currently allocate to switched virtual\n                 channel connections.  This value is the maximum of\n                 atmInterfaceConfMinSvccVci, and the\n                 atmInterfaceConfMinSvccVci of the interface's UNI/NNI\n                 peer.\n\n                 If the interface does not negotiate with its peer to\n                 determine the minimum VCI that can be allocated to\n                 SVCCs on the interface, then the value of this object\n                 must equal atmInterfaceConfMinSvccVci.")
atmIntfSigVccRxTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 18), AtmTrafficDescrParamIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfSigVccRxTrafficDescrIndex.setDescription('This object identifies the row in the\n                 atmTrafficDescrParamTable used during ILMI auto-\n                 configuration to specify the advertised signalling VCC\n                 traffic parameters for the receive direction.\n\n                 The traffic descriptor resulting from ILMI auto-\n                 configuration of the signalling VCC is indicated in the\n                 atmVclTable.')
atmIntfSigVccTxTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 19), AtmTrafficDescrParamIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfSigVccTxTrafficDescrIndex.setDescription('This object identifies the row in the\n                 atmTrafficDescrParamTable used during ILMI auto-\n                 configuration to specify the advertised signalling VCC\n                 traffic parameters for the transmit direction.\n\n                 The traffic descriptor resulting from ILMI auto-\n                 configuration of the signalling VCC is indicated in the\n                 atmVclTable.')
atmIntfPvcFailures = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfPvcFailures.setDescription('The number of times the operational status of a PVPL\n                 or PVCL on this interface has gone down.')
atmIntfCurrentlyFailingPVpls = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfCurrentlyFailingPVpls.setDescription("The current number of VPLs on this interface for which\n                 there is an active row in the atmVplTable having an\n                 atmVplConnKind value of `pvc' and an atmVplOperStatus\n                 with a value other than `up'.")
atmIntfCurrentlyFailingPVcls = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIntfCurrentlyFailingPVcls.setDescription("The current number of VCLs on this interface for which\n                 there is an active row in the atmVclTable having an\n                 atmVclConnKind value of `pvc' and an atmVclOperStatus\n                 with a value other than `up'.")
atmIntfPvcFailuresTrapEnable = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 23), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfPvcFailuresTrapEnable.setDescription('Allows the generation of traps in response to PVCL or\n                 PVPL failures on this interface.')
atmIntfPvcNotificationInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 14, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,3600)).clone(30)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIntfPvcNotificationInterval.setDescription('The minimum interval between the sending of\n                 atmIntfPvcFailuresTrap notifications for this\n                 interface.')
atmIlmiSrvcRegTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15), )
if mibBuilder.loadTexts: atmIlmiSrvcRegTable.setDescription('This table contains a list of all the ATM network\n                 services known by this device.\n\n                 The characteristics of these services are made\n                 available through the ILMI, using the ILMI general-\n                 purpose service registry MIB.\n\n                 These services may be made available to all ATM\n                 interfaces (atmIlmiSrvcRegIndex = 0) or to some\n                 specific ATM interfaces only (atmIlmiSrvcRegIndex = ATM\n                 interface index).')
atmIlmiSrvcRegEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1), ).setIndexNames((0, "ATM2-MIB", "atmIlmiSrvcRegIndex"), (0, "ATM2-MIB", "atmIlmiSrvcRegServiceID"), (0, "ATM2-MIB", "atmIlmiSrvcRegAddressIndex"))
if mibBuilder.loadTexts: atmIlmiSrvcRegEntry.setDescription('Information about a single service provider that is\n                 available to the user-side of an adjacent device\n                 through the ILMI.')
atmIlmiSrvcRegIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: atmIlmiSrvcRegIndex.setDescription('The ATM interface where the service defined in this\n                 entry can be made available to an ATM device attached\n                 to this interface.\n\n                 The value of 0 has a special meaning: when an ATM\n                 service is defined in an entry whose\n                 atmIlmiSrvcRegIndex is zero, the ATM service is\n                 available to ATM devices connected to any ATM\n                 interface.  (default value(s)).\n\n                 When the user-side of an adjacent device queries the\n                 content of the ILMI service registry MIB (using the\n                 ILMI protocol), the local network-side responds with\n                 the ATM services defined in atmIlmiSrvcRegTable\n                 entries, provided that these entries are indexed by:\n                 - the corresponding ifIndex value (atmIlmiSrvcRegIndex\n                   equal to the ifIndex of the interface to which the\n                   adjacent device is connected)\n                 - zero (atmIlmiSrvcRegIndex=0).')
atmIlmiSrvcRegServiceID = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 2), ObjectIdentifier())
if mibBuilder.loadTexts: atmIlmiSrvcRegServiceID.setDescription('This is the service identifier which uniquely\n                 identifies the type of service at the address provided\n                 in the table.  The object identifiers for the LAN\n                 Emulation Configuration Server (LECS) and the ATM Name\n                 Server (ANS) are defined in the ATM Forum ILMI Service\n                 Registry MIB.  The object identifiers for the ATMARP\n                 Server, the Multicast Address Resolution Server (MARS),\n                 and the NHRP Server (NHS) are defined in RFC 2601, RFC\n                 2602, and RFC 2603, respectively.')
atmIlmiSrvcRegAddressIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647)))
if mibBuilder.loadTexts: atmIlmiSrvcRegAddressIndex.setDescription('An arbitrary integer to differentiate multiple rows\n                 containing different ATM addresses for the same service\n                 on the same interface.  This number need NOT be the\n                 same as the corresponding ILMI atmfSrvcRegAddressIndex\n                 MIB object.')
atmIlmiSrvcRegATMAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 4), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIlmiSrvcRegATMAddress.setDescription('This is the full address of the service.  The user-\n                 side of the adjacent device may use this address to\n                 establish a connection with the service.')
atmIlmiSrvcRegParm1 = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1,255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIlmiSrvcRegParm1.setDescription('An octet string used according to the value of\n                 atmIlmiSrvcRegServiceID.')
atmIlmiSrvcRegRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 15, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIlmiSrvcRegRowStatus.setDescription('This object is used to create or destroy an entry from\n                 this table.')
atmIlmiNetworkPrefixTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 16), )
if mibBuilder.loadTexts: atmIlmiNetworkPrefixTable.setDescription('A table specifying per-interface network prefix(es)\n                 supplied by the network side of the UNI during ILMI\n                 address registration.  When no network prefixes are\n                 specified for a particular interface, one or more\n                 network prefixes based on the switch address(es) may be\n                 used for ILMI address registration.')
atmIlmiNetworkPrefixEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 16, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM2-MIB", "atmIlmiNetPrefixPrefix"))
if mibBuilder.loadTexts: atmIlmiNetworkPrefixEntry.setDescription('Information about a single network prefix supplied by\n                 the network side of the UNI during ILMI address\n                 registration.  Note that the index variable\n                 atmIlmiNetPrefixPrefix is a variable-length string, and\n                 as such the rule for variable-length strings in section\n                 7.7 of RFC 2578 applies.')
atmIlmiNetPrefixPrefix = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 16, 1, 1), AtmIlmiNetworkPrefix())
if mibBuilder.loadTexts: atmIlmiNetPrefixPrefix.setDescription('The network prefix specified for use in ILMI address\n                 registration.')
atmIlmiNetPrefixRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 16, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmIlmiNetPrefixRowStatus.setDescription('Used to create, delete, activate and de-activate\n                 network prefixes used in ILMI address registration.')
atmSwitchAddressTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 17), )
if mibBuilder.loadTexts: atmSwitchAddressTable.setDescription('This table contains one or more ATM endsystem\n                 addresses on a per-switch basis.  These addresses are\n                 used to identify the switch.  When no ILMI network\n                 prefixes are configured for certain interfaces, network\n                 prefixes based on the switch address(es) may be used\n                 for ILMI address registration.')
atmSwitchAddressEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 17, 1), ).setIndexNames((0, "ATM2-MIB", "atmSwitchAddressIndex"))
if mibBuilder.loadTexts: atmSwitchAddressEntry.setDescription('An entry in the ATM Switch Address table.')
atmSwitchAddressIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 17, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535)))
if mibBuilder.loadTexts: atmSwitchAddressIndex.setDescription('An arbitrary index used to enumerate the ATM endsystem\n                 addresses for this switch.')
atmSwitchAddressAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 17, 1, 2), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(13,13),ValueSizeConstraint(20,20),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSwitchAddressAddress.setDescription('An ATM endsystem address or address prefix used to\n                 identify this switch.  When no ESI or SEL field is\n                 specified, the switch may generate the ESI and SEL\n                 fields automatically to obtain a complete 20-byte ATM\n                 endsystem address.')
atmSwitchAddressRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 17, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSwitchAddressRowStatus.setDescription('Used to create, delete, activate, and de-activate\n                 addresses used to identify this switch.')
atmVpCrossConnectXTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 18), )
if mibBuilder.loadTexts: atmVpCrossConnectXTable.setDescription('This table contains one row per VP Cross-Connect\n                 represented in the atmVpCrossConnectTable.')
atmVpCrossConnectXEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 18, 1), )
atmVpCrossConnectEntry.registerAugmentions(("ATM2-MIB", "atmVpCrossConnectXEntry"))
atmVpCrossConnectXEntry.setIndexNames(*atmVpCrossConnectEntry.getIndexNames())
if mibBuilder.loadTexts: atmVpCrossConnectXEntry.setDescription('Information about a particular ATM VP Cross-Connect.\n\n                 Each entry provides an two objects that name the\n                 Cross-Connect.  One is assigned by the Service User and\n                 the other by the Service Provider.')
atmVpCrossConnectUserName = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 18, 1, 1), DisplayString().subtype(subtypeSpec=ValueRangeConstraint(0,255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVpCrossConnectUserName.setDescription('This is a service user assigned textual representation\n                 of a VPC PVC.')
atmVpCrossConnectProviderName = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 18, 1, 2), DisplayString().subtype(subtypeSpec=ValueRangeConstraint(0,255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCrossConnectProviderName.setDescription('This is a system supplied textual representation of\n                 VPC PVC.  It is assigned by the service provider.')
atmVcCrossConnectXTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 19), )
if mibBuilder.loadTexts: atmVcCrossConnectXTable.setDescription('This table contains one row per VC Cross-Connect\n                 represented in the atmVcCrossConnectTable.')
atmVcCrossConnectXEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 19, 1), )
atmVcCrossConnectEntry.registerAugmentions(("ATM2-MIB", "atmVcCrossConnectXEntry"))
atmVcCrossConnectXEntry.setIndexNames(*atmVcCrossConnectEntry.getIndexNames())
if mibBuilder.loadTexts: atmVcCrossConnectXEntry.setDescription('Information about a particular ATM VC Cross-Connect.\n\n                 Each entry provides an two objects that name the\n                 Cross-Connect.  One is assigned by the Service User and\n                 the other by the Service Provider.')
atmVcCrossConnectUserName = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 19, 1, 1), DisplayString().subtype(subtypeSpec=ValueRangeConstraint(0,255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVcCrossConnectUserName.setDescription('This is a service user assigned textual representation\n                 of a VCC PVC.')
atmVcCrossConnectProviderName = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 19, 1, 2), DisplayString().subtype(subtypeSpec=ValueRangeConstraint(0,255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCrossConnectProviderName.setDescription('This is a system supplied textual representation of\n                 VCC PVC.  It is assigned by the service provider.')
atmCurrentlyFailingPVplTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 20), )
if mibBuilder.loadTexts: atmCurrentlyFailingPVplTable.setDescription("A table indicating all VPLs for which there is an\n                 active row in the atmVplTable having an atmVplConnKind\n                 value of `pvc' and an atmVplOperStatus with a value\n                 other than `up'.")
atmCurrentlyFailingPVplEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 20, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVplVpi"))
if mibBuilder.loadTexts: atmCurrentlyFailingPVplEntry.setDescription("Each entry in this table represents a VPL for which\n                 the atmVplRowStatus is `active', the atmVplConnKind is\n                 `pvc', and the atmVplOperStatus is other than `up'.")
atmCurrentlyFailingPVplTimeStamp = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 20, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCurrentlyFailingPVplTimeStamp.setDescription('The time at which this PVPL began to fail.')
atmCurrentlyFailingPVclTable = MibTable((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 21), )
if mibBuilder.loadTexts: atmCurrentlyFailingPVclTable.setDescription("A table indicating all VCLs for which there is an\n                 active row in the atmVclTable having an atmVclConnKind\n                 value of `pvc' and an atmVclOperStatus with a value\n                 other than `up'.")
atmCurrentlyFailingPVclEntry = MibTableRow((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 21, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"))
if mibBuilder.loadTexts: atmCurrentlyFailingPVclEntry.setDescription("Each entry in this table represents a VCL for which\n                 the atmVclRowStatus is `active', the atmVclConnKind is\n                 `pvc', and the atmVclOperStatus is other than `up'.")
atmCurrentlyFailingPVclTimeStamp = MibTableColumn((1, 3, 6, 1, 2, 1, 37, 1, 14, 1, 21, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCurrentlyFailingPVclTimeStamp.setDescription('The time at which this PVCL began to fail.')
atmPvcTraps = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 2, 1))
atmPvcTrapsPrefix = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 2, 1, 0))
atmIntfPvcFailuresTrap = NotificationType((1, 3, 6, 1, 2, 1, 37, 1, 14, 2, 1, 0, 1)).setObjects(*(("ATM2-MIB", "ifIndex"), ("ATM2-MIB", "atmIntfPvcFailures"), ("ATM2-MIB", "atmIntfCurrentlyFailingPVpls"), ("ATM2-MIB", "atmIntfCurrentlyFailingPVcls"),))
if mibBuilder.loadTexts: atmIntfPvcFailuresTrap.setDescription('A notification indicating that one or more PVPLs or\n                 PVCLs on this interface has failed since the last\n                 atmPvcFailuresTrap was sent.  If this trap has not been\n                 sent for the last atmIntfPvcNotificationInterval, then\n                 it will be sent on the next increment of\n                 atmIntfPvcFailures.')
atm2MIBConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 3))
atm2MIBGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1))
atm2MIBCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 2))
atm2MIBCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 2, 1)).setObjects(*(("ATM2-MIB", "atmSwitchServcHostGroup"),))
if mibBuilder.loadTexts: atm2MIBCompliance.setDescription('The compliance statement for SNMP entities which\n                 represent ATM interfaces.  The compliance statements\n                 are used to determine if a particular group or object\n                 applies to hosts, networks/switches, or both.')
atmSwitchServcHostGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 1)).setObjects(*(("ATM2-MIB", "atmSigSSCOPConEvents"), ("ATM2-MIB", "atmSigSSCOPErrdPdus"), ("ATM2-MIB", "atmSigDetectSetupAttempts"), ("ATM2-MIB", "atmSigEmitSetupAttempts"), ("ATM2-MIB", "atmSigDetectUnavailRoutes"), ("ATM2-MIB", "atmSigEmitUnavailRoutes"), ("ATM2-MIB", "atmSigDetectUnavailResrcs"), ("ATM2-MIB", "atmSigEmitUnavailResrcs"), ("ATM2-MIB", "atmSigDetectCldPtyEvents"), ("ATM2-MIB", "atmSigEmitCldPtyEvents"), ("ATM2-MIB", "atmSigDetectMsgErrors"), ("ATM2-MIB", "atmSigEmitMsgErrors"), ("ATM2-MIB", "atmSigDetectClgPtyEvents"), ("ATM2-MIB", "atmSigEmitClgPtyEvents"), ("ATM2-MIB", "atmSigDetectTimerExpireds"), ("ATM2-MIB", "atmSigEmitTimerExpireds"), ("ATM2-MIB", "atmSigDetectRestarts"), ("ATM2-MIB", "atmSigEmitRestarts"), ("ATM2-MIB", "atmSigInEstabls"), ("ATM2-MIB", "atmSigOutEstabls"), ("ATM2-MIB", "atmVclStatTotalCellIns"), ("ATM2-MIB", "atmVclStatClp0CellIns"), ("ATM2-MIB", "atmVclStatTotalDiscards"), ("ATM2-MIB", "atmVclStatClp0Discards"), ("ATM2-MIB", "atmVclStatTotalCellOuts"), ("ATM2-MIB", "atmVclStatClp0CellOuts"), ("ATM2-MIB", "atmVclStatTaggedOuts"), ("ATM2-MIB", "atmVplStatTotalCellIns"), ("ATM2-MIB", "atmVplStatClp0CellIns"), ("ATM2-MIB", "atmVplStatTotalDiscards"), ("ATM2-MIB", "atmVplStatClp0Discards"), ("ATM2-MIB", "atmVplStatTotalCellOuts"), ("ATM2-MIB", "atmVplStatClp0CellOuts"), ("ATM2-MIB", "atmVplStatTaggedOuts"), ("ATM2-MIB", "atmVplLogicalPortDef"), ("ATM2-MIB", "atmVplLogicalPortIndex"), ("ATM2-MIB", "atmInterfaceConfMaxSvpcVpi"), ("ATM2-MIB", "atmInterfaceCurrentMaxSvpcVpi"), ("ATM2-MIB", "atmInterfaceConfMaxSvccVpi"), ("ATM2-MIB", "atmInterfaceCurrentMaxSvccVpi"), ("ATM2-MIB", "atmInterfaceConfMinSvccVci"), ("ATM2-MIB", "atmInterfaceCurrentMinSvccVci"), ("ATM2-MIB", "atmIntfSigVccRxTrafficDescrIndex"), ("ATM2-MIB", "atmIntfSigVccTxTrafficDescrIndex"), ("ATM2-MIB", "atmIntfPvcFailures"), ("ATM2-MIB", "atmIntfCurrentlyFailingPVpls"), ("ATM2-MIB", "atmIntfCurrentlyFailingPVcls"), ("ATM2-MIB", "atmIntfPvcNotificationInterval"), ("ATM2-MIB", "atmIntfPvcFailuresTrapEnable"), ("ATM2-MIB", "atmIntfConfigType"), ("ATM2-MIB", "atmIntfActualType"), ("ATM2-MIB", "atmIntfConfigSide"), ("ATM2-MIB", "atmIntfActualSide"), ("ATM2-MIB", "atmIntfIlmiAdminStatus"), ("ATM2-MIB", "atmIntfIlmiOperStatus"), ("ATM2-MIB", "atmIntfIlmiFsmState"), ("ATM2-MIB", "atmIntfIlmiEstablishConPollIntvl"), ("ATM2-MIB", "atmIntfIlmiCheckConPollIntvl"), ("ATM2-MIB", "atmIntfIlmiConPollInactFactor"), ("ATM2-MIB", "atmIntfIlmiPublicPrivateIndctr"), ("ATM2-MIB", "atmCurrentlyFailingPVplTimeStamp"), ("ATM2-MIB", "atmCurrentlyFailingPVclTimeStamp"),))
if mibBuilder.loadTexts: atmSwitchServcHostGroup.setDescription('A collection of objects providing information\n                   for a Switch/Service/Host that implements\n                   ATM interfaces.')
atmSwitchServcGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 2)).setObjects(*(("ATM2-MIB", "atmIlmiSrvcRegATMAddress"), ("ATM2-MIB", "atmIlmiSrvcRegParm1"), ("ATM2-MIB", "atmIlmiSrvcRegRowStatus"), ("ATM2-MIB", "atmIlmiNetPrefixRowStatus"), ("ATM2-MIB", "atmSigSupportClgPtyNumDel"), ("ATM2-MIB", "atmSigSupportClgPtySubAddr"), ("ATM2-MIB", "atmSigSupportCldPtySubAddr"), ("ATM2-MIB", "atmSigSupportHiLyrInfo"), ("ATM2-MIB", "atmSigSupportLoLyrInfo"), ("ATM2-MIB", "atmSigSupportBlliRepeatInd"), ("ATM2-MIB", "atmSigSupportAALInfo"), ("ATM2-MIB", "atmSigSupportPrefCarrier"), ("ATM2-MIB", "atmSvcVpCrossConnectCreationTime"), ("ATM2-MIB", "atmSvcVpCrossConnectRowStatus"), ("ATM2-MIB", "atmSvcVcCrossConnectCreationTime"), ("ATM2-MIB", "atmSvcVcCrossConnectRowStatus"), ("ATM2-MIB", "atmIfRegAddrAddressSource"), ("ATM2-MIB", "atmIfRegAddrOrgScope"), ("ATM2-MIB", "atmIfRegAddrRowStatus"),))
if mibBuilder.loadTexts: atmSwitchServcGroup.setDescription('A collection of objects providing information\n                   for a Switch/Service that implements ATM interfaces.')
atmSwitchServcNotifGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 3)).setObjects(*(("ATM2-MIB", "atmIntfPvcFailuresTrap"),))
if mibBuilder.loadTexts: atmSwitchServcNotifGroup.setDescription('A collection of notifications providing information\n                   for a Switch/Service that implements ATM interfaces.')
atmSwitchGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 4)).setObjects(*(("ATM2-MIB", "atmSwitchAddressAddress"), ("ATM2-MIB", "atmSwitchAddressRowStatus"),))
if mibBuilder.loadTexts: atmSwitchGroup.setDescription('A collection of objects providing information\n                   for an ATM switch.')
atmServcGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 5)).setObjects(*(("ATM2-MIB", "atmVpCrossConnectUserName"), ("ATM2-MIB", "atmVpCrossConnectProviderName"), ("ATM2-MIB", "atmVcCrossConnectUserName"), ("ATM2-MIB", "atmVcCrossConnectProviderName"),))
if mibBuilder.loadTexts: atmServcGroup.setDescription('A collection of objects providing information\n                   for an ATM Network Service.')
atmHostGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 37, 1, 14, 3, 1, 6)).setObjects(*(("ATM2-MIB", "atmAal5VclInPkts"), ("ATM2-MIB", "atmAal5VclOutPkts"), ("ATM2-MIB", "atmAal5VclInOctets"), ("ATM2-MIB", "atmAal5VclOutOctets"), ("ATM2-MIB", "atmVclAddrType"), ("ATM2-MIB", "atmVclAddrRowStatus"), ("ATM2-MIB", "atmAddrVclAddrType"), ("ATM2-MIB", "atmVclGenSigDescrIndex"), ("ATM2-MIB", "atmSigDescrParamAalType"), ("ATM2-MIB", "atmSigDescrParamAalSscsType"), ("ATM2-MIB", "atmSigDescrParamBhliType"), ("ATM2-MIB", "atmSigDescrParamBhliInfo"), ("ATM2-MIB", "atmSigDescrParamBbcConnConf"), ("ATM2-MIB", "atmSigDescrParamBlliLayer2"), ("ATM2-MIB", "atmSigDescrParamBlliLayer3"), ("ATM2-MIB", "atmSigDescrParamBlliPktSize"), ("ATM2-MIB", "atmSigDescrParamBlliSnapId"), ("ATM2-MIB", "atmSigDescrParamBlliOuiPid"), ("ATM2-MIB", "atmSigDescrParamRowStatus"),))
if mibBuilder.loadTexts: atmHostGroup.setDescription('A collection of objects providing information\n                   for a Host that implements ATM interfaces.')
mibBuilder.exportSymbols("ATM2-MIB", atmVclStatTotalCellIns=atmVclStatTotalCellIns, atmSwitchGroup=atmSwitchGroup, atmAal5VclInOctets=atmAal5VclInOctets, atmSigDetectUnavailRoutes=atmSigDetectUnavailRoutes, atmSigDetectUnavailResrcs=atmSigDetectUnavailResrcs, atmVclAddrRowStatus=atmVclAddrRowStatus, atmIlmiSrvcRegATMAddress=atmIlmiSrvcRegATMAddress, atmSigEmitUnavailRoutes=atmSigEmitUnavailRoutes, atmSigSupportLoLyrInfo=atmSigSupportLoLyrInfo, atmSigDescrParamBbcConnConf=atmSigDescrParamBbcConnConf, atmSvcVcCrossConnectRowStatus=atmSvcVcCrossConnectRowStatus, atmSigDescrParamRowStatus=atmSigDescrParamRowStatus, atmVclGenTable=atmVclGenTable, atmVplStatTaggedOuts=atmVplStatTaggedOuts, atmVclStatClp0Discards=atmVclStatClp0Discards, atmIntfConfigType=atmIntfConfigType, atmAal5VclOutPkts=atmAal5VclOutPkts, atmIntfCurrentlyFailingPVpls=atmIntfCurrentlyFailingPVpls, atmIntfCurrentlyFailingPVcls=atmIntfCurrentlyFailingPVcls, atmVclStatTotalCellOuts=atmVclStatTotalCellOuts, atmSigSupportClgPtySubAddr=atmSigSupportClgPtySubAddr, atmAal5VclOutOctets=atmAal5VclOutOctets, atmSvcVpCrossConnectHighIfIndex=atmSvcVpCrossConnectHighIfIndex, atmIfRegAddrOrgScope=atmIfRegAddrOrgScope, atmVclGenSigDescrIndex=atmVclGenSigDescrIndex, atmIlmiSrvcRegEntry=atmIlmiSrvcRegEntry, atmSvcVcCrossConnectTable=atmSvcVcCrossConnectTable, atmSigDescrParamBlliSnapId=atmSigDescrParamBlliSnapId, atmIntfConfigSide=atmIntfConfigSide, atmSvcVcCrossConnectLowVpi=atmSvcVcCrossConnectLowVpi, atmIfRegAddrRowStatus=atmIfRegAddrRowStatus, atmSigDetectRestarts=atmSigDetectRestarts, atmSigSupportCldPtySubAddr=atmSigSupportCldPtySubAddr, atmSigEmitTimerExpireds=atmSigEmitTimerExpireds, atmSvcVpCrossConnectHighVpi=atmSvcVpCrossConnectHighVpi, atmVplStatTotalCellIns=atmVplStatTotalCellIns, atmVplLogicalPortIndex=atmVplLogicalPortIndex, atmIntfSigVccRxTrafficDescrIndex=atmIntfSigVccRxTrafficDescrIndex, atmInterfaceExtTable=atmInterfaceExtTable, atm2MIBCompliances=atm2MIBCompliances, atmAddrVclAddrType=atmAddrVclAddrType, atmVclStatTable=atmVclStatTable, atmVclAddrAddr=atmVclAddrAddr, atmIlmiNetPrefixPrefix=atmIlmiNetPrefixPrefix, atmInterfaceExtEntry=atmInterfaceExtEntry, atmAal5VclStatEntry=atmAal5VclStatEntry, atmInterfaceCurrentMinSvccVci=atmInterfaceCurrentMinSvccVci, atmIlmiSrvcRegTable=atmIlmiSrvcRegTable, atmIntfIlmiCheckConPollIntvl=atmIntfIlmiCheckConPollIntvl, atmIntfPvcFailures=atmIntfPvcFailures, atmIlmiSrvcRegIndex=atmIlmiSrvcRegIndex, atmHostGroup=atmHostGroup, atmSigDescrParamBlliOuiPid=atmSigDescrParamBlliOuiPid, atmSigSupportEntry=atmSigSupportEntry, atmVclGenEntry=atmVclGenEntry, atmInterfaceConfMaxSvpcVpi=atmInterfaceConfMaxSvpcVpi, atmInterfaceCurrentMaxSvccVpi=atmInterfaceCurrentMaxSvccVpi, atmVpCrossConnectUserName=atmVpCrossConnectUserName, atmSvcVpCrossConnectLowVpi=atmSvcVpCrossConnectLowVpi, atmCurrentlyFailingPVclTable=atmCurrentlyFailingPVclTable, atmSigDescrParamBhliInfo=atmSigDescrParamBhliInfo, atmIlmiSrvcRegParm1=atmIlmiSrvcRegParm1, atmIntfPvcFailuresTrap=atmIntfPvcFailuresTrap, atmSigSupportPrefCarrier=atmSigSupportPrefCarrier, atmVplStatClp0CellIns=atmVplStatClp0CellIns, atmSigEmitCldPtyEvents=atmSigEmitCldPtyEvents, atmVclStatEntry=atmVclStatEntry, atmSigStatEntry=atmSigStatEntry, atmVplStatEntry=atmVplStatEntry, atmVclStatClp0CellOuts=atmVclStatClp0CellOuts, atmIntfPvcNotificationInterval=atmIntfPvcNotificationInterval, atmIlmiSrvcRegRowStatus=atmIlmiSrvcRegRowStatus, atmSigDescrParamBlliPktSize=atmSigDescrParamBlliPktSize, atmCurrentlyFailingPVplEntry=atmCurrentlyFailingPVplEntry, atmVcCrossConnectUserName=atmVcCrossConnectUserName, atmVclAddrEntry=atmVclAddrEntry, atmSigSSCOPErrdPdus=atmSigSSCOPErrdPdus, atmIfRegisteredAddrTable=atmIfRegisteredAddrTable, atmVclAddrTable=atmVclAddrTable, atmSigDetectClgPtyEvents=atmSigDetectClgPtyEvents, atmAddrVclVci=atmAddrVclVci, atm2MIBCompliance=atm2MIBCompliance, atmSigSupportBlliRepeatInd=atmSigSupportBlliRepeatInd, atmSwitchServcGroup=atmSwitchServcGroup, atmSigInEstabls=atmSigInEstabls, atmAddrVclVpi=atmAddrVclVpi, atmVplStatTable=atmVplStatTable, atmAddrVclAtmIfIndex=atmAddrVclAtmIfIndex, atmAddrVclTable=atmAddrVclTable, atmIntfIlmiConPollInactFactor=atmIntfIlmiConPollInactFactor, atmInterfaceConfMaxSvccVpi=atmInterfaceConfMaxSvccVpi, atmIntfIlmiEstablishConPollIntvl=atmIntfIlmiEstablishConPollIntvl, atmSwitchAddressIndex=atmSwitchAddressIndex, atmIlmiNetworkPrefixTable=atmIlmiNetworkPrefixTable, atmIntfIlmiAdminStatus=atmIntfIlmiAdminStatus, atmSvcVcCrossConnectIndex=atmSvcVcCrossConnectIndex, atmSigDescrParamBlliLayer2=atmSigDescrParamBlliLayer2, atm2MIBTraps=atm2MIBTraps, atmSwitchAddressTable=atmSwitchAddressTable, atmCurrentlyFailingPVplTimeStamp=atmCurrentlyFailingPVplTimeStamp, atmSwitchServcNotifGroup=atmSwitchServcNotifGroup, atmSigDescrParamBhliType=atmSigDescrParamBhliType, atmIntfActualType=atmIntfActualType, atmInterfaceCurrentMaxSvpcVpi=atmInterfaceCurrentMaxSvpcVpi, atmCurrentlyFailingPVplTable=atmCurrentlyFailingPVplTable, atmSvcVcCrossConnectEntry=atmSvcVcCrossConnectEntry, atmVclStatTaggedOuts=atmVclStatTaggedOuts, atmPvcTraps=atmPvcTraps, atmIntfPvcFailuresTrapEnable=atmIntfPvcFailuresTrapEnable, atmVplStatClp0CellOuts=atmVplStatClp0CellOuts, atmVcCrossConnectXTable=atmVcCrossConnectXTable, atmSigDescrParamBlliLayer3=atmSigDescrParamBlliLayer3, atmSigEmitUnavailResrcs=atmSigEmitUnavailResrcs, atmVplLogicalPortEntry=atmVplLogicalPortEntry, atmSigEmitMsgErrors=atmSigEmitMsgErrors, atmVcCrossConnectProviderName=atmVcCrossConnectProviderName, atmVplStatTotalCellOuts=atmVplStatTotalCellOuts, atmSigSSCOPConEvents=atmSigSSCOPConEvents, atmSvcVcCrossConnectCreationTime=atmSvcVcCrossConnectCreationTime, atmSvcVpCrossConnectIndex=atmSvcVpCrossConnectIndex, atmSigDetectTimerExpireds=atmSigDetectTimerExpireds, atm2MIBConformance=atm2MIBConformance, atmSigDescrParamAalType=atmSigDescrParamAalType, atmIlmiSrvcRegAddressIndex=atmIlmiSrvcRegAddressIndex, atmSigEmitClgPtyEvents=atmSigEmitClgPtyEvents, atmSigDescrParamAalSscsType=atmSigDescrParamAalSscsType, atmVclStatClp0CellIns=atmVclStatClp0CellIns, atmAal5VclInPkts=atmAal5VclInPkts, atmVpCrossConnectXEntry=atmVpCrossConnectXEntry, atmVcCrossConnectXEntry=atmVcCrossConnectXEntry, atmSigDescrParamEntry=atmSigDescrParamEntry, atmVplLogicalPortDef=atmVplLogicalPortDef, atmServcGroup=atmServcGroup, atmSigSupportHiLyrInfo=atmSigSupportHiLyrInfo, atmIlmiNetworkPrefixEntry=atmIlmiNetworkPrefixEntry, atmIlmiSrvcRegServiceID=atmIlmiSrvcRegServiceID, atmSvcVcCrossConnectHighVpi=atmSvcVcCrossConnectHighVpi, atmSigSupportTable=atmSigSupportTable, atmSigOutEstabls=atmSigOutEstabls, atmSvcVcCrossConnectLowVci=atmSvcVcCrossConnectLowVci, atmSvcVpCrossConnectCreationTime=atmSvcVpCrossConnectCreationTime, atmSwitchAddressEntry=atmSwitchAddressEntry, atmSigDescrParamIndex=atmSigDescrParamIndex, atmSigSupportClgPtyNumDel=atmSigSupportClgPtyNumDel, atmSvcVpCrossConnectLowIfIndex=atmSvcVpCrossConnectLowIfIndex, atmSvcVpCrossConnectRowStatus=atmSvcVpCrossConnectRowStatus, atmIntfIlmiOperStatus=atmIntfIlmiOperStatus, atmIntfSigVccTxTrafficDescrIndex=atmIntfSigVccTxTrafficDescrIndex, atmSigDetectMsgErrors=atmSigDetectMsgErrors, atmCurrentlyFailingPVclEntry=atmCurrentlyFailingPVclEntry, atmSigDescrParamTable=atmSigDescrParamTable, atmPvcTrapsPrefix=atmPvcTrapsPrefix, atmSvcVpCrossConnectEntry=atmSvcVpCrossConnectEntry, atmVplStatTotalDiscards=atmVplStatTotalDiscards, atmVplLogicalPortTable=atmVplLogicalPortTable, atmVclAddrType=atmVclAddrType, atmSvcVcCrossConnectHighIfIndex=atmSvcVcCrossConnectHighIfIndex, atmIlmiNetPrefixRowStatus=atmIlmiNetPrefixRowStatus, atmIfRegAddrAddressSource=atmIfRegAddrAddressSource, atmSwitchServcHostGroup=atmSwitchServcHostGroup, atmInterfaceConfMinSvccVci=atmInterfaceConfMinSvccVci, atmCurrentlyFailingPVclTimeStamp=atmCurrentlyFailingPVclTimeStamp, atm2MIBGroups=atm2MIBGroups, atmSigDetectSetupAttempts=atmSigDetectSetupAttempts, PYSNMP_MODULE_ID=atm2MIB, atmSigEmitSetupAttempts=atmSigEmitSetupAttempts, atmSvcVcCrossConnectLowIfIndex=atmSvcVcCrossConnectLowIfIndex, atm2MIB=atm2MIB, atmAddrVclEntry=atmAddrVclEntry, atmSvcVpCrossConnectTable=atmSvcVpCrossConnectTable, atmIntfIlmiFsmState=atmIntfIlmiFsmState, atmSvcVcCrossConnectHighVci=atmSvcVcCrossConnectHighVci, atmAal5VclStatTable=atmAal5VclStatTable, atmIfRegAddrAddress=atmIfRegAddrAddress, atmVplStatClp0Discards=atmVplStatClp0Discards, atmIntfActualSide=atmIntfActualSide, atmIntfIlmiPublicPrivateIndctr=atmIntfIlmiPublicPrivateIndctr, atmSwitchAddressRowStatus=atmSwitchAddressRowStatus, atmVpCrossConnectProviderName=atmVpCrossConnectProviderName, atmIfRegisteredAddrEntry=atmIfRegisteredAddrEntry, atmVpCrossConnectXTable=atmVpCrossConnectXTable, atmVclStatTotalDiscards=atmVclStatTotalDiscards, atmSigStatTable=atmSigStatTable, atmSigEmitRestarts=atmSigEmitRestarts, atmSigDetectCldPtyEvents=atmSigDetectCldPtyEvents, atmSwitchAddressAddress=atmSwitchAddressAddress, atmSigSupportAALInfo=atmSigSupportAALInfo, atm2MIBObjects=atm2MIBObjects)
