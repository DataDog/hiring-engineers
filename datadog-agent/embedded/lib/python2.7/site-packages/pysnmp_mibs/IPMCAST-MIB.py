#
# PySNMP MIB module IPMCAST-MIB (http://pysnmp.sf.net)
# ASN.1 source http://mibs.snmplabs.com:80/asn1/IPMCAST-MIB
# Produced by pysmi-0.0.7 at Sun Feb 14 00:17:53 2016
# On host bldfarm platform Linux version 4.1.13-100.fc21.x86_64 by user goose
# Using Python version 3.5.0 (default, Jan  5 2016, 17:11:52) 
#
( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
( CounterBasedGauge64, ) = mibBuilder.importSymbols("HCNUM-TC", "CounterBasedGauge64")
( IANAipRouteProtocol, IANAipMRouteProtocol, ) = mibBuilder.importSymbols("IANA-RTPROTO-MIB", "IANAipRouteProtocol", "IANAipMRouteProtocol")
( InterfaceIndex, InterfaceIndexOrZero, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero")
( InetAddressType, InetZoneIndex, InetAddressPrefixLength, InetAddress, InetVersion, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetZoneIndex", "InetAddressPrefixLength", "InetAddress", "InetVersion")
( LangTag, ) = mibBuilder.importSymbols("LANGTAG-TC-MIB", "LangTag")
( SnmpAdminString, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
( ObjectGroup, ModuleCompliance, NotificationGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
( Counter32, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, mib_2, iso, NotificationType, IpAddress, Gauge32, Unsigned32, ObjectIdentity, MibIdentifier, Integer32, ModuleIdentity, Bits, TimeTicks, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "mib-2", "iso", "NotificationType", "IpAddress", "Gauge32", "Unsigned32", "ObjectIdentity", "MibIdentifier", "Integer32", "ModuleIdentity", "Bits", "TimeTicks")
( TimeStamp, RowStatus, DisplayString, TextualConvention, StorageType, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "TimeStamp", "RowStatus", "DisplayString", "TextualConvention", "StorageType", "TruthValue")
ipMcastMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 168)).setRevisions(("2007-11-09 00:00",))
if mibBuilder.loadTexts: ipMcastMIB.setLastUpdated('200711090000Z')
if mibBuilder.loadTexts: ipMcastMIB.setOrganization('IETF MBONE Deployment (MBONED) Working Group')
if mibBuilder.loadTexts: ipMcastMIB.setContactInfo('David McWalter\n                  Data Connection Limited\n                  100 Church Street\n                  Enfield, EN2 6BQ\n                  UK\n\n                  Phone: +44 208 366 1177\n                  EMail: dmcw@dataconnection.com\n\n                  Dave Thaler\n                  Microsoft Corporation\n                  One Microsoft Way\n                  Redmond, WA 98052-6399\n                  US\n\n                  Phone: +1 425 703 8835\n                  EMail: dthaler@dthaler.microsoft.com\n\n                  Andrew Kessler\n                  Cisco Systems\n                  425 E. Tasman Drive\n                  San Jose, CA 95134\n                  US\n\n                  Phone: +1 408 526 5139\n                  EMail: kessler@cisco.com')
if mibBuilder.loadTexts: ipMcastMIB.setDescription('The MIB module for management of IP Multicast, including\n            multicast routing, data forwarding, and data reception.\n\n            Copyright (C) The IETF Trust (2007).  This version of this\n            MIB module is part of RFC 5132; see the RFC itself for full\n            legal notices.')
ipMcast = MibIdentifier((1, 3, 6, 1, 2, 1, 168, 1))
ipMcastEnabled = MibScalar((1, 3, 6, 1, 2, 1, 168, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipMcastEnabled.setDescription('The enabled status of IP Multicast function on this\n            system.\n\n            The storage type of this object is determined by\n            ipMcastDeviceConfigStorageType.')
ipMcastRouteEntryCount = MibScalar((1, 3, 6, 1, 2, 1, 168, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteEntryCount.setDescription('The number of rows in the ipMcastRouteTable.  This can be\n            used to check for multicast routing activity, and to monitor\n            the multicast routing table size.')
ipMcastDeviceConfigStorageType = MibScalar((1, 3, 6, 1, 2, 1, 168, 1, 11), StorageType().clone('nonVolatile')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipMcastDeviceConfigStorageType.setDescription("The storage type used for the global IP multicast\n            configuration of this device, comprised of the objects\n            listed below.  If this storage type takes the value\n            'permanent', write-access to the listed objects need not be\n            allowed.\n\n            The objects described by this storage type are:\n            ipMcastEnabled.")
ipMcastInterfaceTable = MibTable((1, 3, 6, 1, 2, 1, 168, 1, 3), )
if mibBuilder.loadTexts: ipMcastInterfaceTable.setDescription('The (conceptual) table used to manage the multicast\n            protocol active on an interface.')
ipMcastInterfaceEntry = MibTableRow((1, 3, 6, 1, 2, 1, 168, 1, 3, 1), ).setIndexNames((0, "IPMCAST-MIB", "ipMcastInterfaceIPVersion"), (0, "IPMCAST-MIB", "ipMcastInterfaceIfIndex"))
if mibBuilder.loadTexts: ipMcastInterfaceEntry.setDescription('An entry (conceptual row) containing the multicast protocol\n            information for a particular interface.\n\n            Per-interface multicast forwarding statistics are also\n            available in ipIfStatsTable.')
ipMcastInterfaceIPVersion = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 3, 1, 1), InetVersion())
if mibBuilder.loadTexts: ipMcastInterfaceIPVersion.setDescription('The IP version of this row.')
ipMcastInterfaceIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 3, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: ipMcastInterfaceIfIndex.setDescription("The index value that uniquely identifies the interface to\n            which this entry is applicable.  The interface identified by\n            a particular value of this index is the same interface as\n            identified by the same value of the IF-MIB's ifIndex.")
ipMcastInterfaceTtl = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 3, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0,256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipMcastInterfaceTtl.setDescription('The datagram Time to Live (TTL) threshold for the\n            interface.  Any IP multicast datagrams with a TTL (IPv4) or\n            Hop Limit (IPv6) less than this threshold will not be\n            forwarded out the interface.  The default value of 0 means\n            all multicast packets are forwarded out the interface.  A\n            value of 256 means that no multicast packets are forwarded\n            out the interface.')
ipMcastInterfaceRateLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 3, 1, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipMcastInterfaceRateLimit.setDescription('The rate-limit, in kilobits per second, of forwarded\n            multicast traffic on the interface.  A rate-limit of 0\n            indicates that no rate limiting is done.')
ipMcastInterfaceStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 3, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipMcastInterfaceStorageType.setDescription("The storage type for this row.  Rows having the value\n            'permanent' need not allow write-access to any columnar\n            objects in the row.")
ipMcastSsmRangeTable = MibTable((1, 3, 6, 1, 2, 1, 168, 1, 4), )
if mibBuilder.loadTexts: ipMcastSsmRangeTable.setDescription('This table is used to create and manage the range(s) of\n            group addresses to which SSM semantics should be applied.')
ipMcastSsmRangeEntry = MibTableRow((1, 3, 6, 1, 2, 1, 168, 1, 4, 1), ).setIndexNames((0, "IPMCAST-MIB", "ipMcastSsmRangeAddressType"), (0, "IPMCAST-MIB", "ipMcastSsmRangeAddress"), (0, "IPMCAST-MIB", "ipMcastSsmRangePrefixLength"))
if mibBuilder.loadTexts: ipMcastSsmRangeEntry.setDescription('An entry (conceptual row) containing a range of group\n            addresses to which SSM semantics should be applied.\n\n            Object Identifiers (OIDs) are limited to 128\n            sub-identifiers, but this limit is not enforced by the\n            syntax of this entry.  In practice, this does not present\n            a problem, because IP address types allowed by conformance\n            statements do not exceed this limit.')
ipMcastSsmRangeAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 4, 1, 1), InetAddressType())
if mibBuilder.loadTexts: ipMcastSsmRangeAddressType.setDescription('The address type of the multicast group prefix.')
ipMcastSsmRangeAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 4, 1, 2), InetAddress())
if mibBuilder.loadTexts: ipMcastSsmRangeAddress.setDescription("The multicast group address which, when combined with\n            ipMcastSsmRangePrefixLength, gives the group prefix for this\n            SSM range.  The InetAddressType is given by\n            ipMcastSsmRangeAddressType.\n\n            This address object is only significant up to\n            ipMcastSsmRangePrefixLength bits.  The remaining address\n            bits are set to zero.  This is especially important for this\n            index field, which is part of the index of this entry.  Any\n            non-zero bits would signify an entirely different entry.\n\n            For IPv6 SSM address ranges, only ranges prefixed by\n            FF3x::/16 are permitted, where 'x' is a valid IPv6 RFC 4291\n            multicast address scope.  The syntax of the address range is\n            given by RFC 3306, Sections 4 and 7.\n\n            For addresses of type ipv4z or ipv6z, the appended zone\n            index is significant even though it lies beyond the prefix\n            length.  The use of these address types indicate that this\n            SSM range entry applies only within the given zone.  Zone\n            index zero is not valid in this table.\n\n            If non-global scope SSM range entries are present, then\n            consistent ipMcastBoundaryTable entries are required on\n            routers at the zone boundary.")
ipMcastSsmRangePrefixLength = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 4, 1, 3), InetAddressPrefixLength())
if mibBuilder.loadTexts: ipMcastSsmRangePrefixLength.setDescription("The length in bits of the mask which, when combined with\n            ipMcastSsmRangeAddress, gives the group prefix for this SSM\n            range.\n\n            The InetAddressType is given by ipMcastSsmRangeAddressType.\n            For values 'ipv4' and 'ipv4z', this object must be in the\n            range 4..32.  For values 'ipv6' and 'ipv6z', this object\n            must be in the range 8..128.")
ipMcastSsmRangeRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 4, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipMcastSsmRangeRowStatus.setDescription('The status of this row, by which rows in this table can\n            be created and destroyed.\n\n            This status object can be set to active(1) without setting\n            any other columnar objects in this entry.\n\n            All writeable objects in this entry can be modified when the\n            status of this entry is active(1).')
ipMcastSsmRangeStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 4, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipMcastSsmRangeStorageType.setDescription("The storage type for this row.  Rows having the value\n           'permanent' need not allow write-access to any columnar\n           objects in the row.")
ipMcastRouteTable = MibTable((1, 3, 6, 1, 2, 1, 168, 1, 5), )
if mibBuilder.loadTexts: ipMcastRouteTable.setDescription('The (conceptual) table containing multicast routing\n            information for IP datagrams sent by particular sources\n            to the IP multicast groups known to this router.')
ipMcastRouteEntry = MibTableRow((1, 3, 6, 1, 2, 1, 168, 1, 5, 1), ).setIndexNames((0, "IPMCAST-MIB", "ipMcastRouteGroupAddressType"), (0, "IPMCAST-MIB", "ipMcastRouteGroup"), (0, "IPMCAST-MIB", "ipMcastRouteGroupPrefixLength"), (0, "IPMCAST-MIB", "ipMcastRouteSourceAddressType"), (0, "IPMCAST-MIB", "ipMcastRouteSource"), (0, "IPMCAST-MIB", "ipMcastRouteSourcePrefixLength"))
if mibBuilder.loadTexts: ipMcastRouteEntry.setDescription('An entry (conceptual row) containing the multicast routing\n            information for IP datagrams from a particular source and\n            addressed to a particular IP multicast group address.\n\n            OIDs are limited to 128 sub-identifiers, but this limit\n            is not enforced by the syntax of this entry.  In practice,\n            this does not present a problem, because IP address types\n            allowed by conformance statements do not exceed this limit.')
ipMcastRouteGroupAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 1), InetAddressType())
if mibBuilder.loadTexts: ipMcastRouteGroupAddressType.setDescription('A value indicating the address family of the address\n            contained in ipMcastRouteGroup.  Legal values correspond to\n            the subset of address families for which multicast\n            forwarding is supported.')
ipMcastRouteGroup = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 2), InetAddress())
if mibBuilder.loadTexts: ipMcastRouteGroup.setDescription('The IP multicast group address which, when combined with\n            the corresponding value specified in\n            ipMcastRouteGroupPrefixLength, identifies the groups for\n            which this entry contains multicast routing information.\n\n            This address object is only significant up to\n            ipMcastRouteGroupPrefixLength bits.  The remaining address\n            bits are set to zero.  This is especially important for this\n            index field, which is part of the index of this entry.  Any\n            non-zero bits would signify an entirely different entry.\n\n            For addresses of type ipv4z or ipv6z, the appended zone\n            index is significant even though it lies beyond the prefix\n            length.  The use of these address types indicate that this\n            forwarding state applies only within the given zone.  Zone\n            index zero is not valid in this table.')
ipMcastRouteGroupPrefixLength = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 3), InetAddressPrefixLength())
if mibBuilder.loadTexts: ipMcastRouteGroupPrefixLength.setDescription("The length in bits of the mask which, when combined with\n            the corresponding value of ipMcastRouteGroup, identifies the\n            groups for which this entry contains multicast routing\n            information.\n\n            The InetAddressType is given by\n            ipMcastRouteGroupAddressType.  For values 'ipv4' and\n            'ipv4z', this object must be in the range 4..32.  For values\n            'ipv6' and 'ipv6z', this object must be in the range\n            8..128.")
ipMcastRouteSourceAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 4), InetAddressType())
if mibBuilder.loadTexts: ipMcastRouteSourceAddressType.setDescription('A value indicating the address family of the address\n            contained in ipMcastRouteSource.\n\n            A value of unknown(0) indicates a non-source-specific entry,\n            corresponding to all sources in the group.  Otherwise, the\n            value MUST be the same as the value of\n            ipMcastRouteGroupType.')
ipMcastRouteSource = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 5), InetAddress())
if mibBuilder.loadTexts: ipMcastRouteSource.setDescription('The network address which, when combined with the\n            corresponding value of ipMcastRouteSourcePrefixLength,\n            identifies the sources for which this entry contains\n            multicast routing information.\n\n            This address object is only significant up to\n            ipMcastRouteSourcePrefixLength bits.  The remaining address\n            bits are set to zero.  This is especially important for this\n            index field, which is part of the index of this entry.  Any\n            non-zero bits would signify an entirely different entry.\n\n            For addresses of type ipv4z or ipv6z, the appended zone\n            index is significant even though it lies beyond the prefix\n            length.  The use of these address types indicate that this\n            source address applies only within the given zone.  Zone\n            index zero is not valid in this table.')
ipMcastRouteSourcePrefixLength = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 6), InetAddressPrefixLength())
if mibBuilder.loadTexts: ipMcastRouteSourcePrefixLength.setDescription("The length in bits of the mask which, when combined with\n            the corresponding value of ipMcastRouteSource, identifies\n            the sources for which this entry contains multicast routing\n            information.\n\n            The InetAddressType is given by\n            ipMcastRouteSourceAddressType.  For the value 'unknown',\n            this object must be zero.  For values 'ipv4' and 'ipv4z',\n            this object must be in the range 4..32.  For values 'ipv6'\n            and 'ipv6z', this object must be in the range 8..128.")
ipMcastRouteUpstreamNeighborType = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 7), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteUpstreamNeighborType.setDescription('A value indicating the address family of the address\n            contained in ipMcastRouteUpstreamNeighbor.\n\n            An address type of unknown(0) indicates that the upstream\n            neighbor is unknown, for example in BIDIR-PIM.')
ipMcastRouteUpstreamNeighbor = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 8), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteUpstreamNeighbor.setDescription('The address of the upstream neighbor (for example, RPF\n            neighbor) from which IP datagrams from these sources to\n            this multicast address are received.')
ipMcastRouteInIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 9), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteInIfIndex.setDescription('The value of ifIndex for the interface on which IP\n            datagrams sent by these sources to this multicast address\n            are received.  A value of 0 indicates that datagrams are not\n            subject to an incoming interface check, but may be accepted\n            on multiple interfaces (for example, in BIDIR-PIM).')
ipMcastRouteTimeStamp = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 10), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteTimeStamp.setDescription('The value of sysUpTime at which the multicast routing\n            information represented by this entry was learned by the\n            router.\n\n            If this information was present at the most recent re-\n            initialization of the local management subsystem, then this\n            object contains a zero value.')
ipMcastRouteExpiryTime = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteExpiryTime.setDescription('The minimum amount of time remaining before this entry will\n            be aged out.  The value 0 indicates that the entry is not\n            subject to aging.  If ipMcastRouteNextHopState is pruned(1),\n            this object represents the remaining time until the prune\n            expires.  If this timer expires, state reverts to\n            forwarding(2).  Otherwise, this object represents the time\n            until this entry is removed from the table.')
ipMcastRouteProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 12), IANAipMRouteProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteProtocol.setDescription('The multicast routing protocol via which this multicast\n            forwarding entry was learned.')
ipMcastRouteRtProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 13), IANAipRouteProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteRtProtocol.setDescription('The routing mechanism via which the route used to find the\n            upstream or parent interface for this multicast forwarding\n            entry was learned.')
ipMcastRouteRtAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 14), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteRtAddressType.setDescription('A value indicating the address family of the address\n            contained in ipMcastRouteRtAddress.')
ipMcastRouteRtAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 15), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteRtAddress.setDescription('The address portion of the route used to find the upstream\n            or parent interface for this multicast forwarding entry.\n\n            This address object is only significant up to\n            ipMcastRouteRtPrefixLength bits.  The remaining address bits\n            are set to zero.\n\n            For addresses of type ipv4z or ipv6z, the appended zone\n            index is significant even though it lies beyond the prefix\n            length.  The use of these address types indicate that this\n            forwarding state applies only within the given zone.  Zone\n            index zero is not valid in this table.')
ipMcastRouteRtPrefixLength = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 16), InetAddressPrefixLength()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteRtPrefixLength.setDescription("The length in bits of the mask associated with the route\n            used to find the upstream or parent interface for this\n            multicast forwarding entry.\n\n            The InetAddressType is given by ipMcastRouteRtAddressType.\n            For values 'ipv4' and 'ipv4z', this object must be in the\n            range 4..32.  For values 'ipv6' and 'ipv6z', this object\n            must be in the range 8..128.")
ipMcastRouteRtType = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("unicast", 1), ("multicast", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteRtType.setDescription('The reason the given route was placed in the (logical)\n            multicast Routing Information Base (RIB).  A value of\n            unicast means that the route would normally be placed only\n            in the unicast RIB, but was placed in the multicast RIB\n            due (instead or in addition) to local configuration, such as\n            when running PIM over RIP.  A value of multicast means that\n            the route was explicitly added to the multicast RIB by the\n            routing protocol, such as the Distance Vector Multicast\n            Routing Protocol (DVMRP) or Multiprotocol BGP.')
ipMcastRouteOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteOctets.setDescription('The number of octets contained in IP datagrams that were\n            received from these sources and addressed to this multicast\n            group address, and which were forwarded by this router.\n\n            Discontinuities in this monotonically increasing value\n            occur at re-initialization of the management system.\n            Discontinuities can also occur as a result of routes being\n            removed and replaced, which can be detected by observing\n            the value of ipMcastRouteTimeStamp.')
ipMcastRoutePkts = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRoutePkts.setDescription('The number of packets routed using this multicast route\n            entry.\n\n            Discontinuities in this monotonically increasing value\n            occur at re-initialization of the management system.\n            Discontinuities can also occur as a result of routes being\n            removed and replaced, which can be detected by observing\n            the value of ipMcastRouteTimeStamp.')
ipMcastRouteTtlDropOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 20), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteTtlDropOctets.setDescription('The number of octets contained in IP datagrams that this\n            router has received from these sources and addressed to this\n            multicast group address, which were dropped because the TTL\n            (IPv4) or Hop Limit (IPv6) was decremented to zero, or to a\n            value less than ipMcastInterfaceTtl for all next hops.\n\n            Discontinuities in this monotonically increasing value\n            occur at re-initialization of the management system.\n            Discontinuities can also occur as a result of routes being\n            removed and replaced, which can be detected by observing\n            the value of ipMcastRouteTimeStamp.')
ipMcastRouteTtlDropPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 21), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteTtlDropPackets.setDescription('The number of packets that this router has received from\n            these sources and addressed to this multicast group address,\n            which were dropped because the TTL (IPv4) or Hop Limit\n            (IPv6) was decremented to zero, or to a value less than\n            ipMcastInterfaceTtl for all next hops.\n\n            Discontinuities in this monotonically increasing value\n            occur at re-initialization of the management system.\n            Discontinuities can also occur as a result of routes being\n            removed and replaced, which can be detected by observing\n            the value of ipMcastRouteTimeStamp.')
ipMcastRouteDifferentInIfOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 22), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteDifferentInIfOctets.setDescription("The number of octets contained in IP datagrams that this\n            router has received from these sources and addressed to this\n            multicast group address, which were dropped because they\n            were received on an unexpected interface.\n\n            For RPF checking protocols (such as PIM-SM), these packets\n            arrived on interfaces other than ipMcastRouteInIfIndex, and\n            were dropped because of this failed RPF check.  (RPF paths\n            are 'Reverse Path Forwarding' paths; the unicast routes to\n            the expected origin of multicast data flows).\n\n            Other protocols may drop packets on an incoming interface\n            check for different reasons (for example, BIDIR-PIM performs\n            a DF check on receipt of packets).  All packets dropped as a\n            result of an incoming interface check are counted here.\n\n            If this counter increases rapidly, this indicates a problem.\n            A significant quantity of multicast data is arriving at this\n            router on unexpected interfaces, and is not being forwarded.\n\n            For guidance, if the rate of increase of this counter\n            exceeds 1% of the rate of increase of ipMcastRouteOctets,\n            then there are multicast routing problems that require\n            investigation.\n\n            Discontinuities in this monotonically increasing value\n            occur at re-initialization of the management system.\n            Discontinuities can also occur as a result of routes being\n            removed and replaced, which can be detected by observing\n            the value of ipMcastRouteTimeStamp.")
ipMcastRouteDifferentInIfPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 23), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteDifferentInIfPackets.setDescription("The number of packets which this router has received from\n            these sources and addressed to this multicast group address,\n            which were dropped because they were received on an\n            unexpected interface.\n\n            For RPF checking protocols (such as PIM-SM), these packets\n            arrived on interfaces other than ipMcastRouteInIfIndex, and\n            were dropped because of this failed RPF check.  (RPF paths\n            are 'Reverse Path Forwarding' path; the unicast routes to\n            the expected origin of multicast data flows).\n\n            Other protocols may drop packets on an incoming interface\n            check for different reasons (for example, BIDIR-PIM performs\n            a DF check on receipt of packets).  All packets dropped as a\n            result of an incoming interface check are counted here.\n\n            If this counter increases rapidly, this indicates a problem.\n            A significant quantity of multicast data is arriving at this\n            router on unexpected interfaces, and is not being forwarded.\n\n            For guidance, if the rate of increase of this counter\n            exceeds 1% of the rate of increase of ipMcastRoutePkts, then\n            there are multicast routing problems that require\n            investigation.\n\n            Discontinuities in this monotonically increasing value\n            occur at re-initialization of the management system.\n            Discontinuities can also occur as a result of routes being\n            removed and replaced, which can be detected by observing\n            the value of ipMcastRouteTimeStamp.")
ipMcastRouteBps = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 5, 1, 24), CounterBasedGauge64()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteBps.setDescription('Bits per second forwarded by this router using this\n            multicast routing entry.\n\n            This value is a sample; it is the number of bits forwarded\n            during the last whole 1 second sampling period.  The value\n            during the current 1 second sampling period is not made\n            available until the period is completed.\n\n            The quantity being sampled is the same as that measured by\n            ipMcastRouteOctets.  The units and the sampling method are\n            different.')
ipMcastRouteNextHopTable = MibTable((1, 3, 6, 1, 2, 1, 168, 1, 6), )
if mibBuilder.loadTexts: ipMcastRouteNextHopTable.setDescription('The (conceptual) table containing information on the\n            next-hops on outgoing interfaces for routing IP multicast\n            datagrams.  Each entry is one of a list of next-hops on\n            outgoing interfaces for particular sources sending to a\n            particular multicast group address.')
ipMcastRouteNextHopEntry = MibTableRow((1, 3, 6, 1, 2, 1, 168, 1, 6, 1), ).setIndexNames((0, "IPMCAST-MIB", "ipMcastRouteNextHopGroupAddressType"), (0, "IPMCAST-MIB", "ipMcastRouteNextHopGroup"), (0, "IPMCAST-MIB", "ipMcastRouteNextHopGroupPrefixLength"), (0, "IPMCAST-MIB", "ipMcastRouteNextHopSourceAddressType"), (0, "IPMCAST-MIB", "ipMcastRouteNextHopSource"), (0, "IPMCAST-MIB", "ipMcastRouteNextHopSourcePrefixLength"), (0, "IPMCAST-MIB", "ipMcastRouteNextHopIfIndex"), (0, "IPMCAST-MIB", "ipMcastRouteNextHopAddressType"), (0, "IPMCAST-MIB", "ipMcastRouteNextHopAddress"))
if mibBuilder.loadTexts: ipMcastRouteNextHopEntry.setDescription('An entry (conceptual row) in the list of next-hops on\n            outgoing interfaces to which IP multicast datagrams from\n            particular sources to an IP multicast group address are\n            routed.\n\n            OIDs are limited to 128 sub-identifiers, but this limit\n            is not enforced by the syntax of this entry.  In practice,\n            this does not present a problem, because IP address types\n            allowed by conformance statements do not exceed this limit.')
ipMcastRouteNextHopGroupAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 6, 1, 1), InetAddressType())
if mibBuilder.loadTexts: ipMcastRouteNextHopGroupAddressType.setDescription('A value indicating the address family of the address\n            contained in ipMcastRouteNextHopGroup.  Legal values\n            correspond to the subset of address families for which\n            multicast forwarding is supported.')
ipMcastRouteNextHopGroup = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 6, 1, 2), InetAddress())
if mibBuilder.loadTexts: ipMcastRouteNextHopGroup.setDescription('The IP multicast group address which, when combined with\n            the corresponding value specified in\n            ipMcastRouteNextHopGroupPrefixLength, identifies the groups\n            for which this entry contains multicast forwarding\n            information.\n\n            This address object is only significant up to\n            ipMcastRouteNextHopGroupPrefixLength bits.  The remaining\n            address bits are set to zero.  This is especially important\n            for this index field, which is part of the index of this\n            entry.  Any non-zero bits would signify an entirely\n            different entry.\n\n            For addresses of type ipv4z or ipv6z, the appended zone\n            index is significant even though it lies beyond the prefix\n            length.  The use of these address types indicate that this\n            forwarding state applies only within the given zone.  Zone\n            index zero is not valid in this table.')
ipMcastRouteNextHopGroupPrefixLength = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 6, 1, 3), InetAddressPrefixLength())
if mibBuilder.loadTexts: ipMcastRouteNextHopGroupPrefixLength.setDescription("The length in bits of the mask which, when combined with\n            the corresponding value of ipMcastRouteGroup, identifies the\n            groups for which this entry contains multicast routing\n            information.\n\n            The InetAddressType is given by\n            ipMcastRouteNextHopGroupAddressType.  For values 'ipv4' and\n            'ipv4z', this object must be in the range 4..32.  For values\n            'ipv6' and 'ipv6z', this object must be in the range\n            8..128.")
ipMcastRouteNextHopSourceAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 6, 1, 4), InetAddressType())
if mibBuilder.loadTexts: ipMcastRouteNextHopSourceAddressType.setDescription('A value indicating the address family of the address\n            contained in ipMcastRouteNextHopSource.\n\n            A value of unknown(0) indicates a non-source-specific entry,\n            corresponding to all sources in the group.  Otherwise, the\n            value MUST be the same as the value of\n            ipMcastRouteNextHopGroupType.')
ipMcastRouteNextHopSource = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 6, 1, 5), InetAddress())
if mibBuilder.loadTexts: ipMcastRouteNextHopSource.setDescription('The network address which, when combined with the\n            corresponding value of the mask specified in\n            ipMcastRouteNextHopSourcePrefixLength, identifies the\n            sources for which this entry specifies a next-hop on an\n            outgoing interface.\n\n            This address object is only significant up to\n            ipMcastRouteNextHopSourcePrefixLength bits.  The remaining\n            address bits are set to zero.  This is especially important\n            for this index field, which is part of the index of this\n            entry.  Any non-zero bits would signify an entirely\n            different entry.\n\n            For addresses of type ipv4z or ipv6z, the appended zone\n            index is significant even though it lies beyond the prefix\n            length.  The use of these address types indicate that this\n            source address applies only within the given zone.  Zone\n            index zero is not valid in this table.')
ipMcastRouteNextHopSourcePrefixLength = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 6, 1, 6), InetAddressPrefixLength())
if mibBuilder.loadTexts: ipMcastRouteNextHopSourcePrefixLength.setDescription("The length in bits of the mask which, when combined with\n            the corresponding value specified in\n            ipMcastRouteNextHopSource, identifies the sources for which\n            this entry specifies a next-hop on an outgoing interface.\n\n            The InetAddressType is given by\n            ipMcastRouteNextHopSourceAddressType.  For the value\n            'unknown', this object must be zero.  For values 'ipv4' and\n            'ipv4z', this object must be in the range 4..32.  For values\n            'ipv6' and 'ipv6z', this object must be in the range\n            8..128.")
ipMcastRouteNextHopIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 6, 1, 7), InterfaceIndex())
if mibBuilder.loadTexts: ipMcastRouteNextHopIfIndex.setDescription('The ifIndex value of the interface for the outgoing\n            interface for this next-hop.')
ipMcastRouteNextHopAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 6, 1, 8), InetAddressType())
if mibBuilder.loadTexts: ipMcastRouteNextHopAddressType.setDescription('A value indicating the address family of the address\n            contained in ipMcastRouteNextHopAddress.')
ipMcastRouteNextHopAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 6, 1, 9), InetAddress())
if mibBuilder.loadTexts: ipMcastRouteNextHopAddress.setDescription('The address of the next-hop specific to this entry.  For\n            most interfaces, this is identical to\n            ipMcastRouteNextHopGroup.  Non-Broadcast Multi-Access\n            (NBMA) interfaces, however, may\n            have multiple next-hop addresses out a single outgoing\n            interface.')
ipMcastRouteNextHopState = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 6, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("pruned", 1), ("forwarding", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteNextHopState.setDescription("An indication of whether the outgoing interface and next-\n            hop represented by this entry is currently being used to\n            forward IP datagrams.  The value 'forwarding' indicates it\n            is currently being used; the value 'pruned' indicates it is\n            not.")
ipMcastRouteNextHopTimeStamp = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 6, 1, 11), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteNextHopTimeStamp.setDescription('The value of sysUpTime at which the multicast routing\n            information represented by this entry was learned by the\n            router.\n\n            If this information was present at the most recent re-\n            initialization of the local management subsystem, then this\n            object contains a zero value.')
ipMcastRouteNextHopExpiryTime = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 6, 1, 12), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteNextHopExpiryTime.setDescription('The minimum amount of time remaining before this entry will\n            be aged out.  If ipMcastRouteNextHopState is pruned(1), the\n            remaining time until the prune expires and the state reverts\n            to forwarding(2).  Otherwise, the remaining time until this\n            entry is removed from the table.  The time remaining may be\n            copied from ipMcastRouteExpiryTime if the protocol in use\n            for this entry does not specify next-hop timers.  The value\n            0 indicates that the entry is not subject to aging.')
ipMcastRouteNextHopClosestMemberHops = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 6, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0,256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteNextHopClosestMemberHops.setDescription('The minimum number of hops between this router and any\n            member of this IP multicast group reached via this next-hop\n            on this outgoing interface.  Any IP multicast datagrams for\n            the group that have a TTL (IPv4) or Hop Count (IPv6) less\n            than this number of hops will not be forwarded to this\n            next-hop.\n\n            A value of 0 means all multicast datagrams are forwarded out\n            the interface.  A value of 256 means that no multicast\n            datagrams are forwarded out the interface.\n\n            This is an optimization applied by multicast routing\n            protocols that explicitly track hop counts to downstream\n            listeners.  Multicast protocols that are not aware of hop\n            counts to downstream listeners set this object to 0.')
ipMcastRouteNextHopProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 6, 1, 14), IANAipMRouteProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteNextHopProtocol.setDescription('The routing mechanism via which this next-hop was learned.')
ipMcastRouteNextHopOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 6, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteNextHopOctets.setDescription('The number of octets of multicast packets that have been\n            forwarded using this route.\n\n            Discontinuities in this monotonically increasing value\n            occur at re-initialization of the management system.\n            Discontinuities can also occur as a result of routes being\n            removed and replaced, which can be detected by observing\n            the value of ipMcastRouteNextHopTimeStamp.')
ipMcastRouteNextHopPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 6, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastRouteNextHopPkts.setDescription('The number of packets which have been forwarded using this\n            route.\n\n            Discontinuities in this monotonically increasing value\n            occur at re-initialization of the management system.\n            Discontinuities can also occur as a result of routes being\n            removed and replaced, which can be detected by observing\n            the value of ipMcastRouteNextHopTimeStamp.')
ipMcastBoundaryTable = MibTable((1, 3, 6, 1, 2, 1, 168, 1, 7), )
if mibBuilder.loadTexts: ipMcastBoundaryTable.setDescription("The (conceptual) table listing the system's multicast scope\n            zone boundaries.")
ipMcastBoundaryEntry = MibTableRow((1, 3, 6, 1, 2, 1, 168, 1, 7, 1), ).setIndexNames((0, "IPMCAST-MIB", "ipMcastBoundaryIfIndex"), (0, "IPMCAST-MIB", "ipMcastBoundaryAddressType"), (0, "IPMCAST-MIB", "ipMcastBoundaryAddress"), (0, "IPMCAST-MIB", "ipMcastBoundaryAddressPrefixLength"))
if mibBuilder.loadTexts: ipMcastBoundaryEntry.setDescription("An entry (conceptual row) describing one of this device's\n            multicast scope zone boundaries.\n\n            OIDs are limited to 128 sub-identifiers, but this limit\n            is not enforced by the syntax of this entry.  In practice,\n            this does not present a problem, because IP address types\n            allowed by conformance statements do not exceed this limit.")
ipMcastBoundaryIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 7, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: ipMcastBoundaryIfIndex.setDescription('The IfIndex value for the interface to which this boundary\n            applies.  Packets with a destination address in the\n            associated address/mask range will not be forwarded over\n            this interface.\n\n            For IPv4, zone boundaries cut through links.  Therefore,\n            this is an external interface.  This may be either a\n            physical or virtual interface (tunnel, encapsulation, and\n            so forth.)\n\n            For IPv6, zone boundaries cut through nodes.  Therefore,\n            this is a virtual interface within the node.  This is not\n            an external interface, either real or virtual.  Packets\n            crossing this interface neither arrive at nor leave the\n            node, but only move between zones within the node.')
ipMcastBoundaryAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 7, 1, 2), InetAddressType())
if mibBuilder.loadTexts: ipMcastBoundaryAddressType.setDescription('A value indicating the address family of the address\n            contained in ipMcastBoundaryAddress.  Legal values\n            correspond to the subset of address families for which\n            multicast forwarding is supported.')
ipMcastBoundaryAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 7, 1, 3), InetAddress())
if mibBuilder.loadTexts: ipMcastBoundaryAddress.setDescription('The group address which, when combined with the\n            corresponding value of ipMcastBoundaryAddressPrefixLength,\n            identifies the group range for which the scoped boundary\n            exists.  Scoped IPv4 multicast address ranges must be\n            prefixed by 239.0.0.0/8.  Scoped IPv6 multicast address\n            ranges are FF0x::/16, where x is a valid RFC 4291 multicast\n            scope.\n\n            An IPv6 address prefixed by FF1x::/16 is a non-permanently-\n            assigned address.  An IPv6 address prefixed by FF3x::/16 is\n            a unicast-prefix-based multicast addresses.  A zone boundary\n            for FF0x::/16 implies an identical boundary for these other\n            prefixes.  No separate FF1x::/16 or FF3x::/16 entries exist\n            in this table.\n\n            This address object is only significant up to\n            ipMcastBoundaryAddressPrefixLength bits.  The remaining\n            address bits are set to zero.  This is especially important\n            for this index field, which is part of the index of this\n            entry.  Any non-zero bits would signify an entirely\n            different entry.')
ipMcastBoundaryAddressPrefixLength = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 7, 1, 4), InetAddressPrefixLength())
if mibBuilder.loadTexts: ipMcastBoundaryAddressPrefixLength.setDescription("The length in bits of the mask which when, combined with\n            the corresponding value of ipMcastBoundaryAddress,\n            identifies the group range for which the scoped boundary\n            exists.\n\n            The InetAddressType is given by ipMcastBoundaryAddressType.\n            For values 'ipv4' and 'ipv4z', this object must be in the\n            range 4..32.  For values 'ipv6' and 'ipv6z', this object\n            must be set to 16.")
ipMcastBoundaryTimeStamp = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 7, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastBoundaryTimeStamp.setDescription('The value of sysUpTime at which the multicast boundary\n            information represented by this entry was learned by the\n            router.\n\n            If this information was present at the most recent re-\n            initialization of the local management subsystem, then this\n            object contains a zero value.')
ipMcastBoundaryDroppedMcastOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 7, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastBoundaryDroppedMcastOctets.setDescription('The number of octets of multicast packets that have been\n            dropped as a result of this zone boundary configuration.\n\n            Discontinuities in this monotonically increasing value\n            occur at re-initialization of the management system.\n            Discontinuities can also occur as a result of boundary\n            configuration being removed and replaced, which can be\n            detected by observing the value of\n            ipMcastBoundaryTimeStamp.')
ipMcastBoundaryDroppedMcastPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 7, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastBoundaryDroppedMcastPkts.setDescription('The number of multicast packets that have been dropped as a\n            result of this zone boundary configuration.\n\n            Discontinuities in this monotonically increasing value\n            occur at re-initialization of the management system.\n            Discontinuities can also occur as a result of boundary\n            configuration being removed and replaced, which can be\n            detected by observing the value of\n            ipMcastBoundaryTimeStamp.')
ipMcastBoundaryStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 7, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipMcastBoundaryStatus.setDescription('The status of this row, by which rows in this table can\n            be created and destroyed.\n\n            This status object can be set to active(1) without setting\n            any other columnar objects in this entry.\n\n            All writeable objects in this entry can be modified when the\n            status of this entry is active(1).')
ipMcastBoundaryStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 7, 1, 9), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipMcastBoundaryStorageType.setDescription("The storage type for this row.  Rows having the value\n           'permanent' need not allow write-access to any columnar\n           objects in the row.")
ipMcastScopeNameTable = MibTable((1, 3, 6, 1, 2, 1, 168, 1, 8), )
if mibBuilder.loadTexts: ipMcastScopeNameTable.setDescription('The (conceptual) table listing multicast scope names.')
ipMcastScopeNameEntry = MibTableRow((1, 3, 6, 1, 2, 1, 168, 1, 8, 1), ).setIndexNames((0, "IPMCAST-MIB", "ipMcastScopeNameAddressType"), (0, "IPMCAST-MIB", "ipMcastScopeNameAddress"), (0, "IPMCAST-MIB", "ipMcastScopeNameAddressPrefixLength"), (0, "IPMCAST-MIB", "ipMcastScopeNameLanguage"))
if mibBuilder.loadTexts: ipMcastScopeNameEntry.setDescription('An entry (conceptual row) that names a multicast address\n            scope.\n\n            OIDs are limited to 128 sub-identifiers, but this limit\n            is not enforced by the syntax of this entry.  In practice,\n            this does not present a problem, because IP address types\n            allowed by conformance statements do not exceed this limit.')
ipMcastScopeNameAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 8, 1, 1), InetAddressType())
if mibBuilder.loadTexts: ipMcastScopeNameAddressType.setDescription('A value indicating the address family of the address\n            contained in ipMcastScopeNameAddress.  Legal values\n            correspond to the subset of address families for which\n            multicast forwarding is supported.')
ipMcastScopeNameAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 8, 1, 2), InetAddress())
if mibBuilder.loadTexts: ipMcastScopeNameAddress.setDescription('The group address which, when combined with the\n            corresponding value of ipMcastScopeNameAddressPrefixLength,\n            identifies the group range associated with the multicast\n            scope.  Scoped IPv4 multicast address ranges must be\n            prefixed by 239.0.0.0/8.  Scoped IPv6 multicast address\n            ranges are FF0x::/16, where x is a valid RFC 4291 multicast\n            scope.\n\n            An IPv6 address prefixed by FF1x::/16 is a non-permanently-\n            assigned address.  An IPv6 address prefixed by FF3x::/16 is\n            a unicast-prefix-based multicast addresses.  A scope\n            FF0x::/16 implies an identical scope name for these other\n            prefixes.  No separate FF1x::/16 or FF3x::/16 entries exist\n            in this table.\n\n            This address object is only significant up to\n            ipMcastScopeNameAddressPrefixLength bits.  The remaining\n            address bits are set to zero.  This is especially important\n            for this index field, which is part of the index of this\n            entry.  Any non-zero bits would signify an entirely\n            different entry.')
ipMcastScopeNameAddressPrefixLength = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 8, 1, 3), InetAddressPrefixLength())
if mibBuilder.loadTexts: ipMcastScopeNameAddressPrefixLength.setDescription("The length in bits of the mask which, when combined with\n            the corresponding value of ipMcastScopeNameAddress,\n            identifies the group range associated with the multicast\n            scope.\n\n            The InetAddressType is given by ipMcastScopeNameAddressType.\n            For values 'ipv4' and 'ipv4z', this object must be in the\n            range 4..32.  For values 'ipv6' and 'ipv6z', this object\n            must be set to 16.")
ipMcastScopeNameLanguage = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 8, 1, 4), LangTag())
if mibBuilder.loadTexts: ipMcastScopeNameLanguage.setDescription('Language tag associated with the scope name.')
ipMcastScopeNameString = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 8, 1, 5), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipMcastScopeNameString.setDescription('The textual name associated with the multicast scope.  The\n            value of this object should be suitable for displaying to\n            end-users, such as when allocating a multicast address in\n            this scope.\n\n            When no name is specified, the default value of this object\n            for IPv4 should be the string 239.x.x.x/y with x and y\n            replaced with decimal values to describe the address and\n            mask length associated with the scope.\n\n            When no name is specified, the default value of this object\n            for IPv6 should be the string FF0x::/16, with x replaced by\n            the hexadecimal value for the RFC 4291 multicast scope.\n\n            An IPv6 address prefixed by FF1x::/16 is a non-permanently-\n            assigned address.  An IPv6 address prefixed by FF3x::/16 is\n            a unicast-prefix-based multicast addresses.  A scope\n            FF0x::/16 implies an identical scope name for these other\n            prefixes.  No separate FF1x::/16 or FF3x::/16 entries exist\n            in this table.')
ipMcastScopeNameDefault = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 8, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipMcastScopeNameDefault.setDescription('If true, indicates a preference that the name in the\n            following language should be used by applications if no name\n            is available in a desired language.')
ipMcastScopeNameStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 8, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipMcastScopeNameStatus.setDescription('The status of this row, by which rows in this table can\n            be created and destroyed.  Before the row can be activated,\n            the object ipMcastScopeNameString must be set to a valid\n            value.  All writeable objects in this entry can be modified\n            when the status is active(1).')
ipMcastScopeNameStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 8, 1, 8), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipMcastScopeNameStorageType.setDescription("The storage type for this row.  Rows having the value\n           'permanent' need not allow write-access to any columnar\n           objects in the row.")
ipMcastLocalListenerTable = MibTable((1, 3, 6, 1, 2, 1, 168, 1, 9), )
if mibBuilder.loadTexts: ipMcastLocalListenerTable.setDescription('The (conceptual) table listing local applications or\n            services that have joined multicast groups as listeners.\n\n            Entries exist for all addresses in the multicast range for\n            all applications and services as they are classified on this\n            device.')
ipMcastLocalListenerEntry = MibTableRow((1, 3, 6, 1, 2, 1, 168, 1, 9, 1), ).setIndexNames((0, "IPMCAST-MIB", "ipMcastLocalListenerGroupAddressType"), (0, "IPMCAST-MIB", "ipMcastLocalListenerGroupAddress"), (0, "IPMCAST-MIB", "ipMcastLocalListenerSourceAddressType"), (0, "IPMCAST-MIB", "ipMcastLocalListenerSourceAddress"), (0, "IPMCAST-MIB", "ipMcastLocalListenerSourcePrefixLength"), (0, "IPMCAST-MIB", "ipMcastLocalListenerIfIndex"), (0, "IPMCAST-MIB", "ipMcastLocalListenerRunIndex"))
if mibBuilder.loadTexts: ipMcastLocalListenerEntry.setDescription('An entry (conceptual row) identifying a local application\n            or service that has joined a multicast group as a listener.\n\n            OIDs are limited to 128 sub-identifiers, but this limit\n            is not enforced by the syntax of this entry.  In practice,\n            this does not present a problem, because IP address types\n            allowed by conformance statements do not exceed this limit.')
ipMcastLocalListenerGroupAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 9, 1, 1), InetAddressType())
if mibBuilder.loadTexts: ipMcastLocalListenerGroupAddressType.setDescription('A value indicating the address family of the address\n            contained in ipMcastLocalListenerGroupAddress.  Legal values\n            correspond to the subset of address families for which\n            multicast is supported.')
ipMcastLocalListenerGroupAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 9, 1, 2), InetAddress())
if mibBuilder.loadTexts: ipMcastLocalListenerGroupAddress.setDescription('The IP multicast group for which this entry specifies\n            locally joined applications or services.')
ipMcastLocalListenerSourceAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 9, 1, 3), InetAddressType())
if mibBuilder.loadTexts: ipMcastLocalListenerSourceAddressType.setDescription('A value indicating the address family of the address\n            contained in ipMcastLocalListenerSource.\n\n            A value of unknown(0) indicates a non-source-specific entry,\n            corresponding to all sources in the group.  Otherwise, the\n            value MUST be the same as the value of\n            ipMcastLocalListenerGroupAddressType.')
ipMcastLocalListenerSourceAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 9, 1, 4), InetAddress())
if mibBuilder.loadTexts: ipMcastLocalListenerSourceAddress.setDescription('The network address which, when combined with the\n            corresponding value of the mask specified in\n            ipMcastLocalListenerSourcePrefixLength, identifies the\n            sources for which this entry specifies a local listener.\n\n            This address object is only significant up to\n            ipMcastLocalListenerSourcePrefixLength bits.  The remaining\n            address bits are set to zero.  This is especially important\n            for this index field, which is part of the index of this\n            entry.  Any non-zero bits would signify an entirely\n            different entry.\n\n            For addresses of type ipv4z or ipv6z, the appended zone\n            index is significant even though it lies beyond the prefix\n            length.  The use of these address types indicate that this\n            listener address applies only within the given zone.  Zone\n            index zero is not valid in this table.')
ipMcastLocalListenerSourcePrefixLength = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 9, 1, 5), InetAddressPrefixLength())
if mibBuilder.loadTexts: ipMcastLocalListenerSourcePrefixLength.setDescription("The length in bits of the mask which, when combined with\n            the corresponding value specified in\n            ipMcastLocalListenerSource, identifies the sources for which\n            this entry specifies a local listener.\n\n            The InetAddressType is given by\n            ipMcastLocalListenerSourceAddressType.  For the value\n            'unknown', this object must be zero.  For values 'ipv4' and\n            'ipv4z', this object must be in the range 4..32.  For values\n            'ipv6' and 'ipv6z', this object must be in the range\n            8..128.")
ipMcastLocalListenerIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 9, 1, 6), InterfaceIndex())
if mibBuilder.loadTexts: ipMcastLocalListenerIfIndex.setDescription('The IfIndex value of the interface for which this entry\n            specifies a local listener.')
ipMcastLocalListenerRunIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 9, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastLocalListenerRunIndex.setDescription("A unique value corresponding to a piece of software running\n            on this router or host system.  Where possible, this should\n            be the system's native, unique identification number.\n\n            This identifier is platform-specific.  It may correspond to\n            a process ID or application instance number.\n\n            A value of zero indicates that the application instance(s)\n            cannot be identified.  A value of zero indicates that one or\n            more unidentified applications have joined the specified\n            multicast groups (for the specified sources) as listeners.")
ipMcastZoneTable = MibTable((1, 3, 6, 1, 2, 1, 168, 1, 10), )
if mibBuilder.loadTexts: ipMcastZoneTable.setDescription('The (conceptual) table listing scope zones on this device.')
ipMcastZoneEntry = MibTableRow((1, 3, 6, 1, 2, 1, 168, 1, 10, 1), ).setIndexNames((0, "IPMCAST-MIB", "ipMcastZoneIndex"))
if mibBuilder.loadTexts: ipMcastZoneEntry.setDescription('An entry (conceptual row) describing a scope zone on this\n            device.')
ipMcastZoneIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 10, 1, 1), InetZoneIndex().subtype(subtypeSpec=ValueRangeConstraint(1,4294967295)))
if mibBuilder.loadTexts: ipMcastZoneIndex.setDescription('This zone index uniquely identifies a zone on a device.\n\n            Each zone is for a given scope.  Scope-level information in\n            this table is for the unique scope that corresponds to this\n            zone.\n\n            Zero is a special value used to request the default zone for\n            a given scope.  Zero is not a valid value for this object.\n\n            To test whether ipMcastZoneIndex is the default zone for\n            this scope, test whether ipMcastZoneIndex is equal to\n            ipMcastZoneScopeDefaultZoneIndex.')
ipMcastZoneScopeDefaultZoneIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 10, 1, 2), InetZoneIndex().subtype(subtypeSpec=ValueRangeConstraint(1,4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastZoneScopeDefaultZoneIndex.setDescription('The default zone index for this scope.  This is the zone\n            that this device will use if the default (zero) zone is\n            requested for this scope.\n\n            Zero is not a valid value for this object.')
ipMcastZoneScopeAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 10, 1, 3), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastZoneScopeAddressType.setDescription('The IP address type for which this scope zone exists.')
ipMcastZoneScopeAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 10, 1, 4), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastZoneScopeAddress.setDescription('The multicast group address which, when combined with\n            ipMcastZoneScopeAddressPrefixLength, gives the multicast\n            address range for this scope.  The InetAddressType is given\n            by ipMcastZoneScopeAddressType.\n\n            Scoped IPv4 multicast address ranges are prefixed by\n            239.0.0.0/8.  Scoped IPv6 multicast address ranges are\n            FF0x::/16, where x is a valid RFC 4291 multicast scope.\n\n            An IPv6 address prefixed by FF1x::/16 is a non-permanently-\n            assigned address.  An IPv6 address prefixed by FF3x::/16 is\n            a unicast-prefix-based multicast addresses.  A scope\n            FF0x::/16 implies an identical scope for these other\n            prefixes.  No separate FF1x::/16 or FF3x::/16 entries exist\n            in this table.\n\n            This address object is only significant up to\n            ipMcastZoneScopeAddressPrefixLength bits.  The remaining\n            address bits are set to zero.')
ipMcastZoneScopeAddressPrefixLength = MibTableColumn((1, 3, 6, 1, 2, 1, 168, 1, 10, 1, 5), InetAddressPrefixLength()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMcastZoneScopeAddressPrefixLength.setDescription("The length in bits of the mask which, when combined\n            with ipMcastZoneScopeAddress, gives the multicast address\n            prefix for this scope.\n\n            The InetAddressType is given by ipMcastZoneScopeAddressType.\n            For values 'ipv4' and 'ipv4z', this object must be in the\n            range 4..32.  For values 'ipv6' and 'ipv6z', this object\n            must be set to 16.")
ipMcastMIBConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 168, 2))
ipMcastMIBCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 168, 2, 1))
ipMcastMIBGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 168, 2, 2))
ipMcastMIBComplianceHost = ModuleCompliance((1, 3, 6, 1, 2, 1, 168, 2, 1, 1)).setObjects(*(("IPMCAST-MIB", "ipMcastMIBLocalListenerGroup"), ("IPMCAST-MIB", "ipMcastMIBBasicGroup"),))
if mibBuilder.loadTexts: ipMcastMIBComplianceHost.setDescription('The compliance statement for hosts supporting IPMCAST-MIB.\n\n            Support for either InetAddressType ipv4 or ipv6 is\n            mandatory; support for both InetAddressTypes ipv4 and ipv6\n            is optional.  Support for types ipv4z and ipv6z is\n            optional.\n\n            -- OBJECT     ipMcastLocalListenerGroupAddressType\n            -- SYNTAX     InetAddressType {unknown(0), ipv4(1), ipv6(2),\n            --                             ipv4z(3), ipv6z(4)}\n            -- DESCRIPTION\n            --     This compliance requires support for ipv4 or ipv6.\n            --\n            -- OBJECT     ipMcastLocalListenerGroupAddress\n            -- SYNTAX     InetAddress (SIZE (0|4|8|16|20))\n            -- DESCRIPTION\n            --     This compliance requires support for ipv4 or ipv6.\n            --\n            -- OBJECT     ipMcastLocalListenerSourceAddressType\n            -- SYNTAX     InetAddressType {unknown(0), ipv4(1), ipv6(2),\n            --                             ipv4z(3), ipv6z(4)}\n            -- DESCRIPTION\n            --     This compliance requires support for ipv4 or ipv6.\n            --\n            -- OBJECT     ipMcastLocalListenerSourceAddress\n            -- SYNTAX     InetAddress (SIZE (0|4|8|16|20))\n            -- DESCRIPTION\n            --     This compliance requires support for ipv4 or ipv6.')
ipMcastMIBComplianceRouter = ModuleCompliance((1, 3, 6, 1, 2, 1, 168, 2, 1, 2)).setObjects(*(("IPMCAST-MIB", "ipMcastMIBRouteProtoGroup"), ("IPMCAST-MIB", "ipMcastMIBBasicGroup"), ("IPMCAST-MIB", "ipMcastMIBSsmGroup"), ("IPMCAST-MIB", "ipMcastMIBRouteGroup"),))
if mibBuilder.loadTexts: ipMcastMIBComplianceRouter.setDescription('The compliance statement for routers supporting\n            IPMCAST-MIB.\n\n            Support for either InetAddressType ipv4 or ipv6 is\n            mandatory; support for both InetAddressTypes ipv4 and ipv6\n            is optional.  Support for types ipv4z and ipv6z is\n            optional.\n\n            -- OBJECT     ipMcastSsmRangeAddressType\n            -- SYNTAX     InetAddressType {ipv4(1), ipv6(2), ipv4z(3),\n            --                             ipv6z(4)}\n            -- DESCRIPTION\n            --     This compliance requires support for ipv4 or ipv6.\n            --\n            -- OBJECT     ipMcastSsmRangeAddress\n            -- SYNTAX     InetAddress (SIZE (4|8|16|20))\n            -- DESCRIPTION\n            --     This compliance requires support for ipv4 or ipv6.\n            --\n            -- OBJECT     ipMcastRouteGroupAddressType\n            -- SYNTAX     InetAddressType {unknown(0), ipv4(1), ipv6(2),\n            --                             ipv4z(3), ipv6z(4)}\n            -- DESCRIPTION\n            --     This compliance requires support for unknown and\n            --     either ipv4 or ipv6.\n            --\n            -- OBJECT     ipMcastRouteGroup\n            -- SYNTAX     InetAddress (SIZE (0|4|8|16|20))\n            -- DESCRIPTION\n            --     This compliance requires support for unknown and\n            --     either ipv4 or ipv6.\n            --\n            -- OBJECT     ipMcastRouteSourceAddressType\n            -- SYNTAX     InetAddressType {unknown(0), ipv4(1), ipv6(2),\n            --                             ipv4z(3), ipv6z(4)}\n            -- DESCRIPTION\n            --     This compliance requires support for unknown and\n            --     either ipv4 or ipv6.\n            --\n            -- OBJECT     ipMcastRouteSource\n            -- SYNTAX     InetAddress (SIZE (0|4|8|16|20))\n            -- DESCRIPTION\n            --     This compliance requires support for unknown and\n            --     either ipv4 or ipv6.\n            --\n            -- OBJECT     ipMcastRouteNextHopGroupAddressType\n            -- SYNTAX     InetAddressType {unknown(0), ipv4(1), ipv6(2),\n            --                             ipv4z(3), ipv6z(4)}\n            -- DESCRIPTION\n            --     This compliance requires support for unknown and\n            --     either ipv4 or ipv6.\n            --\n            -- OBJECT     ipMcastRouteNextHopGroup\n            -- SYNTAX     InetAddress (SIZE (0|4|8|16|20))\n            -- DESCRIPTION\n            --     This compliance requires support for unknown and\n            --     either ipv4 or ipv6.\n            --\n            -- OBJECT     ipMcastRouteNextHopSourceAddressType\n            -- SYNTAX     InetAddressType {unknown(0), ipv4(1), ipv6(2),\n            --                              ipv4z(3), ipv6z(4)}\n            -- DESCRIPTION\n            --     This compliance requires support for unknown and\n            --     either ipv4 or ipv6.\n            --\n            -- OBJECT     ipMcastRouteNextHopSource\n            -- SYNTAX     InetAddress (SIZE (0|4|8|16|20))\n            -- DESCRIPTION\n            --     This compliance requires support for unknown and\n            --     either ipv4 or ipv6.\n            --\n            -- OBJECT     ipMcastRouteNextHopAddressType\n            -- SYNTAX     InetAddressType {unknown(0), ipv4(1), ipv6(2),\n            --                             ipv4z(3), ipv6z(4)}\n            -- DESCRIPTION\n            --     This compliance requires support for unknown and\n            --     either ipv4 or ipv6.\n            --\n            -- OBJECT     ipMcastRouteNextHopAddress\n            -- SYNTAX     InetAddress (SIZE (0|4|8|16|20))\n            -- DESCRIPTION\n            --     This compliance requires support for unknown and\n            --     either ipv4 or ipv6.')
ipMcastMIBComplianceBorderRouter = ModuleCompliance((1, 3, 6, 1, 2, 1, 168, 2, 1, 3)).setObjects(*(("IPMCAST-MIB", "ipMcastMIBRouteProtoGroup"), ("IPMCAST-MIB", "ipMcastMIBBasicGroup"), ("IPMCAST-MIB", "ipMcastMIBSsmGroup"), ("IPMCAST-MIB", "ipMcastMIBRouteGroup"), ("IPMCAST-MIB", "ipMcastMIBBoundaryIfGroup"), ("IPMCAST-MIB", "ipMcastMIBScopeNameGroup"),))
if mibBuilder.loadTexts: ipMcastMIBComplianceBorderRouter.setDescription('The compliance statement for routers on scope\n            boundaries supporting IPMCAST-MIB.\n\n            Support for either InetAddressType ipv4z or ipv6z is\n            mandatory; support for both InetAddressTypes ipv4z and\n            ipv6z is optional.\n\n            -- OBJECT     ipMcastSsmRangeAddressType\n            -- SYNTAX     InetAddressType {ipv4(1), ipv6(2), ipv4z(3),\n            --                             ipv6z(4)}\n            -- DESCRIPTION\n            --     This compliance requires support for ipv4 or ipv6.\n            --\n            -- OBJECT     ipMcastSsmRangeAddress\n            -- SYNTAX     InetAddress (SIZE (4|8|16|20))\n            -- DESCRIPTION\n            --     This compliance requires support for ipv4 or ipv6.\n            --\n            -- OBJECT     ipMcastRouteGroupAddressType\n            -- SYNTAX     InetAddressType {unknown(0), ipv4(1), ipv6(2),\n            --                             ipv4z(3), ipv6z(4)}\n            -- DESCRIPTION\n            --     This compliance requires support for unknown and\n            --     either ipv4 or ipv6.\n            --\n            -- OBJECT     ipMcastRouteGroup\n            -- SYNTAX     InetAddress (SIZE (0|4|8|16|20))\n            -- DESCRIPTION\n            --     This compliance requires support for unknown and\n            --     either ipv4 and ipv4z or ipv6 and ipv6z.\n            --\n            -- OBJECT     ipMcastRouteSourceAddressType\n            -- SYNTAX     InetAddressType {unknown(0), ipv4(1), ipv6(2),\n            --                             ipv4z(3), ipv6z(4)}\n            -- DESCRIPTION\n            --     This compliance requires support for unknown and\n            --     either ipv4 and ipv4z or ipv6 and ipv6z.\n            --\n            -- OBJECT     ipMcastRouteSource\n            -- SYNTAX     InetAddress (SIZE (0|4|8|16|20))\n            -- DESCRIPTION\n            --     This compliance requires support for unknown and\n            --     either ipv4 and ipv4z or ipv6 and ipv6z.\n            --\n            -- OBJECT     ipMcastRouteNextHopGroupAddressType\n            -- SYNTAX     InetAddressType {unknown(0), ipv4(1), ipv6(2),\n            --                             ipv4z(3), ipv6z(4)}\n            -- DESCRIPTION\n            --     This compliance requires support for unknown and\n            --     either ipv4 and ipv4z or ipv6 and ipv6z.\n            --\n            -- OBJECT     ipMcastRouteNextHopGroup\n            -- SYNTAX     InetAddress (SIZE (0|4|8|16|20))\n            -- DESCRIPTION\n            --     This compliance requires support for unknown and\n            --     either ipv4 and ipv4z or ipv6 and ipv6z.\n            --\n            -- OBJECT     ipMcastRouteNextHopSourceAddressType\n            -- SYNTAX     InetAddressType {unknown(0), ipv4(1), ipv6(2),\n            --                             ipv4z(3), ipv6z(4)}\n            -- DESCRIPTION\n            --     This compliance requires support for unknown and\n            --     either ipv4 and ipv4z or ipv6 and ipv6z.\n            --\n            -- OBJECT     ipMcastRouteNextHopSource\n            -- SYNTAX     InetAddress (SIZE (0|4|8|16|20))\n            -- DESCRIPTION\n            --     This compliance requires support for unknown and\n            --     either ipv4 and ipv4z or ipv6 and ipv6z.\n            --\n            -- OBJECT     ipMcastRouteNextHopAddressType\n            -- SYNTAX     InetAddressType {unknown(0), ipv4(1), ipv6(2),\n            --                             ipv4z(3), ipv6z(4)}\n            -- DESCRIPTION\n            --     This compliance requires support for unknown and\n            --     either ipv4 and ipv4z or ipv6 and ipv6z.\n            --\n            -- OBJECT     ipMcastRouteNextHopAddress\n            -- SYNTAX     InetAddress (SIZE (0|4|8|16|20))\n            -- DESCRIPTION\n            --     This compliance requires support for unknown and\n            --     either ipv4 and ipv4z or ipv6 and ipv6z.\n            --\n            -- OBJECT     ipMcastBoundaryAddressType\n            -- SYNTAX     InetAddressType {ipv4(1), ipv6(2)}\n            -- DESCRIPTION\n            --     This compliance requires support for ipv4 or ipv6.\n            --\n            -- OBJECT     ipMcastBoundaryAddress\n            -- SYNTAX     InetAddress (SIZE (4|16)\n            -- DESCRIPTION\n            --     This compliance requires support for ipv4 or ipv6.\n            --\n            -- OBJECT     ipMcastScopeNameAddressType\n            -- SYNTAX     InetAddressType {ipv4(1), ipv6(2)}\n            -- DESCRIPTION\n            --     This compliance requires support for ipv4 or ipv6.\n            --\n            -- OBJECT     ipMcastScopeNameAddress\n            -- SYNTAX     InetAddress (SIZE (4|16)\n            -- DESCRIPTION\n            --     This compliance requires support for ipv4 or ipv6.')
ipMcastMIBBasicGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 168, 2, 2, 1)).setObjects(*(("IPMCAST-MIB", "ipMcastEnabled"), ("IPMCAST-MIB", "ipMcastRouteEntryCount"), ("IPMCAST-MIB", "ipMcastDeviceConfigStorageType"),))
if mibBuilder.loadTexts: ipMcastMIBBasicGroup.setDescription('A collection of objects to support basic management of IP\n            Multicast protocols.')
ipMcastMIBSsmGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 168, 2, 2, 2)).setObjects(*(("IPMCAST-MIB", "ipMcastSsmRangeRowStatus"), ("IPMCAST-MIB", "ipMcastSsmRangeStorageType"),))
if mibBuilder.loadTexts: ipMcastMIBSsmGroup.setDescription('A collection of objects to support management of Source-\n            Specific Multicast routing.')
ipMcastMIBRouteGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 168, 2, 2, 3)).setObjects(*(("IPMCAST-MIB", "ipMcastInterfaceTtl"), ("IPMCAST-MIB", "ipMcastInterfaceRateLimit"), ("IPMCAST-MIB", "ipMcastInterfaceStorageType"), ("IPMCAST-MIB", "ipMcastRouteUpstreamNeighborType"), ("IPMCAST-MIB", "ipMcastRouteUpstreamNeighbor"), ("IPMCAST-MIB", "ipMcastRouteInIfIndex"), ("IPMCAST-MIB", "ipMcastRouteTimeStamp"), ("IPMCAST-MIB", "ipMcastRouteExpiryTime"), ("IPMCAST-MIB", "ipMcastRouteNextHopState"), ("IPMCAST-MIB", "ipMcastRouteNextHopTimeStamp"), ("IPMCAST-MIB", "ipMcastRouteNextHopExpiryTime"),))
if mibBuilder.loadTexts: ipMcastMIBRouteGroup.setDescription('A collection of objects to support basic management of IP\n            Multicast routing.')
ipMcastMIBRouteDiagnosticsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 168, 2, 2, 4)).setObjects(*(("IPMCAST-MIB", "ipMcastRoutePkts"), ("IPMCAST-MIB", "ipMcastRouteTtlDropPackets"), ("IPMCAST-MIB", "ipMcastRouteDifferentInIfPackets"),))
if mibBuilder.loadTexts: ipMcastMIBRouteDiagnosticsGroup.setDescription('A collection of routing diagnostic packet counters.')
ipMcastMIBPktsOutGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 168, 2, 2, 5)).setObjects(*(("IPMCAST-MIB", "ipMcastRouteNextHopTimeStamp"), ("IPMCAST-MIB", "ipMcastRouteNextHopPkts"),))
if mibBuilder.loadTexts: ipMcastMIBPktsOutGroup.setDescription('A collection of objects to support management of packet\n            counters for each outgoing interface entry of a route.')
ipMcastMIBHopCountGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 168, 2, 2, 6)).setObjects(*(("IPMCAST-MIB", "ipMcastRouteNextHopClosestMemberHops"),))
if mibBuilder.loadTexts: ipMcastMIBHopCountGroup.setDescription('A collection of objects to support management of the use of\n            hop counts in IP Multicast routing.')
ipMcastMIBRouteOctetsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 168, 2, 2, 7)).setObjects(*(("IPMCAST-MIB", "ipMcastRouteTimeStamp"), ("IPMCAST-MIB", "ipMcastRouteOctets"), ("IPMCAST-MIB", "ipMcastRouteTtlDropOctets"), ("IPMCAST-MIB", "ipMcastRouteDifferentInIfOctets"), ("IPMCAST-MIB", "ipMcastRouteNextHopTimeStamp"), ("IPMCAST-MIB", "ipMcastRouteNextHopOctets"),))
if mibBuilder.loadTexts: ipMcastMIBRouteOctetsGroup.setDescription('A collection of objects to support management of octet\n            counters for each forwarding entry.')
ipMcastMIBRouteBpsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 168, 2, 2, 8)).setObjects(*(("IPMCAST-MIB", "ipMcastRouteBps"),))
if mibBuilder.loadTexts: ipMcastMIBRouteBpsGroup.setDescription('A collection of objects to support sampling of data rate\n            in bits per second for each forwarding entry.')
ipMcastMIBRouteProtoGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 168, 2, 2, 9)).setObjects(*(("IPMCAST-MIB", "ipMcastRouteProtocol"), ("IPMCAST-MIB", "ipMcastRouteRtProtocol"), ("IPMCAST-MIB", "ipMcastRouteRtAddressType"), ("IPMCAST-MIB", "ipMcastRouteRtAddress"), ("IPMCAST-MIB", "ipMcastRouteRtPrefixLength"), ("IPMCAST-MIB", "ipMcastRouteRtType"), ("IPMCAST-MIB", "ipMcastRouteNextHopProtocol"),))
if mibBuilder.loadTexts: ipMcastMIBRouteProtoGroup.setDescription('A collection of objects providing information on the\n            relationship between multicast routing information and the\n            IP Forwarding Table.')
ipMcastMIBLocalListenerGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 168, 2, 2, 10)).setObjects(*(("IPMCAST-MIB", "ipMcastLocalListenerRunIndex"),))
if mibBuilder.loadTexts: ipMcastMIBLocalListenerGroup.setDescription('A collection of objects to support management of local\n            listeners on hosts or routers.')
ipMcastMIBBoundaryIfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 168, 2, 2, 11)).setObjects(*(("IPMCAST-MIB", "ipMcastBoundaryTimeStamp"), ("IPMCAST-MIB", "ipMcastBoundaryDroppedMcastOctets"), ("IPMCAST-MIB", "ipMcastBoundaryDroppedMcastPkts"), ("IPMCAST-MIB", "ipMcastBoundaryStatus"), ("IPMCAST-MIB", "ipMcastBoundaryStorageType"), ("IPMCAST-MIB", "ipMcastZoneScopeDefaultZoneIndex"), ("IPMCAST-MIB", "ipMcastZoneScopeAddressType"), ("IPMCAST-MIB", "ipMcastZoneScopeAddress"), ("IPMCAST-MIB", "ipMcastZoneScopeAddressPrefixLength"),))
if mibBuilder.loadTexts: ipMcastMIBBoundaryIfGroup.setDescription('A collection of objects to support management of multicast\n            scope zone boundaries.')
ipMcastMIBScopeNameGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 168, 2, 2, 12)).setObjects(*(("IPMCAST-MIB", "ipMcastScopeNameString"), ("IPMCAST-MIB", "ipMcastScopeNameDefault"), ("IPMCAST-MIB", "ipMcastScopeNameStatus"), ("IPMCAST-MIB", "ipMcastScopeNameStorageType"),))
if mibBuilder.loadTexts: ipMcastMIBScopeNameGroup.setDescription('A collection of objects to support management of multicast\n            address scope names.')
mibBuilder.exportSymbols("IPMCAST-MIB", ipMcastSsmRangePrefixLength=ipMcastSsmRangePrefixLength, ipMcastZoneTable=ipMcastZoneTable, ipMcastRouteNextHopSourceAddressType=ipMcastRouteNextHopSourceAddressType, ipMcastLocalListenerTable=ipMcastLocalListenerTable, ipMcastBoundaryDroppedMcastPkts=ipMcastBoundaryDroppedMcastPkts, ipMcastLocalListenerIfIndex=ipMcastLocalListenerIfIndex, ipMcastLocalListenerRunIndex=ipMcastLocalListenerRunIndex, PYSNMP_MODULE_ID=ipMcastMIB, ipMcastRouteNextHopTable=ipMcastRouteNextHopTable, ipMcastSsmRangeAddress=ipMcastSsmRangeAddress, ipMcastBoundaryEntry=ipMcastBoundaryEntry, ipMcastMIBComplianceRouter=ipMcastMIBComplianceRouter, ipMcastZoneScopeAddress=ipMcastZoneScopeAddress, ipMcastRouteSourcePrefixLength=ipMcastRouteSourcePrefixLength, ipMcastInterfaceStorageType=ipMcastInterfaceStorageType, ipMcastZoneScopeAddressPrefixLength=ipMcastZoneScopeAddressPrefixLength, ipMcastMIBHopCountGroup=ipMcastMIBHopCountGroup, ipMcastMIBPktsOutGroup=ipMcastMIBPktsOutGroup, ipMcastRouteGroupAddressType=ipMcastRouteGroupAddressType, ipMcastMIBRouteDiagnosticsGroup=ipMcastMIBRouteDiagnosticsGroup, ipMcastMIBRouteOctetsGroup=ipMcastMIBRouteOctetsGroup, ipMcastScopeNameTable=ipMcastScopeNameTable, ipMcastRouteNextHopPkts=ipMcastRouteNextHopPkts, ipMcastRouteGroup=ipMcastRouteGroup, ipMcastMIBGroups=ipMcastMIBGroups, ipMcastMIBLocalListenerGroup=ipMcastMIBLocalListenerGroup, ipMcastRouteExpiryTime=ipMcastRouteExpiryTime, ipMcastInterfaceIPVersion=ipMcastInterfaceIPVersion, ipMcastScopeNameEntry=ipMcastScopeNameEntry, ipMcastRouteNextHopAddress=ipMcastRouteNextHopAddress, ipMcastRouteProtocol=ipMcastRouteProtocol, ipMcastRouteDifferentInIfPackets=ipMcastRouteDifferentInIfPackets, ipMcastMIB=ipMcastMIB, ipMcastRouteNextHopIfIndex=ipMcastRouteNextHopIfIndex, ipMcastDeviceConfigStorageType=ipMcastDeviceConfigStorageType, ipMcastMIBRouteBpsGroup=ipMcastMIBRouteBpsGroup, ipMcastBoundaryAddressType=ipMcastBoundaryAddressType, ipMcastInterfaceEntry=ipMcastInterfaceEntry, ipMcastLocalListenerSourceAddressType=ipMcastLocalListenerSourceAddressType, ipMcastScopeNameStatus=ipMcastScopeNameStatus, ipMcastBoundaryTimeStamp=ipMcastBoundaryTimeStamp, ipMcastRouteNextHopGroupAddressType=ipMcastRouteNextHopGroupAddressType, ipMcastSsmRangeEntry=ipMcastSsmRangeEntry, ipMcastRouteTable=ipMcastRouteTable, ipMcastRouteRtProtocol=ipMcastRouteRtProtocol, ipMcastRouteNextHopGroupPrefixLength=ipMcastRouteNextHopGroupPrefixLength, ipMcastLocalListenerSourceAddress=ipMcastLocalListenerSourceAddress, ipMcastScopeNameAddress=ipMcastScopeNameAddress, ipMcastZoneScopeDefaultZoneIndex=ipMcastZoneScopeDefaultZoneIndex, ipMcastRouteNextHopClosestMemberHops=ipMcastRouteNextHopClosestMemberHops, ipMcastZoneEntry=ipMcastZoneEntry, ipMcastRouteTtlDropOctets=ipMcastRouteTtlDropOctets, ipMcastRouteInIfIndex=ipMcastRouteInIfIndex, ipMcastRouteNextHopSource=ipMcastRouteNextHopSource, ipMcastRouteNextHopAddressType=ipMcastRouteNextHopAddressType, ipMcastSsmRangeTable=ipMcastSsmRangeTable, ipMcastInterfaceTtl=ipMcastInterfaceTtl, ipMcastRouteTimeStamp=ipMcastRouteTimeStamp, ipMcastRouteNextHopGroup=ipMcastRouteNextHopGroup, ipMcastSsmRangeStorageType=ipMcastSsmRangeStorageType, ipMcastRouteNextHopTimeStamp=ipMcastRouteNextHopTimeStamp, ipMcastRouteRtAddressType=ipMcastRouteRtAddressType, ipMcastRoutePkts=ipMcastRoutePkts, ipMcastRouteEntryCount=ipMcastRouteEntryCount, ipMcastZoneIndex=ipMcastZoneIndex, ipMcastInterfaceIfIndex=ipMcastInterfaceIfIndex, ipMcastRouteNextHopSourcePrefixLength=ipMcastRouteNextHopSourcePrefixLength, ipMcastRouteBps=ipMcastRouteBps, ipMcastBoundaryAddressPrefixLength=ipMcastBoundaryAddressPrefixLength, ipMcastScopeNameDefault=ipMcastScopeNameDefault, ipMcastRouteEntry=ipMcastRouteEntry, ipMcastRouteSource=ipMcastRouteSource, ipMcastInterfaceRateLimit=ipMcastInterfaceRateLimit, ipMcastRouteNextHopExpiryTime=ipMcastRouteNextHopExpiryTime, ipMcastMIBComplianceHost=ipMcastMIBComplianceHost, ipMcastBoundaryStorageType=ipMcastBoundaryStorageType, ipMcastBoundaryDroppedMcastOctets=ipMcastBoundaryDroppedMcastOctets, ipMcastMIBConformance=ipMcastMIBConformance, ipMcastZoneScopeAddressType=ipMcastZoneScopeAddressType, ipMcastRouteUpstreamNeighbor=ipMcastRouteUpstreamNeighbor, ipMcastScopeNameStorageType=ipMcastScopeNameStorageType, ipMcastMIBComplianceBorderRouter=ipMcastMIBComplianceBorderRouter, ipMcastLocalListenerSourcePrefixLength=ipMcastLocalListenerSourcePrefixLength, ipMcastBoundaryTable=ipMcastBoundaryTable, ipMcastRouteOctets=ipMcastRouteOctets, ipMcastEnabled=ipMcastEnabled, ipMcastLocalListenerEntry=ipMcastLocalListenerEntry, ipMcastLocalListenerGroupAddress=ipMcastLocalListenerGroupAddress, ipMcastSsmRangeAddressType=ipMcastSsmRangeAddressType, ipMcastRouteNextHopEntry=ipMcastRouteNextHopEntry, ipMcastMIBRouteProtoGroup=ipMcastMIBRouteProtoGroup, ipMcastRouteRtPrefixLength=ipMcastRouteRtPrefixLength, ipMcastMIBBasicGroup=ipMcastMIBBasicGroup, ipMcastMIBScopeNameGroup=ipMcastMIBScopeNameGroup, ipMcastScopeNameString=ipMcastScopeNameString, ipMcastRouteGroupPrefixLength=ipMcastRouteGroupPrefixLength, ipMcastMIBCompliances=ipMcastMIBCompliances, ipMcastRouteSourceAddressType=ipMcastRouteSourceAddressType, ipMcastRouteNextHopProtocol=ipMcastRouteNextHopProtocol, ipMcastMIBSsmGroup=ipMcastMIBSsmGroup, ipMcastSsmRangeRowStatus=ipMcastSsmRangeRowStatus, ipMcastRouteNextHopOctets=ipMcastRouteNextHopOctets, ipMcastRouteRtType=ipMcastRouteRtType, ipMcastInterfaceTable=ipMcastInterfaceTable, ipMcastBoundaryAddress=ipMcastBoundaryAddress, ipMcastRouteUpstreamNeighborType=ipMcastRouteUpstreamNeighborType, ipMcastScopeNameLanguage=ipMcastScopeNameLanguage, ipMcastRouteDifferentInIfOctets=ipMcastRouteDifferentInIfOctets, ipMcastScopeNameAddressType=ipMcastScopeNameAddressType, ipMcastRouteNextHopState=ipMcastRouteNextHopState, ipMcastBoundaryIfIndex=ipMcastBoundaryIfIndex, ipMcastMIBRouteGroup=ipMcastMIBRouteGroup, ipMcastScopeNameAddressPrefixLength=ipMcastScopeNameAddressPrefixLength, ipMcastRouteRtAddress=ipMcastRouteRtAddress, ipMcast=ipMcast, ipMcastRouteTtlDropPackets=ipMcastRouteTtlDropPackets, ipMcastBoundaryStatus=ipMcastBoundaryStatus, ipMcastLocalListenerGroupAddressType=ipMcastLocalListenerGroupAddressType, ipMcastMIBBoundaryIfGroup=ipMcastMIBBoundaryIfGroup)
