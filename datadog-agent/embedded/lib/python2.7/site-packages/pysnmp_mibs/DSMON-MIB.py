#
# PySNMP MIB module DSMON-MIB (http://pysnmp.sf.net)
# ASN.1 source http://mibs.snmplabs.com:80/asn1/DSMON-MIB
# Produced by pysmi-0.0.7 at Sun Feb 14 00:11:25 2016
# On host bldfarm platform Linux version 4.1.13-100.fc21.x86_64 by user goose
# Using Python version 3.5.0 (default, Jan  5 2016, 17:11:52) 
#
( OctetString, Integer, ObjectIdentifier, ) = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion")
( Dscp, ) = mibBuilder.importSymbols("DIFFSERV-DSCP-TC", "Dscp")
( ZeroBasedCounter64, CounterBasedGauge64, ) = mibBuilder.importSymbols("HCNUM-TC", "ZeroBasedCounter64", "CounterBasedGauge64")
( rmon, OwnerString, ) = mibBuilder.importSymbols("RMON-MIB", "rmon", "OwnerString")
( ZeroBasedCounter32, DataSource, TimeFilter, LastCreateTime, protocolDirLocalIndex, ) = mibBuilder.importSymbols("RMON2-MIB", "ZeroBasedCounter32", "DataSource", "TimeFilter", "LastCreateTime", "protocolDirLocalIndex")
( SnmpAdminString, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
( ObjectGroup, ModuleCompliance, NotificationGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
( Integer32, TimeTicks, iso, NotificationType, Unsigned32, Counter64, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, IpAddress, ObjectIdentity, Bits, Counter32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "TimeTicks", "iso", "NotificationType", "Unsigned32", "Counter64", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "IpAddress", "ObjectIdentity", "Bits", "Counter32")
( TruthValue, TextualConvention, RowStatus, DisplayString, TimeStamp, ) = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "TextualConvention", "RowStatus", "DisplayString", "TimeStamp")
dsmonMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 16, 26)).setRevisions(("2002-05-31 00:00",))
if mibBuilder.loadTexts: dsmonMIB.setLastUpdated('200205310000Z')
if mibBuilder.loadTexts: dsmonMIB.setOrganization('IETF RMONMIB Working Group')
if mibBuilder.loadTexts: dsmonMIB.setContactInfo('        Andy Bierman\n                     Cisco Systems, Inc.\n                     RMONMIB WG Chair and DSMON MIB Editor\n\n             Postal: 170 West Tasman Drive\n                     San Jose, CA USA 95134\n                Tel: +1 408 527-3711\n             E-mail: abierman@cisco.com\n\n             Send comments to <rmonmib@ietf.org>\n             Mailing list subscription info:\n                 http://www.ietf.org/mailman/listinfo/rmonmib ')
if mibBuilder.loadTexts: dsmonMIB.setDescription("This module defines Remote Monitoring MIB extensions for\n            Differentiated Services enabled networks.\n\n             RMON DIFFSERV DSCP statistics\n              * Per Counter Aggregation Group\n              * Per Protocol Per Counter Aggregation Group\n              * Per Counter Aggregation Group Per Host\n\n              * Per Counter Aggregation Group Per Host-Pair\n\n            In order to maintain the RMON 'look-and-feel' and semantic\n            consistency, some of the text from the RMON-2 and HC-RMON\n            MIBs by Steve Waldbusser has been adapted for use in this\n            MIB.")
dsmonObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 26, 1))
dsmonNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 26, 2))
dsmonConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 26, 3))
dsmonAggObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 26, 1, 1))
dsmonStatsObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 26, 1, 2))
dsmonPdistObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 26, 1, 3))
dsmonHostObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 26, 1, 4))
dsmonCapsObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 26, 1, 5))
dsmonMatrixObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 26, 1, 6))
class DsmonCounterAggGroupIndex(Integer32, TextualConvention):
    subtypeSpec = Integer32.subtypeSpec+ValueRangeConstraint(0,2147483647)

class DsmonCounterAggProfileIndex(Integer32, TextualConvention):
    subtypeSpec = Integer32.subtypeSpec+ValueRangeConstraint(1,2147483647)

dsmonCapabilities = MibScalar((1, 3, 6, 1, 2, 1, 16, 26, 1, 5, 1), Bits().clone(namedValues=NamedValues(("dsmonCounterAggControl", 0), ("dsmonStats", 1), ("dsmonStatsOvfl", 2), ("dsmonStatsHC", 3), ("dsmonPdist", 4), ("dsmonPdistOvfl", 5), ("dsmonPdistHC", 6), ("dsmonHost", 7), ("dsmonHostOvfl", 8), ("dsmonHostHC", 9), ("dsmonCaps", 10), ("dsmonMatrix", 11), ("dsmonMatrixOvfl", 12), ("dsmonMatrixHC", 13),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonCapabilities.setDescription("This object provides an indication of the DSMON groups\n            supported by the agent.  If a bit is set, then the agent\n            implements all of the objects in the DSMON object group,\n            where bit 'n' represents the MIB group identified by the\n            OBJECT IDENTIFIER value { dsmonGroups n+1 }.")
dsmonMaxAggGroups = MibScalar((1, 3, 6, 1, 2, 1, 16, 26, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2,64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMaxAggGroups.setDescription("The maximum number of counter aggregation groups that this\n            agent can support.  The agent will allow this number of\n            distinct groups to be configured in the\n            dsmonAggProfileTable, numbered from '0' to\n            'dsmonMaxAggGroups - 1', for each counter aggregation\n            profile entry supported by the agent.\n\n            The agent MUST NOT lower this value during system operation,\n            and SHOULD set this object to an appropriate value during\n            system initialization.")
dsmonAggControlLocked = MibScalar((1, 3, 6, 1, 2, 1, 16, 26, 1, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsmonAggControlLocked.setDescription("Controls the setup of counter aggregation groups for this\n            agent.\n\n            If this object contains the value 'true', then write access\n            to the objects in the dsmonAggControlTable (except the\n            dsmonAggControlOwner object), dsmonAggProfileTable, and\n            dsmonAggGroupTable is not permitted, and data collection is\n            possible.  This object only controls write access to these\n            MIB objects.  The DSMON data collection control tables\n            (e.g., dsmonHostCtlTable) can be configured at any time,\n            regardless of the value of this object.\n\n            If this object contains the value 'false', write access to\n            the objects in the dsmonAggControlTable,\n            dsmonAggProfileTable, and dsmonAggGroupTable is permitted,\n            and data collection is not possible.  In addition, all\n            objects in all DSMON data tables (e.g., dsmonStatsTable)\n            shall be deleted.\n\n            An agent is not required to process SNMP Set Requests for\n            this object in conjunction with other objects from this MIB.\n            This is intended to simplify the processing of Set Requests\n            for tables such as the dsmonAggProfileTable, by eliminating\n            the possibility that a single Set PDU will contain multiple\n            varbinds which are in conflict, such as a PDU which both\n            modifies the dsmonAggProfileTable and locks the\n\n            dsmonAggProfileTable at the same time.\n\n            Note that the agent is not required to validate the entire\n            counter aggregation configuration when an attempt is made to\n            transition an instance of this object from 'true' to\n            'false'.  That validation is done if and when a DSMON data\n            collection is activated.\n\n            An agent is required to reactivate any suspended data\n            collections when this object transitions to 'true', Each\n            active data control entry (e.g., dsmonStatsControlEntry),\n            will be validated with respect to the new counter\n            aggregation configuration.  If the counter aggregation\n            profile referenced in the data collection is valid, then\n            that collection will be restarted.  Otherwise, the RowStatus\n            object (e.g., dsmonStatsControlStatus) will be set to\n            'notReady' for that collection control entry.")
dsmonAggControlChanges = MibScalar((1, 3, 6, 1, 2, 1, 16, 26, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonAggControlChanges.setDescription("This object counts the number of times the value of the\n            dsmonAggControlLocked object has changed.  A management\n            station can use this object to detect if counters in the\n            DSMON data tables (e.g., dsmonStatsEntry) have been deleted\n            and recreated between polls.\n\n            This object shall be incremented by one each time the\n            dsmonAggControlLocked object changes from 'false' to 'true',\n            or from 'true' to 'false'.")
dsmonAggControlLastChangeTime = MibScalar((1, 3, 6, 1, 2, 1, 16, 26, 1, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonAggControlLastChangeTime.setDescription("This object identifies the value of sysUpTime at the moment\n            the dsmonAggControlLocked object was last modified.  A\n            management station can use this object to detect if counters\n            in the DSMON data tables (e.g., dsmonStatsEntry) have been\n            deleted and recreated between polls.\n\n            This object shall be updated with the current value of\n            sysUpTime, if the dsmonAggControlLocked object changes from\n\n            'false' to 'true', or from 'true' to 'false'.\n\n            Upon system initialization, this object shall contain the\n            value zero.")
dsmonAggControlTable = MibTable((1, 3, 6, 1, 2, 1, 16, 26, 1, 1, 5), )
if mibBuilder.loadTexts: dsmonAggControlTable.setDescription("This table provides an overall description and control\n            point for all dsmonAggProfileEntries with the same\n            dsmonAggControlIndex value.\n\n            A management application SHOULD create a counter aggregation\n            profile by first creating and activating an entry in this\n            table.  This will cause the agent to create a set of 64\n            dsmonAggProfileEntries on behalf of this control entry.  An\n            application can then set the individual counter aggregation\n            group assignments for each of the 64 DSCP values,\n\n            This table MUST NOT be modified if the dsmonAggControlLocked\n            object is equal to 'true'.\n\n            Note that an agent MAY choose to limit the actual number of\n            entries which may be created in this table, and\n            (independently) the number of counter aggregation profiles\n            which may be applied to a particular data source.  In this\n            case, the agent SHOULD return an error-status of\n            'resourceUnavailable(13)', as per section 4.2.5 of the\n            'Protocol Operations for SNMPv2' specification [RFC1905].\n\n            The agent SHOULD support non-volatile configuration of this\n            table, and upon system initialization, the table SHOULD be\n            initialized with the saved values.  Otherwise, each\n            potential counter aggregation group description string\n            SHOULD contain the empty string.")
dsmonAggControlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 26, 1, 1, 5, 1), ).setIndexNames((0, "DSMON-MIB", "dsmonAggControlIndex"))
if mibBuilder.loadTexts: dsmonAggControlEntry.setDescription('A conceptual row in the dsmonAggControlTable.')
dsmonAggControlIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 1, 5, 1, 1), DsmonCounterAggProfileIndex())
if mibBuilder.loadTexts: dsmonAggControlIndex.setDescription('An arbitrary integer index value used to identify the\n            counter aggregation profile specified by this control\n            entry.')
dsmonAggControlDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 1, 5, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0,64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonAggControlDescr.setDescription("An administratively assigned description of the counter\n            aggregation profile identified by this entry.\n\n            Upon first creation of an instance of this object, the agent\n            SHOULD set this object to the empty string.  If the agent\n            supports non-volatile storage, then this object SHOULD be\n            re-initialized with its stored value after a system reboot.\n\n            This object MUST NOT be modified if the associated\n            dsmonAggControlStatus object is equal to 'active', or the\n            dsmonAggControlLocked object is equal to 'true'.")
dsmonAggControlOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 1, 5, 1, 3), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonAggControlOwner.setDescription('The entity that configured this entry and is therefore\n            using the resources assigned to it.')
dsmonAggControlStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 1, 5, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonAggControlStatus.setDescription("The status of this row.\n\n            An entry MUST NOT exist in the active state unless all\n            objects in the entry have an appropriate value.\n\n            Upon setting this object to active(1), the agent will create\n            a complete set of 64 associated entries in the\n            dsmonAggProfileTable.\n\n            If this object is not equal to active(1), all associated\n            entries in the dsmonAggProfileTable shall be deleted.\n\n            This object MUST NOT be modified if the\n            dsmonAggControlLocked object is equal to 'true'.")
dsmonAggProfileTable = MibTable((1, 3, 6, 1, 2, 1, 16, 26, 1, 1, 6), )
if mibBuilder.loadTexts: dsmonAggProfileTable.setDescription("Controls the setup of counter aggregation profiles for this\n            agent.  For each such profile, every DSCP value MUST be\n            configured into exactly one counter aggregation group.\n\n            This table MUST NOT be modified if the dsmonAggControlLocked\n            object is equal to 'true'.\n\n            The agent will create a set of 64 entries in this table\n            (with the same dsmonAggControlIndex value) when the\n            associated dsmonAggControlEntry is activated.\n\n            If the agent supports non-volatile configuration of this\n            table, then upon system initialization, this table SHOULD be\n            initialized with the saved values.")
dsmonAggProfileEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 26, 1, 1, 6, 1), ).setIndexNames((0, "DSMON-MIB", "dsmonAggControlIndex"), (0, "DSMON-MIB", "dsmonAggProfileDSCP"))
if mibBuilder.loadTexts: dsmonAggProfileEntry.setDescription('A conceptual row in the dsmonAggProfileTable.  The\n            dsmonAggControlIndex value in the index identifies the\n            dsmonAggControlEntry associated with each entry in this\n            table.')
dsmonAggProfileDSCP = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 1, 6, 1, 1), Dscp())
if mibBuilder.loadTexts: dsmonAggProfileDSCP.setDescription('The specific DSCP value for the DSCP counter which is\n            configured in a counter aggregation group by this entry.')
dsmonAggGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 1, 6, 1, 2), DsmonCounterAggGroupIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dsmonAggGroupIndex.setDescription("The counter aggregation group which contains this DSCP\n            value.  Upon creation of a new sub-tree (set of 64 entries\n            with the same dsmonAggControlIndex value) in this table, the\n            agent SHOULD initialize all related instances of this object\n            to the value zero.\n\n            This object MUST NOT be modified if the\n            dsmonAggControlLocked object is equal to 'true'.")
dsmonAggGroupTable = MibTable((1, 3, 6, 1, 2, 1, 16, 26, 1, 1, 7), )
if mibBuilder.loadTexts: dsmonAggGroupTable.setDescription("This table provides a description of each counter\n            aggregation group configured on this system.  Note that the\n            semantics of a particular counter aggregation group are only\n            relevant within the scope of a particular counter\n            aggregation profile.\n\n            This table MUST NOT be modified if the dsmonAggControlLocked\n            object is equal to 'true'.\n\n            Note that an agent MAY choose to limit the actual number of\n            entries which may be created in this table, and\n            (independently) the number of counter aggregation profiles\n            which may be applied to a particular data source.  In this\n            case, the agent SHOULD return an error-status of\n            'resourceUnavailable(13)', as per section 4.2.5 of the\n            'Protocol Operations for SNMPv2' specification [RFC1905].\n\n            If the agent supports non-volatile configuration of this\n            table, then upon system initialization, this table SHOULD be\n            initialized with the saved values.  Otherwise, each\n            potential counter aggregation group description string\n            SHOULD contain the empty string.\n\n            An agent SHOULD allow entries to be created or modified in\n            this table, even if the specified dsmonAggControlIndex value\n            does not identify a valid dsmonAggControlEntry or a complete\n            set of valid dsmonAggProfileEntries, to reduce row creation\n            order dependencies.")
dsmonAggGroupEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 26, 1, 1, 7, 1), ).setIndexNames((0, "DSMON-MIB", "dsmonAggControlIndex"), (0, "DSMON-MIB", "dsmonAggGroupIndex"))
if mibBuilder.loadTexts: dsmonAggGroupEntry.setDescription("A conceptual row in the dsmonAggGroupTable.  The\n            dsmonAggGroupIndex value in the INDEX identifies the counter\n            aggregation group associated with each entry.\n\n            The dsmonAggControlIndex in the index identifies the counter\n            aggregation profile associated with each entry, identified\n            by the dsmonAggControlEntry and dsmonAggProfileEntries with\n            the same index value.\n\n            The agent SHOULD support non-volatile configuration of this\n            table, and upon system initialization, the table SHOULD be\n            initialized with the saved values.\n\n            The dsmonAggGroupIndex in the index identifies the counter\n            aggregation group associated with each entry.  This object\n            SHOULD be indexed from zero to 'N', where 'N' is less than\n            the value of the dsmonMaxAggGroups for this agent.")
dsmonAggGroupDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 1, 7, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0,64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonAggGroupDescr.setDescription("An administratively assigned description of the counter\n            aggregation group identified by this entry.\n\n            Upon first creation of an instance of this object, the agent\n            SHOULD set this object to the empty string.\n\n            This object MUST NOT be modified if the associated\n            dsmonAggGroupStatus object is equal to 'active', or the\n            dsmonAggControlLocked object is equal to 'true'.")
dsmonAggGroupStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 1, 7, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonAggGroupStatus.setDescription("The status of this row.\n\n            An entry MUST NOT exist in the active state unless all\n            objects in the entry have an appropriate value.\n\n            This object MUST NOT be modified if the\n            dsmonAggControlLocked object is equal to 'true'.")
dsmonStatsControlTable = MibTable((1, 3, 6, 1, 2, 1, 16, 26, 1, 2, 1), )
if mibBuilder.loadTexts: dsmonStatsControlTable.setDescription("Controls the setup of per data source per counter\n            aggregation group distribution statistics.\n\n            Note that an agent MAY choose to limit the actual number of\n            entries which may be created in this table.  In this case,\n            the agent SHOULD return an error-status of\n            'resourceUnavailable(13)', as per section 4.2.5 of the\n            'Protocol Operations for SNMPv2' specification [RFC1905].")
dsmonStatsControlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 26, 1, 2, 1, 1), ).setIndexNames((0, "DSMON-MIB", "dsmonStatsControlIndex"))
if mibBuilder.loadTexts: dsmonStatsControlEntry.setDescription('A conceptual row in the dsmonStatsControlTable.\n\n            Entries are created and deleted from this table by\n            management action only, using the dsmonStatsControlStatus\n            RowStatus object.\n\n            The agent SHOULD support non-volatile configuration of this\n            table, and upon system initialization, the table SHOULD be\n            initialized with the saved values.\n\n            Activation of a control row in this table will cause an\n            associated dsmonStatsTable to be created and maintained by\n            the agent.')
dsmonStatsControlIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535)))
if mibBuilder.loadTexts: dsmonStatsControlIndex.setDescription('An arbitrary and unique index for this\n            dsmonStatsControlEntry.')
dsmonStatsControlDataSource = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 2, 1, 1, 2), DataSource()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonStatsControlDataSource.setDescription('The data source of this per protocol per counter\n            aggregation group distribution.\n\n            Note that only packets that contain a network protocol\n            encapsulation which contains a DS field [RFC2474] will be\n            counted in this table.\n\n            This object MUST NOT be modified if the associated\n            dsmonStatsControlStatus object is equal to active(1).')
dsmonStatsControlAggProfile = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 2, 1, 1, 3), DsmonCounterAggProfileIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonStatsControlAggProfile.setDescription("The dsmonAggControlIndex value identifying the counter\n            aggregation profile which should be used on behalf of this\n            dsmonStatsControlEntry.\n\n            The associated dsmonAggControlEntry and\n            dsmonAggProfileEntries, identified by the same\n            dsmonAggControlIndex index value, MUST be active in order\n            for this entry to remain active.  It is possible for the\n            counter aggregation configuration to change from a valid to\n            invalid state for this dsmonStats collection.  In this case,\n\n            the associated dsmonStatsControlStatus object will be\n            changed to the 'notReady' state, and data collection will\n            not occur on behalf of this control entry.\n\n            Note that an agent MAY choose to limit the actual number of\n            counter aggregation profiles which may be applied to a\n            particular data source.\n\n            This object MUST NOT be modified if the associated\n            dsmonStatsControlStatus object is equal to active(1).")
dsmonStatsControlDroppedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 2, 1, 1, 4), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonStatsControlDroppedFrames.setDescription('The total number of frames which were received by the probe\n            and therefore not accounted for in the *StatsDropEvents, but\n            for which the probe chose not to count for this entry for\n            whatever reason.  Most often, this event occurs when the\n            probe is out of some resources and decides to shed load from\n            this collection.\n\n            This count does not include packets that were not counted\n            because they had MAC-layer errors.\n\n            Note that, unlike the dropEvents counter, this number is the\n            exact number of frames dropped.')
dsmonStatsControlCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 2, 1, 1, 5), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonStatsControlCreateTime.setDescription('The value of sysUpTime when this control entry was last\n            activated.  This can be used by the management station to\n            detect if the table has been deleted and recreated between\n            polls.')
dsmonStatsControlOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 2, 1, 1, 6), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonStatsControlOwner.setDescription('The entity that configured this entry and is therefore\n            using the resources assigned to it.')
dsmonStatsControlStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 2, 1, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonStatsControlStatus.setDescription('The status of this row.\n\n            An entry MUST NOT exist in the active state unless all\n            objects in the entry have an appropriate value.\n\n            If this object is not equal to active(1), all associated\n            entries in the dsmonStatsTable shall be deleted.')
dsmonStatsTable = MibTable((1, 3, 6, 1, 2, 1, 16, 26, 1, 2, 2), )
if mibBuilder.loadTexts: dsmonStatsTable.setDescription("A list of information on counter aggregation group usage\n            for each monitored data source.\n\n            The following table defines per counter aggregation group\n            statistics for full and/or half-duplex links as well as high\n            capacity links.\n\n            For half-duplex links, or full-duplex-capable links\n            operating in half-duplex mode, the dsmonStatsIn* objects\n            shall be used and the dsmonStatsOut* objects will not\n            increment.\n\n            For full-duplex links, the dsmonStatsOut* objects will be\n            present.  Whenever possible, the probe SHOULD count packets\n            moving away from the closest terminating equipment as output\n            packets.  Failing that, the probe SHOULD count packets\n            moving away from the DTE as output packets.\n\n            If the dsmonAggControlLocked object is equal to 'false',\n            then all entries in this table will be deleted and the agent\n            will not process packets on behalf of any\n\n            dsmonStatsControlEntry.")
dsmonStatsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 26, 1, 2, 2, 1), ).setIndexNames((0, "DSMON-MIB", "dsmonStatsControlIndex"), (0, "DSMON-MIB", "dsmonAggGroupIndex"))
if mibBuilder.loadTexts: dsmonStatsEntry.setDescription('A list of information on Differentiated Services DSCP\n            usage, containing inbound and outbound packet and octet\n            counters for each counter aggregation group configured for\n            collection.\n\n            The dsmonStatsControlIndex value in the index identifies the\n            dsmonStatsControlEntry on whose behalf this entry was\n            created.\n\n            The dsmonAggGroupIndex value in the index is determined by\n            examining the DSCP value in each monitored packet, and the\n            dsmonAggProfileTable entry for that DSCP value.\n\n            Note that only packets that contain a network protocol\n            encapsulation which contains a DS field [RFC2474] will be\n            counted in this table.\n\n            An example of the indexing of this entry is\n            dsmonStatsOutPkts.1.16')
dsmonStatsInPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 2, 2, 1, 1), ZeroBasedCounter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonStatsInPkts.setDescription('The number of packets using one of the DSCP values in the\n            indicated counter aggregation group, received on a half-\n            duplex link or on the inbound connection of a full-duplex\n            link.')
dsmonStatsInOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 2, 2, 1, 2), ZeroBasedCounter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonStatsInOctets.setDescription('The number of octets in packets, using one of the DSCP\n            values in the indicated counter aggregation group, received\n            on a half-duplex link or on the inbound connection of a\n            full-duplex link.')
dsmonStatsInOvflPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 2, 2, 1, 3), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonStatsInOvflPkts.setDescription('The number of times the associated dsmonStatsInPkts counter\n            has overflowed.  Note that this object will only be\n            instantiated if the associated dsmonStatsInHCPkts object is\n            also instantiated for a particular dataSource.')
dsmonStatsInOvflOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 2, 2, 1, 4), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonStatsInOvflOctets.setDescription('The number of times the associated dsmonStatsInOctets\n            counter has overflowed.  Note that this object will only be\n            instantiated if the associated dsmonStatsInHCOctets object\n            is also instantiated for a particular dataSource.')
dsmonStatsInHCPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 2, 2, 1, 5), ZeroBasedCounter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonStatsInHCPkts.setDescription('The 64-bit version of the dsmonStatsInPkts object.\n\n            Note that this object will only be instantiated if the RMON\n            agent supports High Capacity monitoring for a particular\n            dataSource.')
dsmonStatsInHCOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 2, 2, 1, 6), ZeroBasedCounter64()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonStatsInHCOctets.setDescription('The 64-bit version of the dsmonStatsInOctets object.\n\n            Note that this object will only be instantiated if the RMON\n            agent supports High Capacity monitoring for a particular\n            dataSource.')
dsmonStatsOutPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 2, 2, 1, 7), ZeroBasedCounter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonStatsOutPkts.setDescription('The number of packets using one of the DSCP values in the\n            indicated counter aggregation group, received on a full-\n            duplex link in the direction of the network.')
dsmonStatsOutOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 2, 2, 1, 8), ZeroBasedCounter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonStatsOutOctets.setDescription('The number of octets in packets, using one of the DSCP\n            values in the indicated counter aggregation group, received\n            on a full-duplex link in the direction of the network.')
dsmonStatsOutOvflPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 2, 2, 1, 9), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonStatsOutOvflPkts.setDescription('The number of times the associated dsmonStatsOutPkts\n            counter has overflowed.  Note that this object will only be\n            instantiated if the associated dsmonStatsOutHCPkts object is\n            also instantiated for a particular dataSource.')
dsmonStatsOutOvflOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 2, 2, 1, 10), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonStatsOutOvflOctets.setDescription('The number of times the associated dsmonStatsOutOctets\n            counter has overflowed.  Note that this object will only be\n            instantiated if the associated dsmonStatsOutHCOctets object\n            is also instantiated for a particular dataSource.')
dsmonStatsOutHCPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 2, 2, 1, 11), ZeroBasedCounter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonStatsOutHCPkts.setDescription('The 64-bit version of the dsmonStatsOutPkts object.\n\n            Note that this object will only be instantiated if the RMON\n            agent supports High Capacity monitoring for a particular\n            dataSource.')
dsmonStatsOutHCOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 2, 2, 1, 12), ZeroBasedCounter64()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonStatsOutHCOctets.setDescription('The 64-bit version of the dsmonStatsOutOctets object.\n            Note that this object will only be instantiated if the RMON\n            agent supports High Capacity monitoring for a particular\n            dataSource.')
dsmonPdistCtlTable = MibTable((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 1), )
if mibBuilder.loadTexts: dsmonPdistCtlTable.setDescription("Controls the setup of per application per counter\n            aggregation group distribution statistics.\n\n            Note that an agent MAY choose to limit the actual number of\n            entries which may be created in this table.  In this case,\n            the agent SHOULD return an error-status of\n            'resourceUnavailable(13)', as per section 4.2.5 of the\n            'Protocol Operations for SNMPv2' specification [RFC1905].")
dsmonPdistCtlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 1, 1), ).setIndexNames((0, "DSMON-MIB", "dsmonPdistCtlIndex"))
if mibBuilder.loadTexts: dsmonPdistCtlEntry.setDescription('A conceptual row in the dsmonPdistCtlTable.\n\n            Entries are created and deleted from this table by\n            management action only, using the dsmonPdistCtlStatus\n            RowStatus object.\n\n            The agent SHOULD support non-volatile configuration of this\n            table, and upon system initialization, the table SHOULD be\n            initialized with the saved values.\n\n            Activation of a control row in this table will cause an\n            associated dsmonPdistStatsTable to be created and maintained\n            by the agent.')
dsmonPdistCtlIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535)))
if mibBuilder.loadTexts: dsmonPdistCtlIndex.setDescription('An arbitrary and unique index for this dsmonPdistCtlEntry.')
dsmonPdistCtlDataSource = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 1, 1, 2), DataSource()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonPdistCtlDataSource.setDescription('The source of data for the this per protocol counter\n            aggregation group distribution.\n\n            This object MUST NOT be modified if the associated\n            dsmonPdistCtlStatus object is equal to active(1).')
dsmonPdistCtlAggProfile = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 1, 1, 3), DsmonCounterAggProfileIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonPdistCtlAggProfile.setDescription("The dsmonAggControlIndex value identifying the counter\n            aggregation profile which should be used on behalf of this\n            dsmonPdistCtlEntry.\n\n            The associated dsmonAggControlEntry and\n            dsmonAggProfileEntries, identified by the same\n            dsmonAggControlIndex index value, MUST be active in order\n            for this entry to remain active.  It is possible for the\n            counter aggregation configuration to change from a valid to\n            invalid state for this dsmonPdist collection.  In this case,\n            the associated dsmonPdistCtlStatus object will be changed to\n            the 'notReady' state, and data collection will not occur on\n            behalf of this control entry.\n\n            Note that an agent MAY choose to limit the actual number of\n            counter aggregation profiles which may be applied to a\n            particular data source.\n\n\n            This object MUST NOT be modified if the associated\n            dsmonPdistCtlStatus object is equal to active(1).")
dsmonPdistCtlMaxDesiredEntries = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1,-1),ValueRangeConstraint(1,2147483647),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonPdistCtlMaxDesiredEntries.setDescription('The maximum number of entries that are desired in the\n            dsmonPdistStatsTable on behalf of this control entry.  The\n            probe will not create more than this number of associated\n            entries in the table, but MAY choose to create fewer entries\n            in this table for any reason including the lack of\n            resources.\n\n            If this value is set to -1, the probe MAY create any number\n            of entries in this table.\n\n            This object MUST NOT be modified if the associated\n            dsmonPdistCtlStatus object is equal to active(1).')
dsmonPdistCtlDroppedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 1, 1, 5), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonPdistCtlDroppedFrames.setDescription('The total number of frames which were received by the probe\n            and therefore not accounted for in the *StatsDropEvents, but\n            for which the probe chose not to count for this entry for\n            whatever reason.  Most often, this event occurs when the\n            probe is out of some resources and decides to shed load from\n            this collection.\n\n            This count does not include packets that were not counted\n            because they had MAC-layer errors.\n\n            Note that, unlike the dropEvents counter, this number is the\n            exact number of frames dropped.')
dsmonPdistCtlInserts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 1, 1, 6), Counter32()).setUnits('table entries').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonPdistCtlInserts.setDescription('The number of times a dsmonPdist entry has been inserted\n            into the dsmonPdistTable.  If an entry is inserted, then\n            deleted, and then inserted, this counter will be incremented\n            by 2.\n\n            To allow for efficient implementation strategies, agents MAY\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal data\n            structures to differ from those visible via SNMP for short\n            periods of time.  This counter may reflect the internal data\n            structures for those short periods of time.\n\n            Note that the table size can be determined by subtracting\n            dsmonPdistCtlDeletes from dsmonPdistCtlInserts.')
dsmonPdistCtlDeletes = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 1, 1, 7), Counter32()).setUnits('table entries').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonPdistCtlDeletes.setDescription('The number of times a dsmonPdist entry has been deleted\n            from the dsmonPdist table (for any reason).  If an entry is\n            deleted, then inserted, and then deleted, this counter will\n            be incremented by 2.\n\n            To allow for efficient implementation strategies, agents MAY\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal data\n            structures to differ from those visible via SNMP for short\n            periods of time.  This counter may reflect the internal data\n            structures for those short periods of time.\n\n            Note that the table size can be determined by subtracting\n            dsmonPdistCtlDeletes from dsmonPdistCtlInserts.')
dsmonPdistCtlCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 1, 1, 8), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonPdistCtlCreateTime.setDescription('The value of sysUpTime when this control entry was last\n            activated.  This can be used by the management station to\n            detect if the table has been deleted and recreated between\n            polls.')
dsmonPdistCtlOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 1, 1, 9), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonPdistCtlOwner.setDescription('The entity that configured this entry and is therefore\n            using the resources assigned to it.')
dsmonPdistCtlStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 1, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonPdistCtlStatus.setDescription('The status of this row.\n\n            An entry MUST NOT exist in the active state unless all\n            objects in the entry have an appropriate value.\n\n            If this object is not equal to active(1), all associated\n            entries in the dsmonPdistStatsTable shall be deleted.')
dsmonPdistStatsTable = MibTable((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 2), )
if mibBuilder.loadTexts: dsmonPdistStatsTable.setDescription("A list of information on a per protocol per counter\n            aggregation group usage.\n\n            If the dsmonAggControlLocked object is equal to 'false',\n            then all entries in this table will be deleted and the agent\n            will not process packets on behalf of any\n            dsmonPdistCtlEntry.")
dsmonPdistStatsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 2, 1), ).setIndexNames((0, "DSMON-MIB", "dsmonPdistCtlIndex"), (0, "DSMON-MIB", "dsmonPdistTimeMark"), (0, "DSMON-MIB", "dsmonAggGroupIndex"), (0, "RMON2-MIB", "protocolDirLocalIndex"))
if mibBuilder.loadTexts: dsmonPdistStatsEntry.setDescription("A list of information on Differentiated Services DSCP\n            usage, containing packet and octet counters for each counter\n            aggregation group configured for collection, and each\n            protocol (as identified by the protocolDirLocalIndex for the\n            protocol) identified in each monitored packet.\n\n            The dsmonPdistCtlIndex value in the index identifies the\n            dsmonPdistCtlEntry on whose behalf this entry was created.\n\n            Note that only packets that contain a network protocol\n            encapsulation which contains a DS field [RFC2474] will be\n            counted in this table.\n\n            The dsmonAggGroupIndex value in the index is determined by\n            examining the DSCP value in each monitored packet, and the\n            dsmonAggProfileTable entry for that value.\n\n            The protocolDirLocalIndex in the index identifies the\n            protocolDirEntry for the protocol encapsulation of each\n            monitored packet.  The agent will include only application\n            layer protocols in the associated dsmonPdistStatsTable.  Any\n            'terminal' protocol is considered to be an application\n            protocol.\n\n            An example of the indexing of this entry is\n            dsmonPdistStatsPkts.9.29943.0.42.")
dsmonPdistTimeMark = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 2, 1, 1), TimeFilter())
if mibBuilder.loadTexts: dsmonPdistTimeMark.setDescription('The Time Filter index for this table.  This object may be\n            used by a management station to retrieve only rows which\n            have been created or modified since a particular time.  Note\n            that the current value for a row are always returned and the\n            TimeFilter is not a historical data archiving mechanism.\n            Refer to RFC 2021 [RFC2021] for a detailed description of\n            TimeFilter operation.')
dsmonPdistStatsPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 2, 1, 2), ZeroBasedCounter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonPdistStatsPkts.setDescription('The number of packets, using one of the DSCP values in the\n            indicated counter aggregation group, for the protocol\n            identified by the associated protocolDirLocalIndex value.')
dsmonPdistStatsOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 2, 1, 3), ZeroBasedCounter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonPdistStatsOctets.setDescription("The number of octets in packets, using one of the DSCP\n            values in the indicated counter aggregation group, for the\n            protocol identified by the associated protocolDirLocalIndex\n            value.\n\n            Note that this object doesn't count just those octets in the\n            particular protocol frames, but includes the entire packet\n            that contained the protocol.")
dsmonPdistStatsOvflPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 2, 1, 4), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonPdistStatsOvflPkts.setDescription('The number of times the associated dsmonPdistStatsPkts\n            counter has overflowed.  Note that this object will only be\n            instantiated if the associated dsmonPdistStatsHCPkts object\n            is also instantiated for a particular dataSource.')
dsmonPdistStatsOvflOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 2, 1, 5), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonPdistStatsOvflOctets.setDescription('The number of times the associated dsmonPdistStatsOctets\n            counter has overflowed.  Note that this object will only be\n            instantiated if the associated dsmonPdistStatsHCOctets\n            object is also instantiated for a particular dataSource.')
dsmonPdistStatsHCPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 2, 1, 6), ZeroBasedCounter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonPdistStatsHCPkts.setDescription('The 64-bit version of the dsmonPdistStatsPkts object.\n\n            Note that this object will only be instantiated if the RMON\n            agent supports High Capacity monitoring for a particular\n            dataSource.')
dsmonPdistStatsHCOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 2, 1, 7), ZeroBasedCounter64()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonPdistStatsHCOctets.setDescription('The 64-bit version of the dsmonPdistStatsOctets object.\n\n            Note that this object will only be instantiated if the RMON\n            agent supports High Capacity monitoring for a particular\n            dataSource.')
dsmonPdistStatsCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 2, 1, 8), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonPdistStatsCreateTime.setDescription('The value of sysUpTime when this dsmonPdistStats entry was\n            last instantiated by the agent.  This can be used by the\n            management station to detect if the entry has been deleted\n            and recreated between polls.')
dsmonPdistTopNCtlTable = MibTable((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 3), )
if mibBuilder.loadTexts: dsmonPdistTopNCtlTable.setDescription("A set of parameters that control the creation of a report\n            of the top N dsmonPdist entries according to a particular\n            metric.\n\n            Note that an agent MAY choose to limit the actual number of\n            entries which may be created in this table.  In this case,\n            the agent SHOULD return an error-status of\n            'resourceUnavailable(13)', as per section 4.2.5 of the\n            'Protocol Operations for SNMPv2' specification [RFC1905].")
dsmonPdistTopNCtlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 3, 1), ).setIndexNames((0, "DSMON-MIB", "dsmonPdistTopNCtlIndex"))
if mibBuilder.loadTexts: dsmonPdistTopNCtlEntry.setDescription('A conceptual row in the dsmonPdistTopNCtlTable.\n\n            Entries are created and deleted from this table by\n            management action only, using the dsmonPdistTopNCtlStatus\n            RowStatus object.\n\n            The agent SHOULD support non-volatile configuration of this\n            table, and upon system initialization, the table SHOULD be\n            initialized with the saved values.\n\n            Activation of a control row in this table will cause an\n            associated dsmonPdistTopNTable to be created and maintained\n            by the agent.')
dsmonPdistTopNCtlIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535)))
if mibBuilder.loadTexts: dsmonPdistTopNCtlIndex.setDescription('An index that uniquely identifies an entry in the\n            dsmonPdistTopNCtlTable, with the same dsmonPdistTopNCtlIndex\n            value as this object.  Each entry in this table defines one\n            Top N report prepared on behalf of the dsmonPdistStatsEntry\n            collection with the same dsmonPdistCtlIndex as this object.')
dsmonPdistTopNCtlPdistIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonPdistTopNCtlPdistIndex.setDescription('The dsmonPdistTable for which a top N report will be\n            prepared on behalf of this entry.  The dsmonPdistTable is\n            identified by the value of the dsmonPdistCtlIndex for that\n            table - that value is used here to identify the particular\n            table.\n\n            This object MUST NOT be modified if the associated\n            dsmonPdistTopNCtlStatus object is equal to active(1).')
dsmonPdistTopNCtlRateBase = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4,))).clone(namedValues=NamedValues(("dsmonPdistTopNPkts", 1), ("dsmonPdistTopNOctets", 2), ("dsmonPdistTopNHCPkts", 3), ("dsmonPdistTopNHCOctets", 4),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonPdistTopNCtlRateBase.setDescription('The variable for each dsmonPdist that the\n            dsmonPdistTopNRate and dsmonPdistTopNHCRate variables are\n            based upon.  Each dsmonPdistTopN report generated on behalf\n            of this control entry will be ranked in descending order,\n\n            based on the associated dsmonPdistStatsTable counter,\n            identified by this object.\n\n            The following table identifies the dsmonPdistTable counter\n            associated with each enumeration:\n\n            Enumeration              RateBase MIB Object\n            -----------              -------------------\n            dsmonPdistTopNPkts          dsmonPdistStatsPkts\n            dsmonPdistTopNOctets        dsmonPdistStatsOctets\n            dsmonPdistTopNHCPkts        dsmonPdistStatsHCPkts\n            dsmonPdistTopNHCOctets      dsmonPdistStatsHCOctets\n\n            Note that the dsmonPdistTopNHCPkts and\n            dsmonPdistTopNHCOctets enumerations are only available if\n            the agent supports High Capacity monitoring.\n\n            This object MUST NOT be modified if the associated\n            dsmonPdistTopNCtlStatus object is equal to active(1).')
dsmonPdistTopNCtlTimeRemaining = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647)).clone(1800)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonPdistTopNCtlTimeRemaining.setDescription('The number of seconds left in the report currently being\n            collected.  When this object is modified by the management\n            station, a new collection is started, possibly aborting a\n            currently running report.  The new value is used as the\n            requested duration of this report, and is immediately loaded\n            into the associated dsmonPdistTopNCtlDuration object.\n\n            When the report finishes, the probe will automatically start\n            another collection with the same initial value of\n            dsmonPdistTopNCtlTimeRemaining.  Thus the management station\n            may simply read the resulting reports repeatedly, checking\n            the startTime and duration each time to ensure that a report\n            was not missed or that the report parameters were not\n            changed.\n\n            While the value of this object is non-zero, it decrements by\n            one per second until it reaches zero.  At the time that this\n            object decrements to zero, the report is made accessible in\n            the dsmonPdistTopNTable, overwriting any report that may be\n            there.\n\n\n            When this object is modified by the management station, any\n            associated entries in the dsmonPdistTopNTable shall be\n            deleted.')
dsmonPdistTopNCtlGeneratedReprts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 3, 1, 5), Counter32()).setUnits('reports').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonPdistTopNCtlGeneratedReprts.setDescription('The number of reports that have been generated by this\n            entry.')
dsmonPdistTopNCtlDuration = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonPdistTopNCtlDuration.setDescription('The number of seconds that this report has collected during\n            the last sampling interval.\n\n            When the associated dsmonPdistTopNCtlTimeRemaining object is\n            set, this object shall be set by the probe to the same value\n            and shall not be modified until the next time the\n            dsmonPdistTopNCtlTimeRemaining is set.\n\n            This value shall be zero if no reports have been requested\n            for this dsmonPdistTopNCtlEntry.')
dsmonPdistTopNCtlRequestedSize = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647)).clone(150)).setUnits('table entries').setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonPdistTopNCtlRequestedSize.setDescription('The maximum number of dsmonPdist entries requested for this\n            report.\n\n            When this object is created or modified, the probe SHOULD\n            set dsmonPdistTopNCtlGrantedSize as closely to this object\n            as is possible for the particular probe implementation and\n            available resources.')
dsmonPdistTopNCtlGrantedSize = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647))).setUnits('table entries').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonPdistTopNCtlGrantedSize.setDescription('The maximum number of dsmonPdist entries in this report.\n\n            When the associated dsmonPdistTopNCtlRequestedSize object is\n            created or modified, the probe SHOULD set this object as\n            closely to the requested value as is possible for the\n            particular implementation and available resources.  The\n            probe MUST NOT lower this value except as a result of a\n            set to the associated dsmonPdistTopNCtlRequestedSize\n            object.\n\n            Protocol entries with the highest value of\n            dsmonPdistTopNRate or dsmonPdistTopNHCRate (depending on the\n            value of the associated dsmonPdistTopNCtlRateBase object)\n            shall be placed in this table in decreasing order of this\n            rate until there is no more room or until there are no more\n            dsmonPdist entries.')
dsmonPdistTopNCtlStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 3, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonPdistTopNCtlStartTime.setDescription('The value of sysUpTime when this top N report was last\n            started.  In other words, this is the time that the\n            associated dsmonPdistTopNCtlTimeRemaining object was\n            modified to start the requested report or the time the\n            report was last automatically (re)started.\n\n            This object may be used by the management station to\n            determine if a report was missed or not.')
dsmonPdistTopNCtlOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 3, 1, 10), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonPdistTopNCtlOwner.setDescription('The entity that configured this entry and is therefore\n            using the resources assigned to it.')
dsmonPdistTopNCtlStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 3, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonPdistTopNCtlStatus.setDescription('The status of this dsmonPdistTopNCtlEntry.\n\n            An entry MUST NOT exist in the active state unless all\n            objects in the entry have an appropriate value.\n\n            If this object is not equal to active(1), all associated\n            entries in the dsmonPdistTopNTable shall be deleted by the\n            agent.')
dsmonPdistTopNTable = MibTable((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 4), )
if mibBuilder.loadTexts: dsmonPdistTopNTable.setDescription("A set of statistics for those protocol distribution entries\n            that have counted the highest number of octets or packets.\n\n            If the dsmonAggControlLocked object is equal to 'false',\n            then all entries in this table SHALL be deleted, and the\n            agent will not process TopN reports on behalf of any\n            dsmonPdistTopNCtlEntry.\n\n            When the dsmonAggControlLocked object is set to 'true', then\n            particular reports SHOULD be restarted from the beginning,\n            on behalf of all active rows in the dsmonPdistTopNCtlTable.\n\n            Note that dsmonPdist entries which did not increment at all\n            during the report interval SHOULD NOT be included in\n            dsmonPdistTopN reports.")
dsmonPdistTopNEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 4, 1), ).setIndexNames((0, "DSMON-MIB", "dsmonPdistTopNCtlIndex"), (0, "DSMON-MIB", "dsmonPdistTopNIndex"))
if mibBuilder.loadTexts: dsmonPdistTopNEntry.setDescription("A conceptual row in the dsmonPdistTopNTable.\n\n            The dsmonPdistTopNCtlIndex value in the index identifies the\n            dsmonPdistTopNCtlEntry on whose behalf this entry was\n            created.  Entries in this table are ordered from 1 to 'N',\n            where lower numbers represent higher values of the rate base\n            object, over the report interval.")
dsmonPdistTopNIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647)))
if mibBuilder.loadTexts: dsmonPdistTopNIndex.setDescription("An index that uniquely identifies an entry in the\n            dsmonPdistTopNTable among those in the same report.  This\n            index is between 1 and N, where N is the number of entries\n            in this report.  Note that 'N' may change over time, and may\n            also be less than the dsmonPdistTopNCtlGrantedSize value\n            associated with this entry.")
dsmonPdistTopNPDLocalIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonPdistTopNPDLocalIndex.setDescription('The protocolDirLocalIndex value which identifies the\n            protocol associated with this entry.\n\n            If the protocolDirEntry associated with the\n            protocolDirLocalIndex with the same value as this object is\n            de-activated or deleted, then the agent MUST delete this\n            dsmonPdistTopN entry.')
dsmonPdistTopNAggGroup = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 4, 1, 3), DsmonCounterAggGroupIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonPdistTopNAggGroup.setDescription('The DSCP counter aggregation group index value associated\n            with protocol identified in this entry.  This object\n            identifies the dsmonAggGroupEntry with the same\n            dsmonAggControlIndex value as the associated\n            dsmonPdistCtlAggProfile object and the same\n            dsmonAggGroupIndex value as this object.')
dsmonPdistTopNRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 4, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonPdistTopNRate.setDescription("The amount of change in the selected variable during this\n            sampling interval.  The selected variable is this protocol's\n            instance of the object selected by\n            dsmonPdistTopNCtlRateBase.\n\n            If the associated dsmonPdistTopNCtlRateBase is equal to\n            'dsmonPdistTopNHCPkts' or 'dsmonPdistTopNHCOctets', then\n            this object will contain the the least significant 32 bits\n            of the associated dsmonPdistTopNHCRate object.")
dsmonPdistTopNRateOvfl = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 4, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonPdistTopNRateOvfl.setDescription("The most significant 32 bits of the associated\n            dsmonPdistTopNHCRate object.\n\n            If the associated dsmonPdistTopNCtlRateBase is equal to\n            'dsmonPdistTopNHCPkts' or 'dsmonPdistTopNHCOctets', then\n            this object will contain the upper 32 bits of the associated\n            dsmonPdistTopNHCRate object.\n\n            If the associated dsmonPdistTopNCtlRateBase is equal to\n            'dsmonPdistTopNPkts' or 'dsmonPdistTopNOctets', then this\n            object will contain the value zero.\n\n            The agent MAY choose not to instantiate this object if High\n            Capacity monitoring is not supported.")
dsmonPdistTopNHCRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 3, 4, 1, 6), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonPdistTopNHCRate.setDescription("The amount of change in the selected variable during this\n            sampling interval.  The selected variable is this protocol's\n            instance of the object selected by\n            dsmonPdistTopNCtlRateBase.\n\n            If the associated dsmonPdistTopNCtlRateBase is equal to\n            'dsmonPdistTopNPkts' or 'dsmonPdistTopNOctets', then this\n            object will contain the value zero, and the associated\n            dsmonPdistTopNRate object will contain the change in the\n            selected variable during the sampling interval.\n\n            The agent MAY choose not to instantiate this object if High\n            Capacity monitoring is not supported.")
dsmonHostCtlTable = MibTable((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 1), )
if mibBuilder.loadTexts: dsmonHostCtlTable.setDescription("Controls setup of per counter aggregation group, per\n            network layer host distribution statistics.\n\n            Note that an agent MAY choose to limit the actual number of\n            entries which may be created in this table.  In this case,\n            the agent SHOULD return an error-status of\n            'resourceUnavailable(13)', as per section 4.2.5 of the\n            'Protocol Operations for SNMPv2' specification [RFC1905].")
dsmonHostCtlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 1, 1), ).setIndexNames((0, "DSMON-MIB", "dsmonHostCtlIndex"))
if mibBuilder.loadTexts: dsmonHostCtlEntry.setDescription('A conceptual row in the dsmonHostCtlTable.\n\n            Entries are created and deleted from this table by\n            management action only, using the dsmonHostCtlStatus\n            RowStatus object.\n\n            The agent SHOULD support non-volatile configuration of this\n            table, and upon system initialization, the table SHOULD be\n            initialized with the saved values.\n\n            Activation of a control row in this table will cause an\n            associated dsmonHostTable to be created and maintained by\n            the agent.')
dsmonHostCtlIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535)))
if mibBuilder.loadTexts: dsmonHostCtlIndex.setDescription('An arbitrary and unique index for this dsmonHostCtlEntry.')
dsmonHostCtlDataSource = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 1, 1, 2), DataSource()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonHostCtlDataSource.setDescription('The source of data for the associated dsmonHostTable.\n\n            Note that only packets that contain a network protocol\n            encapsulation which contains a DS field [RFC2474] will be\n            counted in this table.\n\n            This object MUST NOT be modified if the associated\n            dsmonHostCtlStatus object is equal to active(1).')
dsmonHostCtlAggProfile = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 1, 1, 3), DsmonCounterAggProfileIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonHostCtlAggProfile.setDescription("The dsmonAggControlIndex value identifying the counter\n            aggregation profile which should be used on behalf of this\n            dsmonHostCtlEntry.\n\n            The associated dsmonAggControlEntry and\n            dsmonAggProfileEntries, identified by the same\n            dsmonAggControlIndex index value, MUST be active in order\n            for this entry to remain active.  It is possible for the\n            counter aggregation configuration to change from a valid to\n            invalid state for this dsmonHost collection.  In this case,\n            the associated dsmonHostCtlStatus object will be changed to\n            the 'notReady' state, and data collection will not occur on\n            behalf of this control entry.\n\n            Note that an agent MAY choose to limit the actual number of\n            counter aggregation profiles which may be applied to a\n            particular data source.\n\n            This object MUST NOT be modified if the associated\n            dsmonHostCtlStatus object is equal to active(1).")
dsmonHostCtlMaxDesiredEntries = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1,-1),ValueRangeConstraint(1,2147483647),))).setUnits('table entries').setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonHostCtlMaxDesiredEntries.setDescription('The maximum number of entries that are desired in the\n            dsmonHostTable on behalf of this control entry.  The probe\n            will not create more than this number of associated entries\n            in the table, but MAY choose to create fewer entries in this\n            table for any reason including the lack of resources.\n\n            If this value is set to -1, the probe MAY create any number\n            of entries in this table.\n\n            This object MUST NOT be modified if the associated\n            dsmonHostCtlStatus object is equal to active(1).')
dsmonHostCtlIPv4PrefixLen = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8,32)).clone(32)).setUnits('bits').setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonHostCtlIPv4PrefixLen.setDescription("The number of 'leftmost' contiguous bits in the host\n            address field for encapsulations of IPv4, that should be\n            maintained in this collection.  This object controls how the\n            dsmonHostAddress object is derived for packets which contain\n            an encapsulation of IPv4.\n\n            If this object has a value less than 32, then 'm' rightmost\n            bits, where 'm' is equal to '32 -\n            dsmonHostCtlIPv4PrefixLen', will be cleared to zero for\n            counting purposes only.  The 'leftmost' bit is the most\n            significant bit of the first network-byte-order octet of the\n            address.\n\n            If this object is equal to 32, then no bits are cleared in\n            each dsmonHostAddress field.\n\n            This object MUST NOT be modified if the associated\n            dsmonHostCtlStatus object is equal to active(1).")
dsmonHostCtlIPv6PrefixLen = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8,128)).clone(128)).setUnits('bits').setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonHostCtlIPv6PrefixLen.setDescription("The number of 'leftmost' contiguous bits in the host\n            address field for encapsulations of IPv6, that should be\n            maintained in this collection.  This object controls how the\n            dsmonHostAddress object is derived for packets which contain\n            an encapsulation of IPv6.\n\n            If this object has a value less than 128, then 'm' rightmost\n            bits, where 'm' is equal to '128 -\n\n            dsmonHostCtlIPv6PrefixLen', will be cleared to zero for\n            counting purposes only.  The 'leftmost' bit is the most\n            significant bit of the first network-byte-order octet of the\n            address.\n\n            If this object is equal to 128, then no bits are cleared in\n            each dsmonHostAddress field.\n\n            This object MUST NOT be modified if the associated\n            dsmonHostCtlStatus object is equal to active(1).")
dsmonHostCtlDroppedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 1, 1, 7), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostCtlDroppedFrames.setDescription('The total number of frames which were received by the probe\n            and therefore not accounted for in the *StatsDropEvents, but\n            for which the probe chose not to count for the associated\n            dsmonHost entries for whatever reason.  Most often, this\n            event occurs when the probe is out of some resources and\n            decides to shed load from this collection.\n\n            This count does not include packets that were not counted\n            because they had MAC-layer errors.\n\n            Note that if the dsmonHostTable is inactive because no\n            appropriate protocols are enabled in the protocol directory,\n            this value SHOULD be 0.\n\n            Note that, unlike the dropEvents counter, this number is the\n            exact number of frames dropped.')
dsmonHostCtlInserts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 1, 1, 8), Counter32()).setUnits('table entries').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostCtlInserts.setDescription('The number of times a dsmonHost entry has been inserted\n            into the dsmonHost table.  If an entry is inserted, then\n            deleted, and then inserted, this counter will be incremented\n            by 2.\n\n\n            To allow for efficient implementation strategies, agents MAY\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal data\n            structures to differ from those visible via SNMP for short\n            periods of time.  This counter may reflect the internal data\n            structures for those short periods of time.\n\n            Note that the table size can be determined by subtracting\n            dsmonHostCtlDeletes from dsmonHostCtlInserts.')
dsmonHostCtlDeletes = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 1, 1, 9), Counter32()).setUnits('table entries').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostCtlDeletes.setDescription('The number of times a dsmonHost entry has been deleted from\n            the dsmonHost table (for any reason).  If an entry is\n            deleted, then inserted, and then deleted, this counter will\n            be incremented by 2.\n\n            To allow for efficient implementation strategies, agents MAY\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal data\n            structures to differ from those visible via SNMP for short\n            periods of time.  This counter may reflect the internal data\n            structures for those short periods of time.\n\n            Note that the table size can be determined by subtracting\n            dsmonHostCtlDeletes from dsmonHostCtlInserts.')
dsmonHostCtlCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 1, 1, 10), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostCtlCreateTime.setDescription('The value of sysUpTime when this control entry was last\n            activated.  This can be used by the management station to\n            detect if the table has been deleted and recreated between\n            polls.')
dsmonHostCtlOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 1, 1, 11), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonHostCtlOwner.setDescription('The entity that configured this entry and is therefore\n            using the resources assigned to it.')
dsmonHostCtlStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 1, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonHostCtlStatus.setDescription('The status of this dsmonHostCtlEntry.\n\n            An entry MUST NOT exist in the active state unless all\n            objects in the entry have an appropriate value.\n\n            If this object is not equal to active(1), all associated\n            entries in the dsmonHostTable shall be deleted.')
dsmonHostTable = MibTable((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 2), )
if mibBuilder.loadTexts: dsmonHostTable.setDescription("A collection of statistics for particular network protocols\n            which contain a DS field, and that has been discovered on a\n            particular dataSource.\n\n            The probe will add to this table all appropriate network\n            protocols, for each network address seen as the source or\n            destination address in all packets with no MAC errors, and\n            will increment octet and packet counts in the table for all\n            packets with no MAC errors.\n\n            If the dsmonAggControlLocked object is equal to 'false',\n            then all entries in this table will be deleted, and the\n            agent will not process packets on behalf of any\n            dsmonHostCtlEntry.")
dsmonHostEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 2, 1), ).setIndexNames((0, "DSMON-MIB", "dsmonHostCtlIndex"), (0, "DSMON-MIB", "dsmonHostTimeMark"), (0, "DSMON-MIB", "dsmonAggGroupIndex"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "DSMON-MIB", "dsmonHostAddress"))
if mibBuilder.loadTexts: dsmonHostEntry.setDescription('A list of information on Differentiated Services DSCP\n            usage, containing packet and octet counters for each counter\n            aggregation group index configured for collection per host\n            address, as identified in the dsmonAggProfileTable.\n\n            The dsmonHostCtlIndex value in the index identifies the\n            dsmonHostCtlEntry on whose behalf this entry was created.\n\n            The protocolDirLocalIndex value in the index identifies the\n            specific network layer protocol encapsulation associated\n            with each entry, and the network protocol type of the\n            dsmonHostAddress object.  It MUST identify a\n            protocolDirEntry which contains a DS field (e.g., IPv4 or\n            IPv6).  Note that if a protocol encapsulation with multiple\n            network layers is specified, then associated entries in this\n            table refer to the innermost network protocol layer host\n            address.\n\n            The dsmonAggGroupIndex value in the index is determined by\n            examining the DSCP value in each monitored packet, and the\n            dsmonAggProfileTable entry configured for that value.\n\n            An example of the indexing of this entry is\n            dsmonHostOutPkts.1.27273.3.200.4.171.69.120.0')
dsmonHostTimeMark = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 2, 1, 1), TimeFilter())
if mibBuilder.loadTexts: dsmonHostTimeMark.setDescription('The Time Filter index for this table.  This object may be\n            used by a management station to retrieve only rows which\n            have been created or modified since a particular time.  Note\n            that the current value for a row are always returned and the\n            TimeFilter is not a historical data archiving mechanism.\n            Refer to RFC 2021 [RFC2021] for a detailed description of\n            TimeFilter operation.')
dsmonHostAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0,110)))
if mibBuilder.loadTexts: dsmonHostAddress.setDescription("The network address for this dsmonHostEntry.\n\n            This object is encoded according to the protocol type\n            indicated by the protocolDirLocalIndex value in the index.\n\n            In addition, this object may have some 'rightmost' bits\n            cleared to zero for counting purposes, as indicated by the\n            associated dsmonHostCtlIPv4PrefixLen or\n            dsmonHostCtlIPv6PrefixLen objects.")
dsmonHostInPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 2, 1, 3), ZeroBasedCounter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostInPkts.setDescription('The number of packets without errors, using one of the DSCP\n            values in the indicated counter aggregation group, and\n            transmitted to this address, since this entry was added to\n            the dsmonHostTable.  Note that this is the number of link-\n            layer packets, so if a single network-layer packet is\n            fragmented into several link-layer frames, this counter is\n            incremented several times.')
dsmonHostInOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 2, 1, 4), ZeroBasedCounter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostInOctets.setDescription("The number of octets in all packets, transmitted to this\n            address and using one of the DSCP values in the indicated\n            counter aggregation group, since this entry was added to the\n            dsmonHostTable (excluding framing bits but including FCS\n            octets), excluding those octets in packets that contained\n            errors.\n\n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that\n            contained the protocol.")
dsmonHostInOvflPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 2, 1, 5), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostInOvflPkts.setDescription('The number of times the associated dsmonHostInPkts counter\n            has overflowed.  Note that this object will only be\n            instantiated if the associated dsmonHostInHCPkts object is\n            also instantiated for a particular dataSource.')
dsmonHostInOvflOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 2, 1, 6), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostInOvflOctets.setDescription('The number of times the associated dsmonHostInOctets\n            counter has overflowed.  Note that this object will only be\n            instantiated if the associated dsmonHostInHCOctets object is\n            also instantiated for a particular dataSource.')
dsmonHostInHCPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 2, 1, 7), ZeroBasedCounter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostInHCPkts.setDescription('The 64-bit version of the dsmonHostInPkts object.\n\n            Note that this object will only be instantiated if the RMON\n\n            agent supports High Capacity monitoring for a particular\n            dataSource.')
dsmonHostInHCOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 2, 1, 8), ZeroBasedCounter64()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostInHCOctets.setDescription('The 64-bit version of the dsmonHostInOctets object.\n\n            Note that this object will only be instantiated if the RMON\n            agent supports High Capacity monitoring for a particular\n            dataSource.')
dsmonHostOutPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 2, 1, 9), ZeroBasedCounter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostOutPkts.setDescription('The number of packets without errors, using one of the DSCP\n            values in the indicated counter aggregation group, and\n            transmitted by this address, since this entry was added to\n            the dsmonHostTable.  Note that this is the number of link-\n            layer packets, so if a single network-layer packet is\n            fragmented into several link-layer frames, this counter is\n            incremented several times.')
dsmonHostOutOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 2, 1, 10), ZeroBasedCounter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostOutOctets.setDescription("The number of octets, transmitted by this address and using\n            one of the DSCP values in the identified counter aggregation\n            group, since this entry was added to the dsmonHostTable\n            (excluding framing bits but including FCS octets), excluding\n            those octets in packets that contained errors.\n\n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that\n            contained the protocol.")
dsmonHostOutOvflPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 2, 1, 11), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostOutOvflPkts.setDescription('The number of times the associated dsmonHostOutPkts counter\n            has overflowed.  Note that this object will only be\n            instantiated if the associated dsmonHostOutHCPkts object is\n            also instantiated for a particular dataSource.')
dsmonHostOutOvflOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 2, 1, 12), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostOutOvflOctets.setDescription('The number of times the associated dsmonHostOutOctets\n            counter has overflowed.  Note that this object will only be\n            instantiated if the associated dsmonHostOutHCOctets object\n            is also instantiated for a particular dataSource.')
dsmonHostOutHCPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 2, 1, 13), ZeroBasedCounter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostOutHCPkts.setDescription('The 64-bit version of the dsmonHostOutPkts object.\n\n            Note that this object will only be instantiated if the RMON\n            agent supports High Capacity monitoring for a particular\n            dataSource.')
dsmonHostOutHCOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 2, 1, 14), ZeroBasedCounter64()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostOutHCOctets.setDescription('The 64-bit version of the dsmonHostOutOctets object.\n\n            Note that this object will only be instantiated if the RMON\n            agent supports High Capacity monitoring for a particular\n            dataSource.')
dsmonHostCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 2, 1, 15), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostCreateTime.setDescription('The value of sysUpTime when this dsmonHost entry was last\n            instantiated by the agent.  This can be used by the\n            management station to ensure that the entry has not been\n            deleted and recreated between polls.')
dsmonHostTopNCtlTable = MibTable((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 3), )
if mibBuilder.loadTexts: dsmonHostTopNCtlTable.setDescription("A set of parameters that control the creation of a report\n            of the top N dsmonHost entries according to a selected\n            metric.\n\n            Note that an agent MAY choose to limit the actual number of\n            entries which may be created in this table.  In this case,\n            the agent SHOULD return an error-status of\n            'resourceUnavailable(13)', as per section 4.2.5 of the\n            'Protocol Operations for SNMPv2' specification [RFC1905].")
dsmonHostTopNCtlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 3, 1), ).setIndexNames((0, "DSMON-MIB", "dsmonHostTopNCtlIndex"))
if mibBuilder.loadTexts: dsmonHostTopNCtlEntry.setDescription('A conceptual row in the dsmonHostTopNCtlTable.\n\n            Entries are created and deleted from this table by\n            management action only, using the dsmonHostTopNCtlStatus\n            RowStatus object.\n\n            The agent SHOULD support non-volatile configuration of this\n            table, and upon system initialization, the table SHOULD be\n            initialized with the saved values.\n\n            Activation of a control row in this table will cause an\n\n            associated dsmonHostTopNTable to be created and maintained\n            by the agent.')
dsmonHostTopNCtlIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535)))
if mibBuilder.loadTexts: dsmonHostTopNCtlIndex.setDescription('An index that uniquely identifies an entry in the\n            dsmonHostTopNCtlTable.  Each such entry defines one Top N\n            report prepared for one RMON dataSource.')
dsmonHostTopNCtlHostIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonHostTopNCtlHostIndex.setDescription('The dsmonHostTable for which a top N report will be\n            prepared on behalf of this entry.  The dsmonHostTable is\n            identified by the value of the dsmonHostCtlIndex for that\n            table - that value is used here to identify the particular\n            table.\n\n            This object MUST NOT be modified if the associated\n            dsmonHostTopNCtlStatus object is equal to active(1).')
dsmonHostTopNCtlRateBase = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,))).clone(namedValues=NamedValues(("dsmonHostTopNInPkts", 1), ("dsmonHostTopNInOctets", 2), ("dsmonHostTopNOutPkts", 3), ("dsmonHostTopNOutOctets", 4), ("dsmonHostTopNTotalPkts", 5), ("dsmonHostTopNTotalOctets", 6), ("dsmonHostTopNInHCPkts", 7), ("dsmonHostTopNInHCOctets", 8), ("dsmonHostTopNOutHCPkts", 9), ("dsmonHostTopNOutHCOctets", 10), ("dsmonHostTopNTotalHCPkts", 11), ("dsmonHostTopNTotalHCOctets", 12),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonHostTopNCtlRateBase.setDescription('The variable(s) for each dsmonHost that the\n            dsmonHostTopNRate and dsmonHostTopNHCRate variables are\n            based upon.  Each dsmonHostTopN report generated on behalf\n            of this control entry will be ranked in descending order,\n            based on the associated dsmonHostTable counter(s),\n            identified by this object.\n\n            The following table identifies the dsmonHostTable counters\n            associated with each enumeration:\n\n            Enumeration              RateBase MIB Objects\n            -----------              --------------------\n            dsmonHostTopNInPkts         dsmonHostInPkts\n            dsmonHostTopNInOctets       dsmonHostInOctets\n            dsmonHostTopNOutPkts        dsmonHostOutPkts\n            dsmonHostTopNOutOctets      dsmonHostOutOctets\n            dsmonHostTopNTotalPkts      dsmonHostInPkts +\n                                          dsmonHostOutPkts\n            dsmonHostTopNTotalOctets    dsmonHostInOctets +\n                                          dsmonHostOutOctets\n            dsmonHostTopNInHCPkts       dsmonHostInHCPkts\n            dsmonHostTopNInHCOctets     dsmonHostInHCOctets\n            dsmonHostTopNOutHCPkts      dsmonHostOutHCPkts\n            dsmonHostTopNOutHCOctets    dsmonHostOutHCPkts\n            dsmonHostTopNTotalHCPkts    dsmonHostInHCPkts +\n                                          dsmonHostOutHCPkts\n            dsmonHostTopNTotalHCOctets  dsmonHostInHCOctets +\n                                          dsmonHostOutHCOctets\n\n            The following enumerations are only available if the agent\n            supports High Capacity monitoring:\n\n            dsmonHostTopNInHCPkts\n            dsmonHostTopNInHCOctets\n\n            dsmonHostTopNOutHCPkts\n            dsmonHostTopNOutHCOctets\n            dsmonHostTopNTotalHCPkts\n            dsmonHostTopNTotalHCOctets\n\n            It is an implementation-specific matter whether an agent can\n            detect an overflow condition resulting from the addition of\n            two counter delta values for the following enumerations:\n\n            dsmonHostTopNTotalPkts\n            dsmonHostTopNTotalOctets\n            dsmonHostTopNTotalHCPkts\n            dsmonHostTopNTotalHCOctets\n\n            In the event such an overflow condition can be detected by\n            the agent, the associated dsmonHostTopNRate,\n            dsmonHostTopNRateOvfl, and/or dsmonHostTopNHCRate objects\n            should be set to their maximum value.\n\n            This object MUST NOT be modified if the associated\n            dsmonHostTopNCtlStatus object is equal to active(1).')
dsmonHostTopNCtlTimeRemaining = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647)).clone(1800)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonHostTopNCtlTimeRemaining.setDescription('The number of seconds left in the report currently being\n            collected.  When this object is modified by the management\n            station, a new collection is started, possibly aborting a\n            currently running report.  The new value is used as the\n            requested duration of this report, and is immediately loaded\n            into the associated dsmonHostTopNCtlDuration object.\n\n            When the report finishes, the probe will automatically start\n            another collection with the same initial value of\n            dsmonHostTopNCtlTimeRemaining.  Thus the management station\n            may simply read the resulting reports repeatedly, checking\n            the startTime and duration each time to ensure that a report\n            was not missed or that the report parameters were not\n            changed.\n\n            While the value of this object is non-zero, it decrements by\n            one per second until it reaches zero.  At the time that this\n            object decrements to zero, the report is made accessible in\n            the dsmonHostTopNTable, overwriting any report that may be\n\n            there.\n\n            When this object is modified by the management station, any\n            associated entries in the dsmonHostTopNTable shall be\n            deleted.')
dsmonHostTopNCtlGeneratedReports = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 3, 1, 5), Counter32()).setUnits('reports').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostTopNCtlGeneratedReports.setDescription('The number of reports that have been generated by this\n            entry.')
dsmonHostTopNCtlDuration = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostTopNCtlDuration.setDescription('The number of seconds that this report has collected during\n            the last sampling interval.\n\n            When the associated dsmonHostTopNCtlTimeRemaining object is\n            set, this object shall be set by the probe to the same value\n            and shall not be modified until the next time the\n            dsmonHostTopNCtlTimeRemaining is set.\n\n            This value shall be zero if no reports have been requested\n            for this dsmonHostTopNCtlEntry.')
dsmonHostTopNCtlRequestedSize = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647)).clone(150)).setUnits('table entries').setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonHostTopNCtlRequestedSize.setDescription('The maximum number of dsmonHost entries requested for this\n            report.\n\n            When this object is created or modified, the probe SHOULD\n            set dsmonHostTopNCtlGrantedSize as closely to this object as\n            is possible for the particular probe implementation and\n\n            available resources.')
dsmonHostTopNCtlGrantedSize = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647))).setUnits('table entries').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostTopNCtlGrantedSize.setDescription('The maximum number of dsmonHost entries in this report.\n\n            When the associated dsmonHostTopNCtlRequestedSize object is\n            created or modified, the probe SHOULD set this object as\n            closely to the requested value as is possible for the\n            particular implementation and available resources.  The\n            probe MUST NOT lower this value except as a result of a\n            set to the associated dsmonHostTopNCtlRequestedSize\n            object.\n\n            Protocol entries with the highest value of dsmonHostTopNRate\n            or dsmonHostTopNHCRate (depending on the value of the\n            associated dsmonHostTopNCtlRateBase object) shall be placed\n            in this table in decreasing order of this rate until there\n            is no more room or until there are no more dsmonHost\n            entries.')
dsmonHostTopNCtlStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 3, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostTopNCtlStartTime.setDescription('The value of sysUpTime when this top N report was last\n            started.  In other words, this is the time that the\n            associated dsmonHostTopNCtlTimeRemaining object was modified\n            to start the requested report or the time the report was\n            last automatically (re)started.\n\n            This object may be used by the management station to\n            determine if a report was missed or not.')
dsmonHostTopNCtlOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 3, 1, 10), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonHostTopNCtlOwner.setDescription('The entity that configured this entry and is therefore\n            using the resources assigned to it.')
dsmonHostTopNCtlStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 3, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonHostTopNCtlStatus.setDescription('The status of this dsmonHostTopNCtlEntry.\n\n            An entry MUST NOT exist in the active state unless all\n            objects in the entry have an appropriate value.\n\n            If this object is not equal to active(1), all associated\n            entries in the dsmonHostTopNTable shall be deleted by the\n            agent.')
dsmonHostTopNTable = MibTable((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 4), )
if mibBuilder.loadTexts: dsmonHostTopNTable.setDescription("A set of statistics for those dsmonHost entries that have\n            counted the highest number of octets or packets.\n\n            If the dsmonAggControlLocked object is equal to 'false',\n            then all entries in this table SHALL be deleted, and the\n            agent will not process TopN reports on behalf of any\n            dsmonHostTopNCtlEntry.\n\n            When the dsmonAggControlLocked object is set to 'true', then\n            particular reports SHOULD be restarted from the beginning,\n            on behalf of all active rows in the dsmonHostTopNCtlTable.\n\n            Note that dsmonHost entries which did not increment at all\n            during the report interval SHOULD NOT be included in\n            dsmonHostTopN reports.")
dsmonHostTopNEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 4, 1), ).setIndexNames((0, "DSMON-MIB", "dsmonHostTopNCtlIndex"), (0, "DSMON-MIB", "dsmonHostTopNIndex"))
if mibBuilder.loadTexts: dsmonHostTopNEntry.setDescription("A conceptual row in the dsmonHostTopNTable.\n\n            The dsmonHostTopNCtlIndex value in the index identifies the\n            dsmonHostTopNCtlEntry on whose behalf this entry was\n            created.\n\n            Entries in this table are ordered from 1 to 'N', where lower\n            numbers represent higher values of the rate base object,\n            over the report interval.")
dsmonHostTopNIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647)))
if mibBuilder.loadTexts: dsmonHostTopNIndex.setDescription('An index that uniquely identifies an entry in the\n            dsmonHostTopNTable among those in the same report.  This\n            index is between 1 and N, where N is the number of entries\n            in this report.')
dsmonHostTopNPDLocalIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostTopNPDLocalIndex.setDescription('The protocolDirLocalIndex value which identifies the\n            protocol associated with the dsmonHostTopNAddress object in\n            this entry.\n\n            If the protocolDirEntry associated with the\n            protocolDirLocalIndex with the same value as this object is\n            de-activated or deleted, then the agent MUST delete this\n            dsmonHostTopN entry.')
dsmonHostTopNAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 4, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostTopNAddress.setDescription('The dsmonHostAddress value for the network host identified\n            in this entry.  The associated dsmonHostTopNPDLocalIndex\n            object identifies the network protocol type and the encoding\n            rules for this object.')
dsmonHostTopNAggGroup = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 4, 1, 4), DsmonCounterAggGroupIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostTopNAggGroup.setDescription('The counter aggregation group index value associated with\n            host identified in this entry.  This object identifies the\n            dsmonAggGroupEntry with the same dsmonAggControlIndex value\n            as the associated dsmonHostCtlAggProfile object and the same\n            dsmonAggGroupIndex value as this object.')
dsmonHostTopNRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 4, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostTopNRate.setDescription("The amount of change in the selected variable during this\n            sampling interval.  The selected variable is this host's\n            instance of the object selected by dsmonHostTopNCtlRateBase.\n\n            If the associated dsmonHostTopNCtlRateBase indicates a High\n            Capacity monitoring enumeration, (e.g.\n            'dsmonHostTopNInHCPkts'), then this object will contain the\n            the least significant 32 bits of the associated\n            dsmonHostTopNHCRate object.")
dsmonHostTopNRateOvfl = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 4, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostTopNRateOvfl.setDescription("The most significant 32 bits of the associated\n            dsmonHostTopNHCRate object.\n\n            If the associated dsmonHostTopNCtlRateBase is equal to any\n            of the High Capacity monitoring enumerations (e.g.\n            'dsmonHostTopNInHCPkts'), then this object will contain the\n            upper 32 bits of the associated dsmonHostTopNHCRate object.\n\n            If the associated dsmonHostTopNCtlRateBase is not equal to\n            any of High Capacity monitoring enumerations, then this\n            object will contain the value zero.\n\n            The agent MAY choose not to instantiate this object if High\n            Capacity monitoring is not supported.")
dsmonHostTopNHCRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 4, 4, 1, 7), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonHostTopNHCRate.setDescription("The amount of change in the selected variable during this\n            sampling interval.  The selected variable is this host's\n            instance of the object selected by dsmonHostTopNCtlRateBase.\n\n            If the associated dsmonHostTopNCtlRateBase is not equal to\n            any of the High Capacity monitoring enumerations (e.g.,\n            'dsmonHostTopNInPkts'), then this object will contain the\n            value zero, and the associated dsmonHostTopNRate object will\n            contain the change in the selected variable during the\n            sampling interval.\n\n            The agent MAY choose not to instantiate this object if High\n            Capacity monitoring is not supported.")
dsmonMatrixCtlTable = MibTable((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 1), )
if mibBuilder.loadTexts: dsmonMatrixCtlTable.setDescription("Controls setup of per counter aggregation group, per host-\n            pair, application protocol distribution statistics.\n\n            Note that an agent MAY choose to limit the actual number of\n            entries which may be created in this table.  In this case,\n            the agent SHOULD return an error-status of\n            'resourceUnavailable(13)', as per section 4.2.5 of the\n            'Protocol Operations for SNMPv2' specification [RFC1905].")
dsmonMatrixCtlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 1, 1), ).setIndexNames((0, "DSMON-MIB", "dsmonMatrixCtlIndex"))
if mibBuilder.loadTexts: dsmonMatrixCtlEntry.setDescription('A conceptual row in the dsmonMatrixCtlTable.\n\n            Entries are created and deleted from this table by\n            management action only, using the dsmonMatrixCtlStatus\n            RowStatus object.\n\n            The agent SHOULD support non-volatile configuration of this\n            table, and upon system initialization, the table SHOULD be\n            initialized with the saved values.\n\n            Activation of a control row in this table will cause an\n            associated dsmonMatrixSDTable and dsmonMatrixDSTable to be\n            created and maintained by the agent.')
dsmonMatrixCtlIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535)))
if mibBuilder.loadTexts: dsmonMatrixCtlIndex.setDescription('An arbitrary and unique index for this\n            dsmonMatrixCtlEntry.')
dsmonMatrixCtlDataSource = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 1, 1, 2), DataSource()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonMatrixCtlDataSource.setDescription('The source of data for the associated dsmonMatrixSDTable\n            and dsmonMatrixDSTable.\n\n            Note that only packets that contain a network protocol\n            encapsulation which contains a DS field [RFC2474] will be\n            counted in this table.\n\n            This object MUST NOT be modified if the associated\n            dsmonMatrixCtlStatus object is equal to active(1).')
dsmonMatrixCtlAggProfile = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 1, 1, 3), DsmonCounterAggProfileIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonMatrixCtlAggProfile.setDescription("The dsmonAggControlIndex value identifying the counter\n            aggregation profile which should be used on behalf of this\n            dsmonMatrixCtlEntry.\n\n            The associated dsmonAggControlEntry and\n            dsmonAggProfileEntries, identified by the same\n            dsmonAggControlIndex index value, MUST be active in order\n            for this entry to remain active.  It is possible for the\n            counter aggregation configuration to change from a valid to\n            invalid state for this dsmonMatrix collection.  In this\n            case, the associated dsmonMatrixCtlStatus object will be\n            changed to the 'notReady' state, and data collection will\n            not occur on behalf of this control entry.\n\n            Note that an agent MAY choose to limit the actual number of\n            counter aggregation profiles which may be applied to a\n            particular data source.\n\n            This object MUST NOT be modified if the associated\n            dsmonMatrixCtlStatus object is equal to active(1).")
dsmonMatrixCtlMaxDesiredEntries = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1,-1),ValueRangeConstraint(1,2147483647),))).setUnits('table entries').setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonMatrixCtlMaxDesiredEntries.setDescription('The maximum number of entries that are desired in the\n            dsmonMatrix tables on behalf of this control entry.  The\n            probe will not create more than this number of associated\n            entries in these tables, but may choose to create fewer\n            entries in this table for any reason including the lack of\n            resources.\n\n            If this value is set to -1, the probe may create any number\n            of entries in this table.\n\n            This object MUST NOT be modified if the associated\n            dsmonMatrixCtlStatus object is equal to active(1).')
dsmonMatrixCtlDroppedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 1, 1, 5), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixCtlDroppedFrames.setDescription('The total number of frames which were received by the probe\n            and therefore not accounted for in the *StatsDropEvents, but\n            for which the probe chose not to count for the associated\n            dsmonMatrixSD and dsmonMatrixDS entries for whatever reason.\n            Most often, this event occurs when the probe is out of some\n            resources and decides to shed load from this collection.\n\n            This count does not include packets that were not counted\n            because they had MAC-layer errors.\n\n            Note that if the dsmonMatrix tables are inactive because no\n            appropriate protocols are enabled in the protocol directory,\n            this value SHOULD be 0.\n\n            Note that, unlike the dropEvents counter, this number is the\n            exact number of frames dropped.')
dsmonMatrixCtlInserts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 1, 1, 6), Counter32()).setUnits('table entries').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixCtlInserts.setDescription('The number of times a dsmonMatrix entry has been inserted\n            into the dsmonMatrix tables.  If an entry is inserted, then\n            deleted, and then inserted, this counter will be incremented\n            by 2.  The addition of a conversation into both the\n            dsmonMatrixSDTable and dsmonMatrixDSTable shall be counted\n            as two insertions (even though every addition into one table\n            must be accompanied by an insertion into the other).\n\n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal data\n            structures to differ from those visible via SNMP for short\n            periods of time.  This counter may reflect the internal data\n            structures for those short periods of time.  Note that the\n            sum of the dsmonMatrixSDTable and dsmonMatrixDSTable sizes\n            can be determined by subtracting dsmonMatrixCtlDeletes from\n            dsmonMatrixCtlInserts.')
dsmonMatrixCtlDeletes = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 1, 1, 7), Counter32()).setUnits('table entries').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixCtlDeletes.setDescription('The number of times a dsmonMatrix entry has been deleted\n            from the dsmonMatrix tables (for any reason).  If an entry\n            is deleted, then inserted, and then deleted, this counter\n            will be incremented by 2.  The deletion of a conversation\n            from both the dsmonMatrixSDTable and dsmonMatrixDSTable\n            shall be counted as two deletions (even though every\n            deletion from one table must be accompanied by a deletion\n            from the other).\n\n            To allow for efficient implementation strategies, agents MAY\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal data\n            structures to differ from those visible via SNMP for short\n            periods of time.  This counter may reflect the internal data\n            structures for those short periods of time.\n\n            Note that the sum of the dsmonMatrixSDTable and\n            dsmonMatrixDSTable sizes can be determined by subtracting\n            dsmonMatrixCtlDeletes from dsmonMatrixCtlInserts.')
dsmonMatrixCtlCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 1, 1, 8), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixCtlCreateTime.setDescription('The value of sysUpTime when this control entry was last\n            activated.  This can be used by the management station to\n            detect if the table has been deleted and recreated between\n            polls.')
dsmonMatrixCtlOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 1, 1, 9), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonMatrixCtlOwner.setDescription('The entity that configured this entry and is therefore\n            using the resources assigned to it.')
dsmonMatrixCtlStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 1, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonMatrixCtlStatus.setDescription('The status of this dsmonMatrixCtlEntry.\n\n            An entry MUST NOT exist in the active state unless all\n            objects in the entry have an appropriate value.\n\n            If this object is not equal to active(1), all associated\n            entries in the dsmonMatrixSDTable and dsmonMatrixDSTable\n            shall be deleted.')
dsmonMatrixSDTable = MibTable((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 2), )
if mibBuilder.loadTexts: dsmonMatrixSDTable.setDescription('A list of application traffic matrix entries which collect\n            statistics for conversations of a particular application\n            protocol between two network-level addresses.  This table is\n            indexed first by the source address and then by the\n\n            destination address to make it convenient to collect all\n            statistics from a particular address.\n\n            The probe will add to this table all pairs of addresses for\n            all protocols seen in all packets with no MAC errors, and\n            will increment octet and packet counts in the table for all\n            packets with no MAC errors.')
dsmonMatrixSDEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 2, 1), ).setIndexNames((0, "DSMON-MIB", "dsmonMatrixCtlIndex"), (0, "DSMON-MIB", "dsmonMatrixTimeMark"), (0, "DSMON-MIB", "dsmonAggGroupIndex"), (0, "DSMON-MIB", "dsmonMatrixNLIndex"), (0, "DSMON-MIB", "dsmonMatrixSourceAddress"), (0, "DSMON-MIB", "dsmonMatrixDestAddress"), (0, "DSMON-MIB", "dsmonMatrixALIndex"))
if mibBuilder.loadTexts: dsmonMatrixSDEntry.setDescription('A conceptual row in the dsmonMatrixSDTable.\n\n            The dsmonMatrixCtlIndex value in the index identifies the\n            dsmonMatrixCtlEntry on whose behalf this entry was created.\n\n            The dsmonAggGroupIndex value in the index is determined by\n            examining the DSCP value in each monitored packet, and the\n            dsmonAggProfileTable entry configured for that value.')
dsmonMatrixTimeMark = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 2, 1, 1), TimeFilter())
if mibBuilder.loadTexts: dsmonMatrixTimeMark.setDescription('The Time Filter index for this table.  This object may be\n            used by a management station to retrieve only rows which\n            have been created or modified since a particular time.  Note\n            that the current value for a row are always returned and the\n            TimeFilter is not a historical data archiving mechanism.\n            Refer to RFC 2021 [RFC2021] for a detailed description of\n            TimeFilter operation.')
dsmonMatrixNLIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647)))
if mibBuilder.loadTexts: dsmonMatrixNLIndex.setDescription('The protocolDirLocalIndex value of a protocolDirEntry\n            representing the specific network layer protocol\n            encapsulation associated with each entry, and the network\n            protocol type of the dsmonMatrixSourceAddress and\n            dsmonMatrixDestAddress objects.')
dsmonMatrixSourceAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0,54)))
if mibBuilder.loadTexts: dsmonMatrixSourceAddress.setDescription('The network source address for this dsmonMatrix entry.\n\n            This is represented as an octet string with specific\n            semantics and length as identified by the dsmonMatrixNLIndex\n            component of the index.\n\n            For example, if the dsmonMatrixNLIndex indicates an\n            encapsulation of IPv4, this object is encoded as a length\n            octet of 4, followed by the 4 octets of the IPv4 address, in\n            network byte order.')
dsmonMatrixDestAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0,54)))
if mibBuilder.loadTexts: dsmonMatrixDestAddress.setDescription('The network destination address for this dsmonMatrix entry.\n\n            This is represented as an octet string with specific\n            semantics and length as identified by the dsmonMatrixNLIndex\n            component of the index.\n\n            For example, if the dsmonMatrixNLIndex indicates an\n            encapsulation of IPv4, this object is encoded as a length\n            octet of 4, followed by the 4 octets of the IPv4 address, in\n            network byte order.')
dsmonMatrixALIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647)))
if mibBuilder.loadTexts: dsmonMatrixALIndex.setDescription('The protocolDirLocalIndex value of the protocolDirEntry\n            representing the specific application layer protocol\n            associated with each entry.\n\n            It MUST identify an protocolDirEntry which is a direct or\n            indirect descendant of the protocolDirEntry identified by\n            the associated dsmonMatrixNLIndex object.')
dsmonMatrixSDPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 2, 1, 6), ZeroBasedCounter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixSDPkts.setDescription('The number of packets of this protocol type (indicated by\n            the associated dsmonMatrixALIndex object) without errors\n            transmitted from the source address to the destination\n            address since this entry was added to the\n            dsmonMatrixSDTable.  Note that this is the number of link-\n            layer packets, so if a single network-layer packet is\n            fragmented into several link-layer frames, this counter is\n            incremented several times.')
dsmonMatrixSDOvflPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 2, 1, 7), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixSDOvflPkts.setDescription('The number of times the associated dsmonMatrixSDPkts\n            counter has overflowed, since this entry was added to the\n            dsmonMatrixSDTable.')
dsmonMatrixSDHCPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 2, 1, 8), ZeroBasedCounter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixSDHCPkts.setDescription('The 64-bit version of the dsmonMatrixSDPkts object.\n\n            Note that this object will only be instantiated if the RMON\n            agent supports High Capacity monitoring for a particular\n            dataSource.')
dsmonMatrixSDOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 2, 1, 9), ZeroBasedCounter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixSDOctets.setDescription("The number of octets in packets of this protocol type\n            transmitted from the source address to the destination\n            address since this entry was added to the dsmonMatrixSDTable\n            (excluding framing bits but including FCS octets), excluding\n            those octets in packets that contained errors.\n\n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that\n            contained the protocol.")
dsmonMatrixSDOvflOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 2, 1, 10), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixSDOvflOctets.setDescription('The number of times the associated dsmonMatrixSDOctets\n            counter has overflowed, since this entry was added to the\n            dsmonMatrixSDTable.')
dsmonMatrixSDHCOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 2, 1, 11), ZeroBasedCounter64()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixSDHCOctets.setDescription('The 64-bit version of the dsmonMatrixSDPkts object.\n\n            Note that this object will only be instantiated if the RMON\n            agent supports High Capacity monitoring for a particular\n            dataSource.')
dsmonMatrixSDCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 2, 1, 12), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixSDCreateTime.setDescription('The value of sysUpTime when this entry was last activated.\n            This can be used by the management station to ensure that\n            the entry has not been deleted and recreated between polls.')
dsmonMatrixDSTable = MibTable((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 3), )
if mibBuilder.loadTexts: dsmonMatrixDSTable.setDescription('A list of application traffic matrix entries which collect\n            statistics for conversations of a particular application\n            protocol between two network-level addresses.  This table is\n            indexed first by the destination address and then by the\n            source address to make it convenient to collect all\n            statistics from a particular address.\n\n            The probe will add to this table all pairs of addresses for\n            all protocols seen in all packets with no MAC errors, and\n            will increment octet and packet counts in the table for all\n            packets with no MAC errors.')
dsmonMatrixDSEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 3, 1), ).setIndexNames((0, "DSMON-MIB", "dsmonMatrixCtlIndex"), (0, "DSMON-MIB", "dsmonMatrixTimeMark"), (0, "DSMON-MIB", "dsmonAggGroupIndex"), (0, "DSMON-MIB", "dsmonMatrixNLIndex"), (0, "DSMON-MIB", "dsmonMatrixDestAddress"), (0, "DSMON-MIB", "dsmonMatrixSourceAddress"), (0, "DSMON-MIB", "dsmonMatrixALIndex"))
if mibBuilder.loadTexts: dsmonMatrixDSEntry.setDescription('A conceptual row in the dsmonMatrixDSTable.  Note that this\n            table is conceptually a re-ordered version of the\n            dsmonMatrixSDTable.  Therefore, all of the index values from\n\n            that table are used by reference, and their semantics are\n            exactly as described in the dsmonMatrixSDTable.\n\n            The dsmonMatrixCtlIndex value in the index identifies the\n            dsmonMatrixCtlEntry on whose behalf this entry was created.\n\n            The dsmonMatrixTimeMark value in the index identifies the\n            Time Filter index for this table.\n\n            The dsmonAggGroupIndex value in the index is determined by\n            examining the DSCP value in each monitored packet, and the\n            dsmonAggProfileTable entry configured for that value.\n\n            The dsmonMatrixNLIndex value in the index identifies the\n            protocolDirLocalIndex value of a protocolDirEntry\n            representing the specific network layer protocol\n            encapsulation associated with each entry, and the network\n            protocol type of the dsmonMatrixSourceAddress and\n            dsmonMatrixDestAddress objects.\n\n            The dsmonMatrixDestAddress value in the index identifies the\n            network destination address for this dsmonMatrix entry.\n\n            The dsmonMatrixSourceAddress value in the index identifies\n            the network source address for this dsmonMatrix entry.\n\n            The dsmonMatrixALIndex value in the index identifies the\n            protocolDirLocalIndex value of the protocolDirEntry\n            representing the specific application layer protocol\n            associated with each entry.')
dsmonMatrixDSPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 3, 1, 1), ZeroBasedCounter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixDSPkts.setDescription('The number of packets of this protocol type (indicated by\n            the associated dsmonMatrixALIndex object) without errors\n            transmitted from the source address to the destination\n            address since this entry was added to the\n            dsmonMatrixDSTable.  Note that this is the number of link-\n            layer packets, so if a single network-layer packet is\n            fragmented into several link-layer frames, this counter is\n            incremented several times.')
dsmonMatrixDSOvflPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 3, 1, 2), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixDSOvflPkts.setDescription('The number of times the associated dsmonMatrixDSPkts\n            counter has overflowed, since this entry was added to the\n            dsmonMatrixDSTable.')
dsmonMatrixDSHCPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 3, 1, 3), ZeroBasedCounter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixDSHCPkts.setDescription('The 64-bit version of the dsmonMatrixDSPkts object.\n\n            Note that this object will only be instantiated if the RMON\n            agent supports High Capacity monitoring for a particular\n            dataSource.')
dsmonMatrixDSOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 3, 1, 4), ZeroBasedCounter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixDSOctets.setDescription("The number of octets in packets of this protocol type\n\n            transmitted from the source address to the destination\n            address since this entry was added to the dsmonMatrixDSTable\n            (excluding framing bits but including FCS octets), excluding\n            those octets in packets that contained errors.\n\n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that\n            contained the protocol.")
dsmonMatrixDSOvflOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 3, 1, 5), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixDSOvflOctets.setDescription('The number of times the associated dsmonMatrixDSOctets\n            counter has overflowed, since this entry was added to the\n            dsmonMatrixDSTable.')
dsmonMatrixDSHCOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 3, 1, 6), ZeroBasedCounter64()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixDSHCOctets.setDescription('The 64-bit version of the dsmonMatrixDSPkts object.\n\n            Note that this object will only be instantiated if the RMON\n            agent supports High Capacity monitoring for a particular\n            dataSource.')
dsmonMatrixDSCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 3, 1, 7), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixDSCreateTime.setDescription('The value of sysUpTime when this entry was last activated.\n            This can be used by the management station to ensure that\n            the entry has not been deleted and recreated between polls.')
dsmonMatrixTopNCtlTable = MibTable((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 4), )
if mibBuilder.loadTexts: dsmonMatrixTopNCtlTable.setDescription("A set of parameters that control the creation of a report\n            of the top N dsmonMatrix entries according to a selected\n            metric.\n\n            Note that an agent MAY choose to limit the actual number of\n            entries which may be created in this table.  In this case,\n            the agent SHOULD return an error-status of\n            'resourceUnavailable(13)', as per section 4.2.5 of the\n            'Protocol Operations for SNMPv2' specification [RFC1905].")
dsmonMatrixTopNCtlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 4, 1), ).setIndexNames((0, "DSMON-MIB", "dsmonMatrixTopNCtlIndex"))
if mibBuilder.loadTexts: dsmonMatrixTopNCtlEntry.setDescription('A conceptual row in the dsmonMatrixTopNCtlTable.\n\n            Entries are created and deleted from this table by\n            management action only, using the dsmonMatrixTopNCtlStatus\n            RowStatus object.\n\n            The agent SHOULD support non-volatile configuration of this\n            table, and upon system initialization, the table SHOULD be\n            initialized with the saved values.\n\n            Activation of a control row in this table will cause an\n            associated dsmonMatrixTopNTable to be created and maintained\n            by the agent.')
dsmonMatrixTopNCtlIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535)))
if mibBuilder.loadTexts: dsmonMatrixTopNCtlIndex.setDescription('An index that uniquely identifies an entry in the\n            dsmonMatrixTopNCtlTable.  Each such entry defines one Top N\n            report prepared for one RMON dataSource.')
dsmonMatrixTopNCtlMatrixIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonMatrixTopNCtlMatrixIndex.setDescription('The dsmonMatrixSDTable for which a top N report will be\n            prepared on behalf of this entry.  The dsmonMatrixSDTable is\n            identified by the same value of the dsmonMatrixCtlIndex\n            object.\n\n            This object MUST NOT be modified if the associated\n            dsmonMatrixTopNCtlStatus object is equal to active(1).')
dsmonMatrixTopNCtlRateBase = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4,))).clone(namedValues=NamedValues(("dsmonMatrixTopNPkts", 1), ("dsmonMatrixTopNOctets", 2), ("dsmonMatrixTopNHCPkts", 3), ("dsmonMatrixTopNHCOctets", 4),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonMatrixTopNCtlRateBase.setDescription('The variable for each dsmonMatrixSD entry that the\n            dsmonMatrixTopNRate and dsmonMatrixTopNHCRate variables are\n            based upon.  Each dsmonMatrixTopN report generated on behalf\n            of this control entry will be ranked in descending order,\n            based on the associated dsmonMatrixSDTable counter,\n            identified by this object.\n\n            The following table identifies the dsmonMatrixSDTable\n            counters associated with each enumeration:\n\n            Enumeration                 RateBase MIB Objects\n\n            -----------                 --------------------\n            dsmonMatrixTopNPkts         dsmonMatrixSDPkts\n            dsmonMatrixTopNOctets       dsmonMatrixSDOctets\n            dsmonMatrixTopNHCPkts       dsmonMatrixSDHCPkts\n            dsmonMatrixTopNHCOctets     dsmonMatrixSDHCOctets\n\n            The following enumerations are only available if the agent\n            supports High Capacity monitoring:\n\n            dsmonMatrixTopNHCPkts\n            dsmonMatrixTopNHCOctets\n\n            This object MUST NOT be modified if the associated\n            dsmonMatrixTopNCtlStatus object is equal to active(1).')
dsmonMatrixTopNCtlTimeRemaining = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647)).clone(1800)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonMatrixTopNCtlTimeRemaining.setDescription('The number of seconds left in the report currently being\n            collected.  When this object is modified by the management\n            station, a new collection is started, possibly aborting a\n            currently running report.  The new value is used as the\n            requested duration of this report, and is immediately loaded\n            into the associated dsmonMatrixTopNCtlDuration object.\n\n            When the report finishes, the probe will automatically start\n            another collection with the same initial value of\n            dsmonMatrixTopNCtlTimeRemaining.  Thus the management\n            station may simply read the resulting reports repeatedly,\n            checking the startTime and duration each time to ensure that\n            a report was not missed or that the report parameters were\n            not changed.\n\n            While the value of this object is non-zero, it decrements by\n            one per second until it reaches zero.  At the time that this\n            object decrements to zero, the report is made accessible in\n            the dsmonMatrixTopNTable, overwriting any report that may be\n            there.\n\n            When this object is modified by the management station, any\n            associated entries in the dsmonMatrixTopNTable shall be\n            deleted.')
dsmonMatrixTopNCtlGeneratedRpts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 4, 1, 5), Counter32()).setUnits('reports').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixTopNCtlGeneratedRpts.setDescription('The number of reports that have been generated by this\n            entry.')
dsmonMatrixTopNCtlDuration = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixTopNCtlDuration.setDescription('The number of seconds that this report has collected during\n            the last sampling interval.\n\n            When the associated dsmonMatrixTopNCtlTimeRemaining object\n            is set, this object shall be set by the probe to the same\n            value and shall not be modified until the next time the\n            dsmonMatrixTopNCtlTimeRemaining is set.\n\n            This value shall be zero if no reports have been requested\n            for this dsmonMatrixTopNCtlEntry.')
dsmonMatrixTopNCtlRequestedSize = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647)).clone(150)).setUnits('table entries').setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonMatrixTopNCtlRequestedSize.setDescription('The maximum number of dsmonMatrix entries requested for\n            this report.\n\n            When this object is created or modified, the probe SHOULD\n            set dsmonMatrixTopNCtlGrantedSize as closely to this object\n            as is possible for the particular probe implementation and\n            available resources.')
dsmonMatrixTopNCtlGrantedSize = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647))).setUnits('table entries').setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixTopNCtlGrantedSize.setDescription('The maximum number of dsmonMatrix entries in this report.\n\n            When the associated dsmonMatrixTopNCtlRequestedSize object\n            is created or modified, the probe SHOULD set this object as\n            closely to the requested value as is possible for the\n            particular implementation and available resources.  The\n            probe MUST NOT lower this value except as a result of a\n            set to the associated dsmonMatrixTopNCtlRequestedSize\n            object.\n\n            Protocol entries with the highest value of\n            dsmonMatrixTopNRate or dsmonMatrixTopNHCRate (depending on\n            the value of the associated dsmonMatrixTopNCtlRateBase\n            object) shall be placed in this table in decreasing order of\n            this rate until there is no more room or until there are no\n            more dsmonMatrix entries.')
dsmonMatrixTopNCtlStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 4, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixTopNCtlStartTime.setDescription('The value of sysUpTime when this top N report was last\n            started.  In other words, this is the time that the\n            associated dsmonMatrixTopNCtlTimeRemaining object was\n            modified to start the requested report or the time the\n            report was last automatically (re)started.\n\n            This object may be used by the management station to\n            determine if a report was missed or not.')
dsmonMatrixTopNCtlOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 4, 1, 10), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonMatrixTopNCtlOwner.setDescription('The entity that configured this entry and is therefore\n            using the resources assigned to it.')
dsmonMatrixTopNCtlStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 4, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dsmonMatrixTopNCtlStatus.setDescription('The status of this dsmonMatrixTopNCtlEntry.\n\n            An entry MUST NOT exist in the active state unless all\n            objects in the entry have an appropriate value.\n\n            If this object is not equal to active(1), all associated\n            entries in the dsmonMatrixTopNTable shall be deleted by the\n            agent.')
dsmonMatrixTopNTable = MibTable((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 5), )
if mibBuilder.loadTexts: dsmonMatrixTopNTable.setDescription("A set of statistics for those dsmonMatrix entries that have\n            counted the highest number of octets or packets.\n\n            If the dsmonAggControlLocked object is equal to 'false',\n            then all entries in this table SHALL be deleted, and the\n            agent will not process TopN reports on behalf of any\n            dsmonMatrixTopNCtlEntry.\n\n            When the dsmonAggControlLocked object is set to 'true', then\n            particular reports SHOULD be restarted from the beginning,\n            on behalf of all active rows in the dsmonMatrixTopNCtlTable.\n\n            Note that dsmonMatrix entries which did not increment at all\n            during the report interval SHOULD NOT be included in\n            dsmonMatrixTopN reports.")
dsmonMatrixTopNEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 5, 1), ).setIndexNames((0, "DSMON-MIB", "dsmonMatrixTopNCtlIndex"), (0, "DSMON-MIB", "dsmonMatrixTopNIndex"))
if mibBuilder.loadTexts: dsmonMatrixTopNEntry.setDescription("A conceptual row in the dsmonMatrixTopNTable.\n\n            The dsmonMatrixTopNCtlIndex value in the index identifies\n            the dsmonMatrixTopNCtlEntry on whose behalf this entry was\n            created.\n\n\n            Entries in this table are ordered from 1 to 'N', where lower\n            numbers represent higher values of the rate base object,\n            over the report interval.")
dsmonMatrixTopNIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647)))
if mibBuilder.loadTexts: dsmonMatrixTopNIndex.setDescription('An index that uniquely identifies an entry in the\n            dsmonMatrixTopNTable among those in the same report.  This\n            index is between 1 and N, where N is the number of entries\n            in this report.')
dsmonMatrixTopNAggGroup = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 5, 1, 2), DsmonCounterAggGroupIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixTopNAggGroup.setDescription('The counter aggregation group index value associated with\n            host identified in this entry.  This object identifies the\n            dsmonAggGroupEntry with the same dsmonAggControlIndex value\n            as the associated dsmonMatrixCtlAggProfile object and the\n            same dsmonAggGroupIndex value as this object.')
dsmonMatrixTopNNLIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixTopNNLIndex.setDescription('The protocolDirLocalIndex value which identifies the\n            protocol associated with the dsmonMatrixTopNSourceAddress\n            and dsmonMatrixTopNDestAddress objects in this entry.\n\n            If the protocolDirEntry associated with the\n            protocolDirLocalIndex with the same value as this object is\n            de-activated or deleted, then the agent MUST delete this\n            dsmonMatrixTopN entry.')
dsmonMatrixTopNSourceAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 5, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixTopNSourceAddress.setDescription('The dsmonMatrixSDSourceAddress value for the source network\n            host identified in this entry.  The associated\n            dsmonMatrixTopNNLIndex object identifies the network\n            protocol type and the encoding rules for this object.')
dsmonMatrixTopNDestAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 5, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixTopNDestAddress.setDescription('The dsmonMatrixSDDestAddress value for the destination\n            network host identified in this entry.  The associated\n            dsmonMatrixTopNNLIndex object identifies the network\n            protocol type and the encoding rules for this object.')
dsmonMatrixTopNALIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 5, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixTopNALIndex.setDescription('The protocolDirLocalIndex value which identifies the\n            application protocol associated with this entry.\n\n            If the protocolDirEntry associated with the\n\n            protocolDirLocalIndex with the same value as this object is\n            de-activated or deleted, then the agent MUST delete this\n            dsmonMatrixTopN entry.')
dsmonMatrixTopNPktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 5, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixTopNPktRate.setDescription('The number of packets seen of this protocol from the source\n            host to the destination host during this sampling interval,\n            counted using the rules for counting the dsmonMatrixSDPkts\n            object.\n\n            If the value of dsmonMatrixTopNCtlRateBase is\n            dsmonMatrixTopNPkts, this variable will be used to sort this\n            report.\n\n            If the value of the dsmonMatrixTopNCtlRateBase is\n            dsmonMatrixTopNHCPkts or dsmonMatrixTopNHCOctets, then this\n            object will contain the the least significant 32 bits of the\n            associated dsmonMatrixTopNHCPktRate object.')
dsmonMatrixTopNPktRateOvfl = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 5, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixTopNPktRateOvfl.setDescription('The most significant 32 bits of the associated\n            dsmonMatrixTopNHCPktRate object.\n\n            If the associated dsmonMatrixTopNCtlRateBase is equal to\n            dsmonMatrixTopNHCPkts or dsmonMatrixTopNHCOctets, then this\n            object will contain the most significant 32 bits of the\n            associated dsmonMatrixTopNHCPktRate object, otherwise this\n            object will contain the value zero.\n\n            The agent MAY choose not to instantiate this object if High\n            Capacity monitoring is not supported.')
dsmonMatrixTopNHCPktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 5, 1, 9), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixTopNHCPktRate.setDescription('The number of packets seen of this protocol from the source\n            host to the destination host during this sampling interval,\n            counted using the rules for counting the dsmonMatrixSDHCPkts\n            object.\n\n            If the value of dsmonMatrixTopNCtlRateBase is\n            dsmonMatrixTopNHCPkts, this variable will be used to sort\n            this report.\n\n            The agent MAY choose not to instantiate this object if High\n            Capacity monitoring is not supported.')
dsmonMatrixTopNRevPktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 5, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixTopNRevPktRate.setDescription('The number of packets seen of this protocol from the\n            destination host to the source host during this sampling\n            interval, counted using the rules for counting the\n            dsmonMatrixDSPkts object  (note that the corresponding\n            dsmonMatrixSDPkts object selected is the one whose source\n            address is equal to dsmonMatrixTopNDestAddress and whose\n            destination address is equal to\n            dsmonMatrixTopNSourceAddress.)')
dsmonMatrixTopNRevPktRateOvfl = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 5, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixTopNRevPktRateOvfl.setDescription('The most significant 32 bits of the associated\n            dsmonMatrixTopNHCRevPktRate object.\n\n            If the associated dsmonMatrixTopNCtlRateBase is equal to\n            dsmonMatrixTopNHCPkts or dsmonMatrixTopNHCOCtets, then this\n            object will contain the most significant 32 bits of the\n            associated dsmonMatrixTopNHCRevPktRate object, otherwise\n            this object will contain the value zero.\n\n            The agent MAY choose not to instantiate this object if High\n            Capacity monitoring is not supported.')
dsmonMatrixTopNHCRevPktRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 5, 1, 12), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixTopNHCRevPktRate.setDescription('The number of packets seen of this protocol from the\n            destination host to the source host during this sampling\n            interval, counted using the rules for counting the\n            dsmonMatrixDSHCPkts object  (note that the corresponding\n            dsmonMatrixSDHCPkts object selected is the one whose source\n            address is equal to dsmonMatrixTopNDestAddress and whose\n            destination address is equal to\n            dsmonMatrixTopNSourceAddress.)\n\n            The agent MAY choose not to instantiate this object if High\n            Capacity monitoring is not supported.')
dsmonMatrixTopNOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 5, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixTopNOctetRate.setDescription('The number of octets seen of this protocol from the source\n            host to the destination host during this sampling interval,\n            counted using the rules for counting the dsmonMatrixSDOctets\n            object.\n\n            If the value of dsmonMatrixTopNCtlRateBase is\n            dsmonMatrixTopNOctets, this variable will be used to sort\n            this report.\n\n            If the value of the dsmonMatrixTopNCtlRateBase is\n            dsmonMatrixTopNHCPkts or dsmonMatrixTopNHCOctets, then this\n            object will contain the the least significant 32 bits of the\n            associated dsmonMatrixTopNHCPktRate object.')
dsmonMatrixTopNOctetRateOvfl = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 5, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixTopNOctetRateOvfl.setDescription('The most significant 32 bits of the associated\n            dsmonMatrixTopNHCOctetRate object.\n\n            If the associated dsmonMatrixTopNCtlRateBase is equal to\n            dsmonMatrixTopNHCPkts or dsmonMatrixTopNHCOctets, then this\n            object will contain the most significant 32 bits of the\n            associated dsmonMatrixTopNHCOctetRate object, otherwise this\n\n            object will contain the value zero.\n\n            The agent MAY choose not to instantiate this object if High\n            Capacity monitoring is not supported.')
dsmonMatrixTopNHCOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 5, 1, 15), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixTopNHCOctetRate.setDescription('The number of octets seen of this protocol from the source\n            host to the destination host during this sampling interval,\n            counted using the rules for counting the\n            dsmonMatrixSDHCOctets object.\n\n            If the value of dsmonMatrixTopNCtlRateBase is\n            dsmonMatrixTopNHCOctets, this variable will be used to sort\n            this report.\n\n            The agent MAY choose not to instantiate this object if High\n            Capacity monitoring is not supported.')
dsmonMatrixTopNRevOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 5, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixTopNRevOctetRate.setDescription('The number of octets seen of this protocol from the\n            destination host to the source host during this sampling\n            interval, counted using the rules for counting the\n            dsmonMatrixDSOctets object  (note that the corresponding\n            dsmonMatrixSDOctets object selected is the one whose source\n            address is equal to dsmonMatrixTopNDestAddress and whose\n            destination address is equal to\n            dsmonMatrixTopNSourceAddress.)')
dsmonMatrixTopNRevOctetRateOvfl = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 5, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixTopNRevOctetRateOvfl.setDescription('The most significant 32 bits of the associated\n            dsmonMatrixTopNHCRevOctetRate object.\n\n            If the associated dsmonMatrixTopNCtlRateBase is equal to\n\n            dsmonMatrixTopNHCPkts or dsmonMatrixTopNHCOCtets, then this\n            object will contain the most significant 32 bits of the\n            associated dsmonMatrixTopNHCRevPktRate object, otherwise\n            this object will contain the value zero.\n\n            The agent MAY choose not to instantiate this object if High\n            Capacity monitoring is not supported.')
dsmonMatrixTopNHCRevOctetRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 26, 1, 6, 5, 1, 18), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dsmonMatrixTopNHCRevOctetRate.setDescription('The number of octets seen of this protocol from the\n            destination host to the source host during this sampling\n            interval, counted using the rules for counting the\n            dsmonMatrixDSHCOctets object  (note that the corresponding\n            dsmonMatrixSDHCOctets object selected is the one whose\n            source address is equal to dsmonMatrixTopNDestAddress and\n            whose destination address is equal to\n            dsmonMatrixTopNSourceAddress.)\n\n            The agent MAY choose not to instantiate this object if High\n            Capacity monitoring is not supported.')
dsmonCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 26, 3, 1))
dsmonGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 26, 3, 2))
dsmonCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 26, 3, 1, 1)).setObjects(*(("DSMON-MIB", "dsmonCounterAggControlGroup"), ("DSMON-MIB", "dsmonStatsGroup"), ("DSMON-MIB", "dsmonCapsGroup"), ("DSMON-MIB", "dsmonStatsHCGroup"), ("DSMON-MIB", "dsmonPdistGroup"), ("DSMON-MIB", "dsmonPdistHCGroup"), ("DSMON-MIB", "dsmonHostGroup"), ("DSMON-MIB", "dsmonHostHCGroup"), ("DSMON-MIB", "dsmonMatrixGroup"), ("DSMON-MIB", "dsmonMatrixHCGroup"),))
if mibBuilder.loadTexts: dsmonCompliance.setDescription('Describes the requirements for conformance to the\n            Differentiated Services Monitoring MIB.')
dsmonHCCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 26, 3, 1, 2)).setObjects(*(("DSMON-MIB", "dsmonCounterAggControlGroup"), ("DSMON-MIB", "dsmonStatsGroup"), ("DSMON-MIB", "dsmonStatsHCGroup"), ("DSMON-MIB", "dsmonCapsGroup"), ("DSMON-MIB", "dsmonPdistGroup"), ("DSMON-MIB", "dsmonPdistHCGroup"), ("DSMON-MIB", "dsmonHostGroup"), ("DSMON-MIB", "dsmonHostHCGroup"), ("DSMON-MIB", "dsmonMatrixGroup"), ("DSMON-MIB", "dsmonMatrixHCGroup"),))
if mibBuilder.loadTexts: dsmonHCCompliance.setDescription('Describes the requirements for conformance to the\n            Differentiated Services Monitoring MIB for agents which also\n            support High Capacity monitoring and the Counter64 data\n            type.')
dsmonHCNoC64Compliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 26, 3, 1, 3)).setObjects(*(("DSMON-MIB", "dsmonCounterAggControlGroup"), ("DSMON-MIB", "dsmonStatsGroup"), ("DSMON-MIB", "dsmonStatsOvflGroup"), ("DSMON-MIB", "dsmonCapsGroup"), ("DSMON-MIB", "dsmonStatsHCGroup"), ("DSMON-MIB", "dsmonPdistGroup"), ("DSMON-MIB", "dsmonPdistOvflGroup"), ("DSMON-MIB", "dsmonPdistHCGroup"), ("DSMON-MIB", "dsmonHostGroup"), ("DSMON-MIB", "dsmonHostOvflGroup"), ("DSMON-MIB", "dsmonHostHCGroup"), ("DSMON-MIB", "dsmonMatrixGroup"), ("DSMON-MIB", "dsmonMatrixOvflGroup"), ("DSMON-MIB", "dsmonMatrixHCGroup"),))
if mibBuilder.loadTexts: dsmonHCNoC64Compliance.setDescription('Describes the requirements for conformance to the\n            Differentiated Services Monitoring MIB for an agent which\n            supports high capacity monitoring, but does not support the\n            Counter64 data type (e.g., only supports the SNMPv1\n            protocol).')
dsmonCounterAggControlGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 26, 3, 2, 1)).setObjects(*(("DSMON-MIB", "dsmonMaxAggGroups"), ("DSMON-MIB", "dsmonAggControlLocked"), ("DSMON-MIB", "dsmonAggControlChanges"), ("DSMON-MIB", "dsmonAggControlLastChangeTime"), ("DSMON-MIB", "dsmonAggControlDescr"), ("DSMON-MIB", "dsmonAggControlOwner"), ("DSMON-MIB", "dsmonAggControlStatus"), ("DSMON-MIB", "dsmonAggGroupIndex"), ("DSMON-MIB", "dsmonAggGroupDescr"), ("DSMON-MIB", "dsmonAggGroupStatus"),))
if mibBuilder.loadTexts: dsmonCounterAggControlGroup.setDescription('A collection of objects used to configure and manage\n            counter aggregation groups for DSMON collection purposes.')
dsmonStatsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 26, 3, 2, 2)).setObjects(*(("DSMON-MIB", "dsmonStatsControlDataSource"), ("DSMON-MIB", "dsmonStatsControlAggProfile"), ("DSMON-MIB", "dsmonStatsControlDroppedFrames"), ("DSMON-MIB", "dsmonStatsControlCreateTime"), ("DSMON-MIB", "dsmonStatsControlOwner"), ("DSMON-MIB", "dsmonStatsControlStatus"), ("DSMON-MIB", "dsmonStatsInPkts"), ("DSMON-MIB", "dsmonStatsInOctets"), ("DSMON-MIB", "dsmonStatsOutPkts"), ("DSMON-MIB", "dsmonStatsOutOctets"),))
if mibBuilder.loadTexts: dsmonStatsGroup.setDescription('A collection of objects providing per DSCP statistics.')
dsmonStatsOvflGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 26, 3, 2, 3)).setObjects(*(("DSMON-MIB", "dsmonStatsInOvflPkts"), ("DSMON-MIB", "dsmonStatsInOvflOctets"), ("DSMON-MIB", "dsmonStatsOutOvflPkts"), ("DSMON-MIB", "dsmonStatsOutOvflOctets"),))
if mibBuilder.loadTexts: dsmonStatsOvflGroup.setDescription('A collection of objects providing per-DSCP overflow\n            counters for systems with high capacity data sources, but\n            without support for the Counter64 data type.')
dsmonStatsHCGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 26, 3, 2, 4)).setObjects(*(("DSMON-MIB", "dsmonStatsInHCPkts"), ("DSMON-MIB", "dsmonStatsInHCOctets"), ("DSMON-MIB", "dsmonStatsOutHCPkts"), ("DSMON-MIB", "dsmonStatsOutHCOctets"),))
if mibBuilder.loadTexts: dsmonStatsHCGroup.setDescription('A collection of objects providing per DSCP statistics for\n            high capacity data sources.')
dsmonPdistGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 26, 3, 2, 5)).setObjects(*(("DSMON-MIB", "dsmonPdistCtlDataSource"), ("DSMON-MIB", "dsmonPdistCtlAggProfile"), ("DSMON-MIB", "dsmonPdistCtlMaxDesiredEntries"), ("DSMON-MIB", "dsmonPdistCtlDroppedFrames"), ("DSMON-MIB", "dsmonPdistCtlInserts"), ("DSMON-MIB", "dsmonPdistCtlDeletes"), ("DSMON-MIB", "dsmonPdistCtlCreateTime"), ("DSMON-MIB", "dsmonPdistCtlOwner"), ("DSMON-MIB", "dsmonPdistCtlStatus"), ("DSMON-MIB", "dsmonPdistStatsPkts"), ("DSMON-MIB", "dsmonPdistStatsOctets"), ("DSMON-MIB", "dsmonPdistStatsCreateTime"), ("DSMON-MIB", "dsmonPdistTopNCtlPdistIndex"), ("DSMON-MIB", "dsmonPdistTopNCtlRateBase"), ("DSMON-MIB", "dsmonPdistTopNCtlTimeRemaining"), ("DSMON-MIB", "dsmonPdistTopNCtlGeneratedReprts"), ("DSMON-MIB", "dsmonPdistTopNCtlDuration"), ("DSMON-MIB", "dsmonPdistTopNCtlRequestedSize"), ("DSMON-MIB", "dsmonPdistTopNCtlGrantedSize"), ("DSMON-MIB", "dsmonPdistTopNCtlStartTime"), ("DSMON-MIB", "dsmonPdistTopNCtlOwner"), ("DSMON-MIB", "dsmonPdistTopNCtlStatus"), ("DSMON-MIB", "dsmonPdistTopNPDLocalIndex"), ("DSMON-MIB", "dsmonPdistTopNAggGroup"), ("DSMON-MIB", "dsmonPdistTopNRate"),))
if mibBuilder.loadTexts: dsmonPdistGroup.setDescription('A collection of objects providing per protocol DSCP\n            monitoring extensions to the RMON-2 MIB.')
dsmonPdistOvflGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 26, 3, 2, 6)).setObjects(*(("DSMON-MIB", "dsmonPdistStatsOvflPkts"), ("DSMON-MIB", "dsmonPdistStatsOvflOctets"), ("DSMON-MIB", "dsmonPdistTopNRateOvfl"),))
if mibBuilder.loadTexts: dsmonPdistOvflGroup.setDescription('A collection of objects providing per-protocol DSCP\n            overflow counters for systems with high capacity data\n            sources, but without support for the Counter64 data type.')
dsmonPdistHCGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 26, 3, 2, 7)).setObjects(*(("DSMON-MIB", "dsmonPdistStatsHCPkts"), ("DSMON-MIB", "dsmonPdistStatsHCOctets"), ("DSMON-MIB", "dsmonPdistTopNHCRate"),))
if mibBuilder.loadTexts: dsmonPdistHCGroup.setDescription('A collection of objects providing per protocol DSCP\n            monitoring extensions to the RMON-2 MIB for High Capacity\n            networks.')
dsmonHostGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 26, 3, 2, 8)).setObjects(*(("DSMON-MIB", "dsmonHostCtlDataSource"), ("DSMON-MIB", "dsmonHostCtlAggProfile"), ("DSMON-MIB", "dsmonHostCtlMaxDesiredEntries"), ("DSMON-MIB", "dsmonHostCtlIPv4PrefixLen"), ("DSMON-MIB", "dsmonHostCtlIPv6PrefixLen"), ("DSMON-MIB", "dsmonHostCtlDroppedFrames"), ("DSMON-MIB", "dsmonHostCtlInserts"), ("DSMON-MIB", "dsmonHostCtlDeletes"), ("DSMON-MIB", "dsmonHostCtlCreateTime"), ("DSMON-MIB", "dsmonHostCtlOwner"), ("DSMON-MIB", "dsmonHostCtlStatus"), ("DSMON-MIB", "dsmonHostInPkts"), ("DSMON-MIB", "dsmonHostInOctets"), ("DSMON-MIB", "dsmonHostOutPkts"), ("DSMON-MIB", "dsmonHostOutOctets"), ("DSMON-MIB", "dsmonHostCreateTime"), ("DSMON-MIB", "dsmonHostTopNCtlHostIndex"), ("DSMON-MIB", "dsmonHostTopNCtlRateBase"), ("DSMON-MIB", "dsmonHostTopNCtlTimeRemaining"), ("DSMON-MIB", "dsmonHostTopNCtlGeneratedReports"), ("DSMON-MIB", "dsmonHostTopNCtlDuration"), ("DSMON-MIB", "dsmonHostTopNCtlRequestedSize"), ("DSMON-MIB", "dsmonHostTopNCtlGrantedSize"), ("DSMON-MIB", "dsmonHostTopNCtlStartTime"), ("DSMON-MIB", "dsmonHostTopNCtlOwner"), ("DSMON-MIB", "dsmonHostTopNCtlStatus"), ("DSMON-MIB", "dsmonHostTopNPDLocalIndex"), ("DSMON-MIB", "dsmonHostTopNAddress"), ("DSMON-MIB", "dsmonHostTopNAggGroup"), ("DSMON-MIB", "dsmonHostTopNRate"),))
if mibBuilder.loadTexts: dsmonHostGroup.setDescription('A collection of objects providing per Host monitoring\n\n            functions.')
dsmonHostOvflGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 26, 3, 2, 9)).setObjects(*(("DSMON-MIB", "dsmonHostInOvflPkts"), ("DSMON-MIB", "dsmonHostInOvflOctets"), ("DSMON-MIB", "dsmonHostOutOvflPkts"), ("DSMON-MIB", "dsmonHostOutOvflOctets"), ("DSMON-MIB", "dsmonHostTopNRateOvfl"),))
if mibBuilder.loadTexts: dsmonHostOvflGroup.setDescription('A collection of objects providing per host DSCP overflow\n            counters for systems with high capacity data sources, but\n            without support for the Counter64 data type.')
dsmonHostHCGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 26, 3, 2, 10)).setObjects(*(("DSMON-MIB", "dsmonHostInHCPkts"), ("DSMON-MIB", "dsmonHostInHCOctets"), ("DSMON-MIB", "dsmonHostOutHCPkts"), ("DSMON-MIB", "dsmonHostOutHCOctets"), ("DSMON-MIB", "dsmonHostTopNHCRate"),))
if mibBuilder.loadTexts: dsmonHostHCGroup.setDescription('A collection of objects providing per Host monitoring\n            functions for High Capacity networks.')
dsmonCapsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 26, 3, 2, 11)).setObjects(*(("DSMON-MIB", "dsmonCapabilities"),))
if mibBuilder.loadTexts: dsmonCapsGroup.setDescription('A collection of objects providing an indication of the\n            DSMON monitoring functions supported by the agent.')
dsmonMatrixGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 26, 3, 2, 12)).setObjects(*(("DSMON-MIB", "dsmonMatrixCtlDataSource"), ("DSMON-MIB", "dsmonMatrixCtlAggProfile"), ("DSMON-MIB", "dsmonMatrixCtlMaxDesiredEntries"), ("DSMON-MIB", "dsmonMatrixCtlDroppedFrames"), ("DSMON-MIB", "dsmonMatrixCtlInserts"), ("DSMON-MIB", "dsmonMatrixCtlDeletes"), ("DSMON-MIB", "dsmonMatrixCtlCreateTime"), ("DSMON-MIB", "dsmonMatrixCtlOwner"), ("DSMON-MIB", "dsmonMatrixCtlStatus"), ("DSMON-MIB", "dsmonMatrixSDPkts"), ("DSMON-MIB", "dsmonMatrixSDOctets"), ("DSMON-MIB", "dsmonMatrixSDCreateTime"), ("DSMON-MIB", "dsmonMatrixDSPkts"), ("DSMON-MIB", "dsmonMatrixDSOctets"), ("DSMON-MIB", "dsmonMatrixDSCreateTime"), ("DSMON-MIB", "dsmonMatrixTopNCtlMatrixIndex"), ("DSMON-MIB", "dsmonMatrixTopNCtlRateBase"), ("DSMON-MIB", "dsmonMatrixTopNCtlTimeRemaining"), ("DSMON-MIB", "dsmonMatrixTopNCtlGeneratedRpts"), ("DSMON-MIB", "dsmonMatrixTopNCtlDuration"), ("DSMON-MIB", "dsmonMatrixTopNCtlRequestedSize"), ("DSMON-MIB", "dsmonMatrixTopNCtlGrantedSize"), ("DSMON-MIB", "dsmonMatrixTopNCtlStartTime"), ("DSMON-MIB", "dsmonMatrixTopNCtlOwner"), ("DSMON-MIB", "dsmonMatrixTopNCtlStatus"), ("DSMON-MIB", "dsmonMatrixTopNAggGroup"), ("DSMON-MIB", "dsmonMatrixTopNNLIndex"), ("DSMON-MIB", "dsmonMatrixTopNSourceAddress"), ("DSMON-MIB", "dsmonMatrixTopNDestAddress"), ("DSMON-MIB", "dsmonMatrixTopNALIndex"), ("DSMON-MIB", "dsmonMatrixTopNPktRate"), ("DSMON-MIB", "dsmonMatrixTopNRevPktRate"), ("DSMON-MIB", "dsmonMatrixTopNOctetRate"), ("DSMON-MIB", "dsmonMatrixTopNRevOctetRate"),))
if mibBuilder.loadTexts: dsmonMatrixGroup.setDescription('A collection of objects providing per conversation\n            monitoring functions.')
dsmonMatrixOvflGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 26, 3, 2, 13)).setObjects(*(("DSMON-MIB", "dsmonMatrixSDOvflPkts"), ("DSMON-MIB", "dsmonMatrixSDOvflOctets"), ("DSMON-MIB", "dsmonMatrixDSOvflPkts"), ("DSMON-MIB", "dsmonMatrixDSOvflOctets"), ("DSMON-MIB", "dsmonMatrixTopNPktRateOvfl"), ("DSMON-MIB", "dsmonMatrixTopNRevPktRateOvfl"), ("DSMON-MIB", "dsmonMatrixTopNOctetRateOvfl"), ("DSMON-MIB", "dsmonMatrixTopNRevOctetRateOvfl"),))
if mibBuilder.loadTexts: dsmonMatrixOvflGroup.setDescription('A collection of objects providing per conversation\n            monitoring functions for systems with high capacity data\n            sources, but without support for the Counter64 data type.')
dsmonMatrixHCGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 26, 3, 2, 14)).setObjects(*(("DSMON-MIB", "dsmonMatrixSDHCPkts"), ("DSMON-MIB", "dsmonMatrixSDHCOctets"), ("DSMON-MIB", "dsmonMatrixDSHCPkts"), ("DSMON-MIB", "dsmonMatrixDSHCOctets"), ("DSMON-MIB", "dsmonMatrixTopNHCPktRate"), ("DSMON-MIB", "dsmonMatrixTopNHCRevPktRate"), ("DSMON-MIB", "dsmonMatrixTopNHCOctetRate"), ("DSMON-MIB", "dsmonMatrixTopNHCRevOctetRate"),))
if mibBuilder.loadTexts: dsmonMatrixHCGroup.setDescription('A collection of objects providing per conversation\n            monitoring functions for High Capacity networks.')
mibBuilder.exportSymbols("DSMON-MIB", dsmonStatsGroup=dsmonStatsGroup, dsmonHostCtlInserts=dsmonHostCtlInserts, dsmonMatrixCtlAggProfile=dsmonMatrixCtlAggProfile, dsmonHostOutHCOctets=dsmonHostOutHCOctets, dsmonCapsGroup=dsmonCapsGroup, dsmonGroups=dsmonGroups, dsmonPdistStatsOvflOctets=dsmonPdistStatsOvflOctets, dsmonMatrixHCGroup=dsmonMatrixHCGroup, dsmonMatrixDSEntry=dsmonMatrixDSEntry, dsmonMatrixSDTable=dsmonMatrixSDTable, dsmonStatsControlEntry=dsmonStatsControlEntry, dsmonStatsControlTable=dsmonStatsControlTable, dsmonMatrixCtlStatus=dsmonMatrixCtlStatus, dsmonMatrixTopNHCRevPktRate=dsmonMatrixTopNHCRevPktRate, dsmonStatsInHCPkts=dsmonStatsInHCPkts, dsmonPdistCtlDataSource=dsmonPdistCtlDataSource, dsmonHostCtlIndex=dsmonHostCtlIndex, dsmonHostCreateTime=dsmonHostCreateTime, dsmonHostTopNTable=dsmonHostTopNTable, dsmonMatrixTopNDestAddress=dsmonMatrixTopNDestAddress, dsmonStatsOutHCOctets=dsmonStatsOutHCOctets, dsmonPdistTopNCtlOwner=dsmonPdistTopNCtlOwner, dsmonMaxAggGroups=dsmonMaxAggGroups, dsmonMatrixSDOvflOctets=dsmonMatrixSDOvflOctets, dsmonStatsObjects=dsmonStatsObjects, dsmonMatrixTopNEntry=dsmonMatrixTopNEntry, dsmonMatrixTopNPktRateOvfl=dsmonMatrixTopNPktRateOvfl, dsmonPdistTopNCtlRequestedSize=dsmonPdistTopNCtlRequestedSize, dsmonAggControlOwner=dsmonAggControlOwner, dsmonStatsControlCreateTime=dsmonStatsControlCreateTime, dsmonAggGroupStatus=dsmonAggGroupStatus, dsmonHostCtlDataSource=dsmonHostCtlDataSource, dsmonPdistCtlOwner=dsmonPdistCtlOwner, dsmonPdistTopNCtlGeneratedReprts=dsmonPdistTopNCtlGeneratedReprts, dsmonMatrixTopNCtlStatus=dsmonMatrixTopNCtlStatus, dsmonMatrixTopNRevOctetRate=dsmonMatrixTopNRevOctetRate, dsmonCounterAggControlGroup=dsmonCounterAggControlGroup, dsmonAggGroupTable=dsmonAggGroupTable, dsmonPdistTopNEntry=dsmonPdistTopNEntry, dsmonMIB=dsmonMIB, dsmonPdistStatsHCPkts=dsmonPdistStatsHCPkts, dsmonHostOutOvflPkts=dsmonHostOutOvflPkts, dsmonMatrixSDCreateTime=dsmonMatrixSDCreateTime, dsmonMatrixTopNAggGroup=dsmonMatrixTopNAggGroup, dsmonMatrixTopNHCRevOctetRate=dsmonMatrixTopNHCRevOctetRate, dsmonMatrixOvflGroup=dsmonMatrixOvflGroup, dsmonStatsInOvflPkts=dsmonStatsInOvflPkts, dsmonStatsOutOvflOctets=dsmonStatsOutOvflOctets, dsmonPdistTopNCtlRateBase=dsmonPdistTopNCtlRateBase, dsmonAggControlChanges=dsmonAggControlChanges, dsmonHostTopNCtlTimeRemaining=dsmonHostTopNCtlTimeRemaining, dsmonPdistCtlStatus=dsmonPdistCtlStatus, dsmonMatrixCtlMaxDesiredEntries=dsmonMatrixCtlMaxDesiredEntries, dsmonHostOutOctets=dsmonHostOutOctets, dsmonHostTopNAggGroup=dsmonHostTopNAggGroup, dsmonPdistCtlDeletes=dsmonPdistCtlDeletes, dsmonHostOvflGroup=dsmonHostOvflGroup, dsmonMatrixTopNCtlMatrixIndex=dsmonMatrixTopNCtlMatrixIndex, dsmonMatrixTopNCtlRateBase=dsmonMatrixTopNCtlRateBase, dsmonHostTopNRate=dsmonHostTopNRate, dsmonMatrixCtlOwner=dsmonMatrixCtlOwner, dsmonMatrixTopNRevOctetRateOvfl=dsmonMatrixTopNRevOctetRateOvfl, dsmonMatrixTopNALIndex=dsmonMatrixTopNALIndex, dsmonNotifications=dsmonNotifications, dsmonHostTopNCtlStatus=dsmonHostTopNCtlStatus, dsmonCompliances=dsmonCompliances, dsmonPdistHCGroup=dsmonPdistHCGroup, dsmonHostCtlMaxDesiredEntries=dsmonHostCtlMaxDesiredEntries, dsmonHCNoC64Compliance=dsmonHCNoC64Compliance, dsmonPdistTopNCtlDuration=dsmonPdistTopNCtlDuration, dsmonMatrixTopNIndex=dsmonMatrixTopNIndex, dsmonMatrixTopNCtlIndex=dsmonMatrixTopNCtlIndex, dsmonCompliance=dsmonCompliance, dsmonHostInHCOctets=dsmonHostInHCOctets, dsmonStatsControlIndex=dsmonStatsControlIndex, dsmonHostTopNRateOvfl=dsmonHostTopNRateOvfl, dsmonPdistTopNPDLocalIndex=dsmonPdistTopNPDLocalIndex, dsmonHostTopNCtlHostIndex=dsmonHostTopNCtlHostIndex, dsmonAggObjects=dsmonAggObjects, dsmonMatrixTopNHCPktRate=dsmonMatrixTopNHCPktRate, dsmonHostTopNCtlGeneratedReports=dsmonHostTopNCtlGeneratedReports, dsmonPdistCtlInserts=dsmonPdistCtlInserts, dsmonHostInOvflPkts=dsmonHostInOvflPkts, dsmonMatrixDSOctets=dsmonMatrixDSOctets, dsmonMatrixTopNCtlGrantedSize=dsmonMatrixTopNCtlGrantedSize, dsmonHostTopNCtlStartTime=dsmonHostTopNCtlStartTime, dsmonAggControlTable=dsmonAggControlTable, dsmonMatrixGroup=dsmonMatrixGroup, dsmonStatsTable=dsmonStatsTable, DsmonCounterAggProfileIndex=DsmonCounterAggProfileIndex, dsmonStatsOutOctets=dsmonStatsOutOctets, dsmonMatrixCtlEntry=dsmonMatrixCtlEntry, dsmonPdistStatsCreateTime=dsmonPdistStatsCreateTime, dsmonAggGroupEntry=dsmonAggGroupEntry, dsmonHostInPkts=dsmonHostInPkts, dsmonMatrixALIndex=dsmonMatrixALIndex, dsmonMatrixDSOvflOctets=dsmonMatrixDSOvflOctets, dsmonHostOutOvflOctets=dsmonHostOutOvflOctets, dsmonStatsControlAggProfile=dsmonStatsControlAggProfile, dsmonHostCtlDeletes=dsmonHostCtlDeletes, dsmonPdistTopNHCRate=dsmonPdistTopNHCRate, dsmonMatrixTimeMark=dsmonMatrixTimeMark, dsmonHostGroup=dsmonHostGroup, PYSNMP_MODULE_ID=dsmonMIB, dsmonStatsInOctets=dsmonStatsInOctets, dsmonPdistTopNCtlGrantedSize=dsmonPdistTopNCtlGrantedSize, dsmonPdistOvflGroup=dsmonPdistOvflGroup, dsmonMatrixObjects=dsmonMatrixObjects, dsmonMatrixTopNSourceAddress=dsmonMatrixTopNSourceAddress, dsmonMatrixTopNCtlGeneratedRpts=dsmonMatrixTopNCtlGeneratedRpts, dsmonHostOutHCPkts=dsmonHostOutHCPkts, dsmonPdistCtlIndex=dsmonPdistCtlIndex, dsmonMatrixTopNHCOctetRate=dsmonMatrixTopNHCOctetRate, dsmonHostTopNIndex=dsmonHostTopNIndex, dsmonHostInOctets=dsmonHostInOctets, dsmonPdistStatsEntry=dsmonPdistStatsEntry, dsmonHCCompliance=dsmonHCCompliance, dsmonMatrixTopNCtlTable=dsmonMatrixTopNCtlTable, dsmonMatrixTopNRevPktRate=dsmonMatrixTopNRevPktRate, dsmonHostTopNHCRate=dsmonHostTopNHCRate, dsmonStatsControlOwner=dsmonStatsControlOwner, dsmonPdistTopNCtlIndex=dsmonPdistTopNCtlIndex, dsmonMatrixDSTable=dsmonMatrixDSTable, dsmonPdistTopNCtlStartTime=dsmonPdistTopNCtlStartTime, dsmonPdistCtlAggProfile=dsmonPdistCtlAggProfile, dsmonMatrixDSHCOctets=dsmonMatrixDSHCOctets, dsmonHostTopNPDLocalIndex=dsmonHostTopNPDLocalIndex, dsmonMatrixCtlDeletes=dsmonMatrixCtlDeletes, dsmonMatrixSDHCPkts=dsmonMatrixSDHCPkts, dsmonHostTopNCtlIndex=dsmonHostTopNCtlIndex, dsmonStatsHCGroup=dsmonStatsHCGroup, dsmonObjects=dsmonObjects, dsmonHostHCGroup=dsmonHostHCGroup, dsmonMatrixDSHCPkts=dsmonMatrixDSHCPkts, dsmonMatrixTopNCtlDuration=dsmonMatrixTopNCtlDuration, dsmonPdistStatsPkts=dsmonPdistStatsPkts, dsmonHostCtlAggProfile=dsmonHostCtlAggProfile, dsmonMatrixCtlDroppedFrames=dsmonMatrixCtlDroppedFrames, dsmonPdistCtlMaxDesiredEntries=dsmonPdistCtlMaxDesiredEntries, dsmonHostCtlStatus=dsmonHostCtlStatus, dsmonStatsOutOvflPkts=dsmonStatsOutOvflPkts, dsmonMatrixTopNPktRate=dsmonMatrixTopNPktRate, dsmonHostOutPkts=dsmonHostOutPkts, dsmonStatsControlDataSource=dsmonStatsControlDataSource, dsmonConformance=dsmonConformance, dsmonHostTopNAddress=dsmonHostTopNAddress, dsmonHostTopNCtlRequestedSize=dsmonHostTopNCtlRequestedSize, dsmonPdistTopNTable=dsmonPdistTopNTable, dsmonPdistTopNCtlStatus=dsmonPdistTopNCtlStatus, dsmonHostTimeMark=dsmonHostTimeMark, dsmonMatrixSDOvflPkts=dsmonMatrixSDOvflPkts, dsmonMatrixTopNOctetRate=dsmonMatrixTopNOctetRate, dsmonPdistCtlEntry=dsmonPdistCtlEntry, dsmonPdistTopNIndex=dsmonPdistTopNIndex, dsmonPdistCtlDroppedFrames=dsmonPdistCtlDroppedFrames, dsmonHostTopNCtlRateBase=dsmonHostTopNCtlRateBase, dsmonPdistTopNAggGroup=dsmonPdistTopNAggGroup, dsmonStatsControlDroppedFrames=dsmonStatsControlDroppedFrames, dsmonHostCtlTable=dsmonHostCtlTable, dsmonAggControlDescr=dsmonAggControlDescr, dsmonPdistStatsOctets=dsmonPdistStatsOctets, dsmonPdistTopNCtlTimeRemaining=dsmonPdistTopNCtlTimeRemaining, dsmonMatrixSDEntry=dsmonMatrixSDEntry, dsmonHostTopNCtlEntry=dsmonHostTopNCtlEntry, dsmonCapsObjects=dsmonCapsObjects, dsmonAggControlEntry=dsmonAggControlEntry, DsmonCounterAggGroupIndex=DsmonCounterAggGroupIndex, dsmonStatsOutHCPkts=dsmonStatsOutHCPkts, dsmonHostCtlIPv4PrefixLen=dsmonHostCtlIPv4PrefixLen, dsmonHostCtlOwner=dsmonHostCtlOwner, dsmonMatrixSourceAddress=dsmonMatrixSourceAddress, dsmonMatrixDSCreateTime=dsmonMatrixDSCreateTime, dsmonPdistTopNCtlEntry=dsmonPdistTopNCtlEntry, dsmonStatsOvflGroup=dsmonStatsOvflGroup, dsmonAggGroupIndex=dsmonAggGroupIndex, dsmonHostTopNCtlGrantedSize=dsmonHostTopNCtlGrantedSize, dsmonHostTopNCtlOwner=dsmonHostTopNCtlOwner, dsmonMatrixTopNCtlStartTime=dsmonMatrixTopNCtlStartTime, dsmonMatrixTopNCtlOwner=dsmonMatrixTopNCtlOwner, dsmonPdistStatsOvflPkts=dsmonPdistStatsOvflPkts, dsmonHostInHCPkts=dsmonHostInHCPkts, dsmonStatsInOvflOctets=dsmonStatsInOvflOctets, dsmonMatrixCtlTable=dsmonMatrixCtlTable, dsmonAggGroupDescr=dsmonAggGroupDescr, dsmonHostEntry=dsmonHostEntry, dsmonStatsInPkts=dsmonStatsInPkts, dsmonHostCtlDroppedFrames=dsmonHostCtlDroppedFrames, dsmonPdistTimeMark=dsmonPdistTimeMark, dsmonStatsControlStatus=dsmonStatsControlStatus, dsmonHostTopNCtlTable=dsmonHostTopNCtlTable, dsmonMatrixTopNRevPktRateOvfl=dsmonMatrixTopNRevPktRateOvfl, dsmonPdistGroup=dsmonPdistGroup, dsmonMatrixDestAddress=dsmonMatrixDestAddress, dsmonMatrixTopNCtlEntry=dsmonMatrixTopNCtlEntry, dsmonMatrixTopNCtlTimeRemaining=dsmonMatrixTopNCtlTimeRemaining, dsmonStatsInHCOctets=dsmonStatsInHCOctets, dsmonMatrixCtlDataSource=dsmonMatrixCtlDataSource, dsmonPdistTopNCtlPdistIndex=dsmonPdistTopNCtlPdistIndex, dsmonHostTable=dsmonHostTable, dsmonPdistTopNRate=dsmonPdistTopNRate, dsmonPdistObjects=dsmonPdistObjects, dsmonPdistCtlTable=dsmonPdistCtlTable, dsmonMatrixCtlIndex=dsmonMatrixCtlIndex, dsmonMatrixSDOctets=dsmonMatrixSDOctets, dsmonMatrixTopNNLIndex=dsmonMatrixTopNNLIndex, dsmonPdistStatsTable=dsmonPdistStatsTable, dsmonAggControlStatus=dsmonAggControlStatus, dsmonCapabilities=dsmonCapabilities, dsmonHostTopNEntry=dsmonHostTopNEntry, dsmonHostCtlCreateTime=dsmonHostCtlCreateTime, dsmonMatrixNLIndex=dsmonMatrixNLIndex, dsmonAggControlLocked=dsmonAggControlLocked, dsmonHostObjects=dsmonHostObjects, dsmonAggControlLastChangeTime=dsmonAggControlLastChangeTime, dsmonAggProfileDSCP=dsmonAggProfileDSCP, dsmonStatsEntry=dsmonStatsEntry, dsmonPdistTopNCtlTable=dsmonPdistTopNCtlTable, dsmonMatrixDSPkts=dsmonMatrixDSPkts, dsmonAggControlIndex=dsmonAggControlIndex, dsmonPdistTopNRateOvfl=dsmonPdistTopNRateOvfl, dsmonHostInOvflOctets=dsmonHostInOvflOctets, dsmonMatrixSDHCOctets=dsmonMatrixSDHCOctets, dsmonMatrixDSOvflPkts=dsmonMatrixDSOvflPkts, dsmonMatrixTopNCtlRequestedSize=dsmonMatrixTopNCtlRequestedSize, dsmonMatrixSDPkts=dsmonMatrixSDPkts, dsmonHostTopNCtlDuration=dsmonHostTopNCtlDuration, dsmonMatrixTopNTable=dsmonMatrixTopNTable, dsmonMatrixCtlCreateTime=dsmonMatrixCtlCreateTime, dsmonPdistCtlCreateTime=dsmonPdistCtlCreateTime, dsmonMatrixTopNOctetRateOvfl=dsmonMatrixTopNOctetRateOvfl, dsmonHostAddress=dsmonHostAddress, dsmonPdistStatsHCOctets=dsmonPdistStatsHCOctets, dsmonHostCtlIPv6PrefixLen=dsmonHostCtlIPv6PrefixLen, dsmonHostCtlEntry=dsmonHostCtlEntry, dsmonMatrixCtlInserts=dsmonMatrixCtlInserts, dsmonAggProfileTable=dsmonAggProfileTable, dsmonStatsOutPkts=dsmonStatsOutPkts, dsmonAggProfileEntry=dsmonAggProfileEntry)
