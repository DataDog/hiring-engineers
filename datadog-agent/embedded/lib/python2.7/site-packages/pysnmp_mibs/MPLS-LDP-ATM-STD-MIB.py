#
# PySNMP MIB module MPLS-LDP-ATM-STD-MIB (http://pysnmp.sf.net)
# ASN.1 source http://mibs.snmplabs.com:80/asn1/MPLS-LDP-ATM-STD-MIB
# Produced by pysmi-0.0.7 at Sun Feb 14 00:21:17 2016
# On host bldfarm platform Linux version 4.1.13-100.fc21.x86_64 by user goose
# Using Python version 3.5.0 (default, Jan  5 2016, 17:11:52) 
#
( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint")
( AtmVpIdentifier, ) = mibBuilder.importSymbols("ATM-TC-MIB", "AtmVpIdentifier")
( InterfaceIndexOrZero, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
( mplsLdpEntityIndex, mplsLdpPeerLdpId, mplsLdpEntityLdpId, ) = mibBuilder.importSymbols("MPLS-LDP-STD-MIB", "mplsLdpEntityIndex", "mplsLdpPeerLdpId", "mplsLdpEntityLdpId")
( mplsStdMIB, MplsAtmVcIdentifier, ) = mibBuilder.importSymbols("MPLS-TC-STD-MIB", "mplsStdMIB", "MplsAtmVcIdentifier")
( ObjectGroup, ModuleCompliance, NotificationGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
( MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, ObjectIdentity, ModuleIdentity, IpAddress, Bits, Counter64, NotificationType, Counter32, iso, MibIdentifier, Integer32, TimeTicks, Gauge32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "ObjectIdentity", "ModuleIdentity", "IpAddress", "Bits", "Counter64", "NotificationType", "Counter32", "iso", "MibIdentifier", "Integer32", "TimeTicks", "Gauge32")
( DisplayString, StorageType, TextualConvention, RowStatus, ) = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "StorageType", "TextualConvention", "RowStatus")
mplsLdpAtmStdMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 10, 166, 5)).setRevisions(("2004-06-03 00:00",))
if mibBuilder.loadTexts: mplsLdpAtmStdMIB.setLastUpdated('200406030000Z')
if mibBuilder.loadTexts: mplsLdpAtmStdMIB.setOrganization('Multiprotocol Label Switching (mpls)\n                  Working Group')
if mibBuilder.loadTexts: mplsLdpAtmStdMIB.setContactInfo('Joan Cucchiara (jcucchiara@mindspring.com)\n         Marconi Communications, Inc.\n\n         Hans Sjostrand (hans@ipunplugged.com)\n         ipUnplugged\n\n         James V. Luciani (james_luciani@mindspring.com)\n         Marconi Communications, Inc.\n\n         Working Group Chairs:\n         George Swallow,   email: swallow@cisco.com\n         Loa Andersson,    email: loa@pi.se\n\n         MPLS Working Group, email: mpls@uu.net\n    ')
if mibBuilder.loadTexts: mplsLdpAtmStdMIB.setDescription('Copyright (C) The Internet Society (2004). The\n        initial version of this MIB module was published\n        in RFC 3815. For full legal notices see the RFC\n        itself or see:\n        http://www.ietf.org/copyrights/ianamib.html\n\n        This MIB contains managed object definitions for\n        configuring and monitoring the Multiprotocol Label\n        Switching (MPLS), Label Distribution Protocol (LDP),\n        utilizing Asynchronous Transfer Mode (ATM) as the Layer 2\n        media.')
mplsLdpAtmObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 5, 1))
mplsLdpAtmConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 5, 2))
mplsLdpEntityAtmObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1))
mplsLdpEntityAtmTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1), )
if mibBuilder.loadTexts: mplsLdpEntityAtmTable.setDescription("This table contains ATM specific information\n        which could be used in the\n        'Optional Parameters' and other ATM specific\n        information.\n\n        This table 'sparse augments' the mplsLdpEntityTable\n        when ATM is the Layer 2 medium.")
mplsLdpEntityAtmEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1), ).setIndexNames((0, "MPLS-LDP-STD-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-STD-MIB", "mplsLdpEntityIndex"))
if mibBuilder.loadTexts: mplsLdpEntityAtmEntry.setDescription('An entry in this table represents the ATM parameters\n        and ATM information for this LDP entity.')
mplsLdpEntityAtmIfIndexOrZero = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 1), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmIfIndexOrZero.setDescription('This value represents either the InterfaceIndex\n       or 0 (zero).  The value of zero means that the\n       InterfaceIndex is not known.\n\n       However, if the InterfaceIndex is known, then it must\n       be represented by this value.\n\n       If an InterfaceIndex becomes known, then the\n       network management entity (e.g., SNMP agent) responsible\n       for this object MUST change the value from 0 (zero) to the\n       value of the InterfaceIndex.  If an ATM Label is\n       being used in forwarding data, then the value of this\n       object MUST be the InterfaceIndex.')
mplsLdpEntityAtmMergeCap = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3,))).clone(namedValues=NamedValues(("notSupported", 0), ("vpMerge", 1), ("vcMerge", 2), ("vpAndVcMerge", 3),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmMergeCap.setDescription("Denotes the Merge Capability of this Entity.\n        This is the EXACT value for the ATM Session\n        Parameter, field M (for ATM Merge Capabilities).\n        The ATM Session Parameter is an optional\n        parameter in the Initialization Message.\n\n        The description from rfc3036.txt is:\n\n        'M, ATM Merge Capabilities\n           Specifies the merge capabilities of an ATM switch.  The\n           following values are supported in this version of the\n           specification:\n\n                  Value          Meaning\n\n                    0            Merge not supported\n                    1            VP Merge supported\n                    2            VC Merge supported\n                    3            VP & VC Merge supported\n\n\n           If the merge capabilities of the LSRs differ, then:\n           -  Non-merge and VC-merge LSRs may freely interoperate.\n\n           -  The interoperability of VP-merge-capable switches\n              with non-VP-merge-capable switches is a subject\n              for future study.  When the LSRs differ on the\n              use of VP-merge, the session is established,\n              but VP merge is not used.'\n\n           Please refer to the following reference for a\n           complete description of this feature.")
mplsLdpEntityAtmLRComponents = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1,65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityAtmLRComponents.setDescription("Number of Label Range Components in the Initialization\n        message.  This also represents the number of entries\n        in the mplsLdpEntityAtmLRTable which correspond\n        to this entry.\n\n        This is the EXACT value for the ATM Session Parameter,\n        field N (for Number of label range components).\n        The ATM Session Parameter is an optional parameter\n        in the Initialization Message.\n\n        The description from rfc3036.txt is:\n\n        'N, Number of label range components\n           Specifies the number of ATM Label Range\n           Components included in the TLV.'\n\n         Please refer to the following reference for\n         a complete description of this feature.")
mplsLdpEntityAtmVcDirectionality = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1,))).clone(namedValues=NamedValues(("bidirectional", 0), ("unidirectional", 1),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmVcDirectionality.setDescription("If the value of this object is 'bidirectional(0)',\n        a given VCI, within a given VPI, is used as a\n        label for both directions independently.\n\n        If the value of this object is 'unidirectional(1)',\n        a given VCI within a VPI designates one direction.\n\n        This is the EXACT value for the ATM Session Parameter,\n        field D (for VC Directionality).  The ATM Session\n        Parameter is an optional parameter in the\n        Initialization Message.\n\n        The description from rfc3036.txt is:\n\n        'D, VC Directionality\n           A value of 0 specifies bidirectional VC capability,\n           meaning the LSR can (within a given VPI) support\n           the use of a given VCI as a label for both link\n           directions independently.  A value of 1\n           specifies unidirectional VC capability, meaning\n           (within a given VPI) a given VCI may appear in\n           a label mapping for one direction on the link\n           only.  When either or both of the peers\n           specifies unidirectional VC capability, both\n           LSRs use unidirectional VC label assignment for\n           the link as follows.  The LSRs compare their\n           LDP Identifiers as unsigned integers.  The LSR\n           with the larger LDP Identifier may assign\n           only odd-numbered VCIs in the VPI/VCI\n           range as labels.  The system with the smaller\n           LDP Identifier may assign only even-numbered\n           VCIs in the VPI/VCI range as labels.'\n\n           Please refer to the following reference\n           for a complete description of this feature.")
mplsLdpEntityAtmLsrConnectivity = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("direct", 1), ("indirect", 2),)).clone('direct')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmLsrConnectivity.setDescription('The peer LSR may be connected indirectly by means\n        of an ATM VP so that the VPI values may be different\n        on either endpoint so the label MUST be encoded\n        entirely within the VCI field.')
mplsLdpEntityAtmDefaultControlVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 6), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmDefaultControlVpi.setDescription('The default VPI value for the non-MPLS connection.  The\n        default value of this is 0 (zero) but other values may\n        be configured.  This object allows a different value\n        to be configured.')
mplsLdpEntityAtmDefaultControlVci = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 7), MplsAtmVcIdentifier().clone(32)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmDefaultControlVci.setDescription('The Default VCI value for a non-MPLS connection.  The\n        default value of this is 32 but other values may be\n        configured.  This object allows a different value to\n        be configured.')
mplsLdpEntityAtmUnlabTrafVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 8), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmUnlabTrafVpi.setDescription("VPI value of the VCC supporting unlabeled traffic.  This\n        non-MPLS connection is used to carry unlabeled (IP)\n        packets.  The default value is the same as the default\n        value of the 'mplsLdpEntityAtmDefaultControlVpi', however\n        another value may be configured.")
mplsLdpEntityAtmUnlabTrafVci = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 9), MplsAtmVcIdentifier().clone(32)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmUnlabTrafVci.setDescription("VCI value of the VCC supporting unlabeled traffic.\n        This non-MPLS connection is used to carry unlabeled (IP)\n        packets. The default value is the same as the default\n        value of the 'mplsLdpEntityAtmDefaultControlVci', however\n        another value may be configured.")
mplsLdpEntityAtmStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 10), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmStorageType.setDescription("The storage type for this conceptual row.\n        Conceptual rows having the value 'permanent(4)'\n        need not allow write-access to any columnar\n        objects in the row.")
mplsLdpEntityAtmRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmRowStatus.setDescription("The status of this conceptual row.  All writable\n         objects in this row may be modified at any time,\n         however, as described in detail in the section\n         entitled, 'Changing Values After Session\n         Establishment', and again described in the\n         DESCRIPTION clause of the mplsLdpEntityAdminStatus\n         object, if a session has been initiated with a Peer,\n         changing objects in this table will wreak havoc\n         with the session and interrupt traffic.  To repeat again:\n         the recommended procedure is to set the\n         mplsLdpEntityAdminStatus to down, thereby explicitly\n         causing a session to be torn down. Then,\n         change objects in this entry, then set the\n         mplsLdpEntityAdminStatus to enable\n         which enables a new session to be initiated.")
mplsLdpEntityAtmLRTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2), )
if mibBuilder.loadTexts: mplsLdpEntityAtmLRTable.setDescription("The MPLS LDP Entity ATM Label Range (LR) Table.\n        The purpose of this table is to provide a mechanism\n        for configuring a contiguous range of vpi's\n        with a contiguous range of vci's, or a 'label range'\n        for LDP Entities.\n\n        LDP Entities which use ATM must have at least one\n        entry in this table.\n\n        There must exist at least one entry in this\n        table for every LDP Entity that has\n        'mplsLdpEntityOptionalParameters' object with\n        a value of 'atmSessionParameters'.")
mplsLdpEntityAtmLREntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2, 1), ).setIndexNames((0, "MPLS-LDP-STD-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-STD-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLRMinVpi"), (0, "MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLRMinVci"))
if mibBuilder.loadTexts: mplsLdpEntityAtmLREntry.setDescription('A row in the LDP Entity ATM Label\n        Range Table.  One entry in this table contains\n        information on a single range of labels\n        represented by the configured Upper and Lower\n        Bounds VPI/VCI pairs.  These are the same\n        data used in the Initialization Message.\n\n        NOTE:  The ranges for a specific LDP Entity\n        are UNIQUE and non-overlapping.  For example,\n        for a specific LDP Entity index, there could\n        be one entry having LowerBound vpi/vci == 0/32, and\n        UpperBound vpi/vci == 0/100, and a second entry\n        for this same interface with LowerBound\n        vpi/vci == 0/101 and UpperBound vpi/vci == 0/200.\n        However, there could not be a third entry with\n        LowerBound vpi/vci == 0/200 and\n        UpperBound vpi/vci == 0/300 because this label\n        range overlaps with the second entry (i.e., both\n        entries now have 0/200).\n\n\n        A row will not become active unless a unique and\n        non-overlapping range is specified.\n\n        At least one label range entry for a\n        specific LDP Entity MUST\n        include the default VPI/VCI  values denoted\n        in the LDP Entity Table.\n\n        A request to create a row with an overlapping\n        range should result in an inconsistentValue\n        error.')
mplsLdpEntityAtmLRMinVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2, 1, 1), AtmVpIdentifier())
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMinVpi.setDescription('The minimum VPI number configured for this range.\n        The value of zero is a valid value for the VPI portion\n        of the label.')
mplsLdpEntityAtmLRMinVci = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2, 1, 2), MplsAtmVcIdentifier())
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMinVci.setDescription('The minimum VCI number configured for this range.')
mplsLdpEntityAtmLRMaxVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2, 1, 3), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMaxVpi.setDescription('The maximum VPI number configured for this range.')
mplsLdpEntityAtmLRMaxVci = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2, 1, 4), MplsAtmVcIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMaxVci.setDescription('The maximum VCI number configured for this range.')
mplsLdpEntityAtmLRStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmLRStorageType.setDescription("The storage type for this conceptual row.\n        Conceptual rows having the value 'permanent(4)'\n        need not allow write-access to any columnar\n        objects in the row.")
mplsLdpEntityAtmLRRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmLRRowStatus.setDescription("The status of this conceptual row.  All writable\n         objects in this row may be modified at any time,\n         however, as described in detail in the section\n         entitled, 'Changing Values After Session\n         Establishment', and again described in the\n         DESCRIPTION clause of the\n         mplsLdpEntityAdminStatus object,\n         if a session has been initiated with a Peer,\n         changing objects in this table will\n         wreak havoc with the session and interrupt traffic.\n         To repeat again:  the recommended procedure\n         is to set the mplsLdpEntityAdminStatus to\n         down, thereby explicitly causing a session\n         to be torn down. Then, change objects in this\n         entry, then set the mplsLdpEntityAdminStatus\n         to enable which enables a new session\n         to be initiated.")
mplsLdpAtmSessionObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 2))
mplsLdpAtmSessionTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 2, 1), )
if mibBuilder.loadTexts: mplsLdpAtmSessionTable.setDescription("A table which relates sessions in the\n        'mplsLdpSessionTable' and their label\n        range intersections.  There could be one\n        or more label range intersections between an\n        LDP Entity and LDP Peer using ATM as the\n        underlying  media.  Each row represents\n        a single label range intersection.\n\n        This table cannot use the 'AUGMENTS'\n        clause because there is not necessarily\n        a one-to-one mapping between this table\n        and the mplsLdpSessionTable.")
mplsLdpAtmSessionEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 2, 1, 1), ).setIndexNames((0, "MPLS-LDP-STD-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-STD-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-STD-MIB", "mplsLdpPeerLdpId"), (0, "MPLS-LDP-ATM-STD-MIB", "mplsLdpSessionAtmLRLowerBoundVpi"), (0, "MPLS-LDP-ATM-STD-MIB", "mplsLdpSessionAtmLRLowerBoundVci"))
if mibBuilder.loadTexts: mplsLdpAtmSessionEntry.setDescription('An entry in this table represents information on a\n        single label range intersection between an LDP Entity\n        and LDP Peer.\n\n        The information contained in a row is read-only.')
mplsLdpSessionAtmLRLowerBoundVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 2, 1, 1, 1), AtmVpIdentifier())
if mibBuilder.loadTexts: mplsLdpSessionAtmLRLowerBoundVpi.setDescription('The minimum VPI number for this range.')
mplsLdpSessionAtmLRLowerBoundVci = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 2, 1, 1, 2), MplsAtmVcIdentifier())
if mibBuilder.loadTexts: mplsLdpSessionAtmLRLowerBoundVci.setDescription('The minimum VCI number for this range.')
mplsLdpSessionAtmLRUpperBoundVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 2, 1, 1, 3), AtmVpIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionAtmLRUpperBoundVpi.setDescription('The maximum VPI number for this range.')
mplsLdpSessionAtmLRUpperBoundVci = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 2, 1, 1, 4), MplsAtmVcIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionAtmLRUpperBoundVci.setDescription('The maximum VCI number for this range.')
mplsLdpAtmGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 5, 2, 1))
mplsLdpAtmCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 5, 2, 2))
mplsLdpAtmModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 166, 5, 2, 2, 1)).setObjects(*(("MPLS-LDP-ATM-STD-MIB", "mplsLdpAtmGroup"),))
if mibBuilder.loadTexts: mplsLdpAtmModuleFullCompliance.setDescription('The Module is implemented with support for\n        read-create and read-write.  In other words,\n        both monitoring and configuration\n        are available when using this MODULE-COMPLIANCE.')
mplsLdpAtmModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 166, 5, 2, 2, 2)).setObjects(*(("MPLS-LDP-ATM-STD-MIB", "mplsLdpAtmGroup"),))
if mibBuilder.loadTexts: mplsLdpAtmModuleReadOnlyCompliance.setDescription('The Module is implemented with support for\n        read-only.  In other words, only monitoring\n        is available by implementing this MODULE-COMPLIANCE.')
mplsLdpAtmGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 5, 2, 1, 1)).setObjects(*(("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmIfIndexOrZero"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmMergeCap"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLRComponents"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmVcDirectionality"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLsrConnectivity"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmDefaultControlVpi"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmDefaultControlVci"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmUnlabTrafVpi"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmUnlabTrafVci"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmStorageType"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmRowStatus"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLRMaxVpi"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLRMaxVci"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLRStorageType"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLRRowStatus"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpSessionAtmLRUpperBoundVpi"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpSessionAtmLRUpperBoundVci"),))
if mibBuilder.loadTexts: mplsLdpAtmGroup.setDescription('Objects that apply to all MPLS LDP implementations\n        using ATM as the Layer 2.')
mibBuilder.exportSymbols("MPLS-LDP-ATM-STD-MIB", mplsLdpEntityAtmLRMinVci=mplsLdpEntityAtmLRMinVci, mplsLdpEntityAtmLRStorageType=mplsLdpEntityAtmLRStorageType, PYSNMP_MODULE_ID=mplsLdpAtmStdMIB, mplsLdpSessionAtmLRLowerBoundVpi=mplsLdpSessionAtmLRLowerBoundVpi, mplsLdpEntityAtmIfIndexOrZero=mplsLdpEntityAtmIfIndexOrZero, mplsLdpEntityAtmLRTable=mplsLdpEntityAtmLRTable, mplsLdpAtmGroups=mplsLdpAtmGroups, mplsLdpAtmStdMIB=mplsLdpAtmStdMIB, mplsLdpEntityAtmLREntry=mplsLdpEntityAtmLREntry, mplsLdpEntityAtmLsrConnectivity=mplsLdpEntityAtmLsrConnectivity, mplsLdpEntityAtmLRRowStatus=mplsLdpEntityAtmLRRowStatus, mplsLdpAtmModuleFullCompliance=mplsLdpAtmModuleFullCompliance, mplsLdpEntityAtmMergeCap=mplsLdpEntityAtmMergeCap, mplsLdpAtmConformance=mplsLdpAtmConformance, mplsLdpEntityAtmUnlabTrafVpi=mplsLdpEntityAtmUnlabTrafVpi, mplsLdpAtmObjects=mplsLdpAtmObjects, mplsLdpEntityAtmDefaultControlVci=mplsLdpEntityAtmDefaultControlVci, mplsLdpEntityAtmRowStatus=mplsLdpEntityAtmRowStatus, mplsLdpAtmSessionObjects=mplsLdpAtmSessionObjects, mplsLdpAtmGroup=mplsLdpAtmGroup, mplsLdpEntityAtmObjects=mplsLdpEntityAtmObjects, mplsLdpEntityAtmLRMaxVpi=mplsLdpEntityAtmLRMaxVpi, mplsLdpEntityAtmUnlabTrafVci=mplsLdpEntityAtmUnlabTrafVci, mplsLdpEntityAtmLRMinVpi=mplsLdpEntityAtmLRMinVpi, mplsLdpSessionAtmLRLowerBoundVci=mplsLdpSessionAtmLRLowerBoundVci, mplsLdpAtmSessionTable=mplsLdpAtmSessionTable, mplsLdpEntityAtmDefaultControlVpi=mplsLdpEntityAtmDefaultControlVpi, mplsLdpEntityAtmLRComponents=mplsLdpEntityAtmLRComponents, mplsLdpAtmSessionEntry=mplsLdpAtmSessionEntry, mplsLdpSessionAtmLRUpperBoundVci=mplsLdpSessionAtmLRUpperBoundVci, mplsLdpEntityAtmLRMaxVci=mplsLdpEntityAtmLRMaxVci, mplsLdpEntityAtmTable=mplsLdpEntityAtmTable, mplsLdpAtmCompliances=mplsLdpAtmCompliances, mplsLdpEntityAtmEntry=mplsLdpEntityAtmEntry, mplsLdpEntityAtmStorageType=mplsLdpEntityAtmStorageType, mplsLdpEntityAtmVcDirectionality=mplsLdpEntityAtmVcDirectionality, mplsLdpSessionAtmLRUpperBoundVpi=mplsLdpSessionAtmLRUpperBoundVpi, mplsLdpAtmModuleReadOnlyCompliance=mplsLdpAtmModuleReadOnlyCompliance)
