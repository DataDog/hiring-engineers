#
# PySNMP MIB module GMPLS-TE-STD-MIB (http://pysnmp.sf.net)
# ASN.1 source http://mibs.snmplabs.com:80/asn1/GMPLS-TE-STD-MIB
# Produced by pysmi-0.0.7 at Sun Feb 14 00:14:16 2016
# On host bldfarm platform Linux version 4.1.13-100.fc21.x86_64 by user goose
# Using Python version 3.5.0 (default, Jan  5 2016, 17:11:52) 
#
( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
( IANAGmplsGeneralizedPidTC, IANAGmplsLSPEncodingTypeTC, IANAGmplsAdminStatusInformationTC, IANAGmplsSwitchingTypeTC, ) = mibBuilder.importSymbols("IANA-GMPLS-TC-MIB", "IANAGmplsGeneralizedPidTC", "IANAGmplsLSPEncodingTypeTC", "IANAGmplsAdminStatusInformationTC", "IANAGmplsSwitchingTypeTC")
( InetAddress, InetAddressType, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
( mplsStdMIB, ) = mibBuilder.importSymbols("MPLS-TC-STD-MIB", "mplsStdMIB")
( mplsTunnelScalarGroup, mplsTunnelCHopIndex, mplsTunnelInstance, mplsTunnelCHopListIndex, mplsTunnelEntry, mplsTunnelGroup, mplsTunnelIndex, mplsTunnelIngressLSRId, mplsTunnelARHopIndex, mplsTunnelEgressLSRId, mplsTunnelHopListIndex, mplsTunnelOperStatus, mplsTunnelHopIndex, mplsTunnelHopPathOptionIndex, mplsTunnelARHopListIndex, mplsTunnelAdminStatus, ) = mibBuilder.importSymbols("MPLS-TE-STD-MIB", "mplsTunnelScalarGroup", "mplsTunnelCHopIndex", "mplsTunnelInstance", "mplsTunnelCHopListIndex", "mplsTunnelEntry", "mplsTunnelGroup", "mplsTunnelIndex", "mplsTunnelIngressLSRId", "mplsTunnelARHopIndex", "mplsTunnelEgressLSRId", "mplsTunnelHopListIndex", "mplsTunnelOperStatus", "mplsTunnelHopIndex", "mplsTunnelHopPathOptionIndex", "mplsTunnelARHopListIndex", "mplsTunnelAdminStatus")
( SnmpAdminString, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
( ObjectGroup, ModuleCompliance, NotificationGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
( ModuleIdentity, Bits, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, zeroDotZero, TimeTicks, Integer32, ObjectIdentity, iso, Unsigned32, Counter64, NotificationType, Counter32, IpAddress, ) = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "Bits", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "zeroDotZero", "TimeTicks", "Integer32", "ObjectIdentity", "iso", "Unsigned32", "Counter64", "NotificationType", "Counter32", "IpAddress")
( RowPointer, TimeStamp, TruthValue, TextualConvention, DisplayString, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowPointer", "TimeStamp", "TruthValue", "TextualConvention", "DisplayString")
gmplsTeStdMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 10, 166, 13)).setRevisions(("2007-02-27 00:00",))
if mibBuilder.loadTexts: gmplsTeStdMIB.setLastUpdated('200702270000Z')
if mibBuilder.loadTexts: gmplsTeStdMIB.setOrganization('IETF Common Control and Measurement Plane (CCAMP) Working\n         Group')
if mibBuilder.loadTexts: gmplsTeStdMIB.setContactInfo('       Thomas D. Nadeau\n                Cisco Systems, Inc.\n         Email: tnadeau@cisco.com\n                Adrian Farrel\n                Old Dog Consulting\n         Email: adrian@olddog.co.uk\n\n         Comments about this document should be emailed directly\n         to the CCAMP working group mailing list at\n         ccamp@ops.ietf.org.')
if mibBuilder.loadTexts: gmplsTeStdMIB.setDescription('Copyright (C) The IETF Trust (2007).  This version of\n         this MIB module is part of RFC 4802; see the RFC itself for\n         full legal notices.\n\n         This MIB module contains managed object definitions\n         for GMPLS Traffic Engineering (TE) as defined in:\n         1. Generalized Multi-Protocol Label Switching (GMPLS)\n            Signaling Functional Description, Berger, L. (Editor),\n            RFC 3471, January 2003.\n         2. Generalized MPLS Signaling - RSVP-TE Extensions, Berger,\n            L. (Editor), RFC 3473, January 2003.\n         ')
gmplsTeNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 13, 0))
gmplsTeScalars = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 13, 1))
gmplsTeObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 13, 2))
gmplsTeConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 13, 3))
gmplsTunnelsConfigured = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 13, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelsConfigured.setDescription('The number of GMPLS tunnels configured on this device.  A GMPLS\n     tunnel is considered configured if an entry for the tunnel\n     exists in the gmplsTunnelTable and the associated\n     mplsTunnelRowStatus is active(1).')
gmplsTunnelsActive = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 13, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelsActive.setDescription('The number of GMPLS tunnels active on this device.  A GMPLS\n     tunnel is considered active if there is an entry in the\n     gmplsTunnelTable and the associated mplsTunnelOperStatus for the\n     tunnel is up(1).')
gmplsTunnelTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1), )
if mibBuilder.loadTexts: gmplsTunnelTable.setDescription('The gmplsTunnelTable sparsely extends the mplsTunnelTable of\n     MPLS-TE-STD-MIB.  It allows GMPLS tunnels to be created between\n     an LSR and a remote endpoint, and existing tunnels to be\n     reconfigured or removed.\n\n     Note that only point-to-point tunnel segments are supported,\n     although multipoint-to-point and point-to-multipoint\n     connections are supported by an LSR acting as a cross-connect.\n     Each tunnel can thus have one out-segment originating at this\n     LSR and/or one in-segment terminating at this LSR.\n\n     The row status of an entry in this table is controlled by the\n     mplsTunnelRowStatus in the corresponding entry in the\n     mplsTunnelTable.  When the corresponding mplsTunnelRowStatus has\n     value active(1), a row in this table may not be created or\n     modified.\n\n     The exception to this rule is the\n     gmplsTunnelAdminStatusInformation object, which can be modified\n     while the tunnel is active.')
gmplsTunnelEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1), ).setIndexNames((0, "MPLS-TE-STD-MIB", "mplsTunnelIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelInstance"), (0, "MPLS-TE-STD-MIB", "mplsTunnelIngressLSRId"), (0, "MPLS-TE-STD-MIB", "mplsTunnelEgressLSRId"))
if mibBuilder.loadTexts: gmplsTunnelEntry.setDescription('An entry in this table in association with the corresponding\n     entry in the mplsTunnelTable represents a GMPLS tunnel.\n\n     An entry can be created by a network administrator via SNMP SET\n     commands, or in response to signaling protocol events.')
gmplsTunnelUnnumIf = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 1), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelUnnumIf.setDescription("Denotes whether or not this tunnel corresponds to an unnumbered\n     interface represented by an entry in the interfaces group table\n     (the ifTable) with ifType set to mpls(166).\n     This object is only used if mplsTunnelIsIf is set to 'true'.\n\n     If both this object and the mplsTunnelIsIf object are set to\n     'true', the originating LSR adds an LSP_TUNNEL_INTERFACE_ID\n     object to the outgoing Path message.\n\n     This object contains information that is only used by the\n     terminating LSR.")
gmplsTunnelAttributes = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 2), Bits().clone(namedValues=NamedValues(("labelRecordingDesired", 0),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelAttributes.setDescription('This bitmask indicates optional parameters for this tunnel.\n     These bits should be taken in addition to those defined in\n     mplsTunnelSessionAttributes in order to determine the full set\n     of options to be signaled (for example SESSION_ATTRIBUTES flags\n     in RSVP-TE).  The following describes these bitfields:\n\n     labelRecordingDesired\n       This flag is set to indicate that label information should be\n       included when doing a route record.  This bit is not valid\n       unless the recordRoute bit is set.')
gmplsTunnelLSPEncoding = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 3), IANAGmplsLSPEncodingTypeTC().clone('tunnelLspNotGmpls')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelLSPEncoding.setDescription("This object indicates the encoding of the LSP being requested.\n\n     A value of 'tunnelLspNotGmpls' indicates that GMPLS signaling is\n     not in use.  Some objects in this MIB module may be of use for\n     MPLS signaling extensions that do not use GMPLS signaling.  By\n     setting this object to 'tunnelLspNotGmpls', an application may\n     indicate that only those objects meaningful in MPLS should be\n     examined.\n\n     The values to use are defined in the TEXTUAL-CONVENTION\n     IANAGmplsLSPEncodingTypeTC found in the IANA-GMPLS-TC-MIB\n     module.")
gmplsTunnelSwitchingType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 4), IANAGmplsSwitchingTypeTC().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelSwitchingType.setDescription("Indicates the type of switching that should be performed on\n     a particular link.  This field is needed for links that\n     advertise more than one type of switching capability.\n\n     The values to use are defined in the TEXTUAL-CONVENTION\n     IANAGmplsSwitchingTypeTC found in the IANA-GMPLS-TC-MIB module.\n\n     This object is only meaningful if gmplsTunnelLSPEncodingType\n     is not set to 'tunnelLspNotGmpls'.")
gmplsTunnelLinkProtection = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 5), Bits().clone(namedValues=NamedValues(("extraTraffic", 0), ("unprotected", 1), ("shared", 2), ("dedicatedOneToOne", 3), ("dedicatedOnePlusOne", 4), ("enhanced", 5),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelLinkProtection.setDescription("This bitmask indicates the level of link protection required.  A\n     value of zero (no bits set) indicates that any protection may be\n     used.  The following describes these bitfields:\n\n     extraTraffic\n       This flag is set to indicate that the LSP should use links\n       that are protecting other (primary) traffic.  Such LSPs may be\n       preempted when the links carrying the (primary) traffic being\n       protected fail.\n\n     unprotected\n       This flag is set to indicate that the LSP should not use any\n       link layer protection.\n\n     shared\n       This flag is set to indicate that a shared link layer\n       protection scheme, such as 1:N protection, should be used to\n       support the LSP.\n\n     dedicatedOneToOne\n       This flag is set to indicate that a dedicated link layer\n       protection scheme, i.e., 1:1 protection, should be used to\n       support the LSP.\n\n     dedicatedOnePlusOne\n       This flag is set to indicate that a dedicated link layer\n       protection scheme, i.e., 1+1 protection, should be used to\n       support the LSP.\n\n     enhanced\n       This flag is set to indicate that a protection scheme that is\n       more reliable than Dedicated 1+1 should be used, e.g., 4 fiber\n       BLSR/MS-SPRING.\n\n     This object is only meaningful if gmplsTunnelLSPEncoding is\n     not set to 'tunnelLspNotGmpls'.")
gmplsTunnelGPid = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 6), IANAGmplsGeneralizedPidTC().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelGPid.setDescription("This object indicates the payload carried by the LSP.  It is only\n     required when GMPLS will be used for this LSP.\n\n     The values to use are defined in the TEXTUAL-CONVENTION\n     IANAGmplsGeneralizedPidTC found in the IANA-GMPLS-TC-MIB module.\n\n     This object is only meaningful if gmplsTunnelLSPEncoding is not\n     set to 'tunnelLspNotGmpls'.")
gmplsTunnelSecondary = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 7), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelSecondary.setDescription("Indicates that the requested LSP is a secondary LSP.\n\n     This object is only meaningful if gmplsTunnelLSPEncoding is not\n     set to 'tunnelLspNotGmpls'.")
gmplsTunnelDirection = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1,))).clone(namedValues=NamedValues(("forward", 0), ("bidirectional", 1),)).clone('forward')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelDirection.setDescription("Whether this tunnel carries forward data only (is\n     unidirectional) or is bidirectional.\n\n     Values of this object other than 'forward' are meaningful\n     only if gmplsTunnelLSPEncoding is not set to\n     'tunnelLspNotGmpls'.")
gmplsTunnelPathComp = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("dynamicFull", 1), ("explicit", 2), ("dynamicPartial", 3),)).clone('dynamicFull')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelPathComp.setDescription("This value instructs the source node on how to perform path\n     computation on the explicit route specified by the associated\n     entries in the gmplsTunnelHopTable.\n\n     dynamicFull\n       The user specifies at least the source and\n       destination of the path and expects that the Constrained\n       Shortest Path First (CSPF) will calculate the remainder\n       of the path.\n\n     explicit\n       The user specifies the entire path for the tunnel to\n       take.  This path may contain strict or loose hops.\n       Evaluation of the explicit route will be performed\n       hop by hop through the network.\n\n     dynamicPartial\n       The user specifies at least the source and\n       destination of the path and expects that the CSPF\n       will calculate the remainder of the path.  The path\n       computed by CSPF is allowed to be only partially\n       computed allowing the remainder of the path to be\n       filled in across the network.\n\n     When an entry is present in the gmplsTunnelTable for a\n     tunnel, gmplsTunnelPathComp MUST be used and any\n     corresponding mplsTunnelHopEntryPathComp object in the\n     mplsTunnelHopTable MUST be ignored and SHOULD not be set.\n\n     mplsTunnelHopTable and mplsTunnelHopEntryPathComp are part of\n     MPLS-TE-STD-MIB.\n\n     This object should be ignored if the value of\n     gmplsTunnelLSPEncoding is 'tunnelLspNotGmpls'.")
gmplsTunnelUpstreamNotifyRecipientType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 10), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelUpstreamNotifyRecipientType.setDescription('This object is used to aid in interpretation of\n    gmplsTunnelUpstreamNotifyRecipient.')
gmplsTunnelUpstreamNotifyRecipient = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 11), InetAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelUpstreamNotifyRecipient.setDescription('Indicates the address of the upstream recipient for Notify\n     messages relating to this tunnel and issued by this LSR.  This\n     information is typically received from an upstream LSR in a Path\n     message.\n\n     This object is only valid when signaling a tunnel using RSVP.\n\n     It is also not valid at the head end of a tunnel since there are\n     no upstream LSRs to which to send a Notify message.\n\n     This object is interpreted in the context of the value of\n     gmplsTunnelUpstreamNotifyRecipientType. If this object is set to\n     0, the value of gmplsTunnelUpstreamNotifyRecipientType MUST be\n     set to unknown(0).')
gmplsTunnelSendResvNotifyRecipientType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 12), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelSendResvNotifyRecipientType.setDescription('This object is used to aid in interpretation of\n    gmplsTunnelSendResvNotifyRecipient.')
gmplsTunnelSendResvNotifyRecipient = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 13), InetAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelSendResvNotifyRecipient.setDescription('Indicates to an upstream LSR the address to which it should send\n     downstream Notify messages relating to this tunnel.\n\n     This object is only valid when signaling a tunnel using RSVP.\n\n     It is also not valid at the head end of the tunnel since no Resv\n     messages are sent from that LSR for this tunnel.\n\n     If set to 0, no Notify Request object will be included in the\n     outgoing Resv messages.\n\n     This object is interpreted in the context of the value of\n     gmplsTunnelSendResvNotifyRecipientType. If this object is set to\n     0, the value of gmplsTunnelSendResvNotifyRecipientType MUST be\n     set to unknown(0).')
gmplsTunnelDownstreamNotifyRecipientType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 14), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelDownstreamNotifyRecipientType.setDescription('This object is used to aid in interpretation of\n    gmplsTunnelDownstreamNotifyRecipient.')
gmplsTunnelDownstreamNotifyRecipient = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 15), InetAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelDownstreamNotifyRecipient.setDescription('Indicates the address of the downstream recipient for Notify\n     messages relating to this tunnel and issued by this LSR.  This\n     information is typically received from an upstream LSR in a Resv\n     message.  This object is only valid when signaling a tunnel using\n     RSVP.\n\n     It is also not valid at the tail end of a tunnel since there are\n     no downstream LSRs to which to send a Notify message.\n\n     This object is interpreted in the context of the value of\n     gmplsTunnelDownstreamNotifyRecipientType. If this object is set\n     to 0, the value of gmplsTunnelDownstreamNotifyRecipientType MUST\n     be set to unknown(0).')
gmplsTunnelSendPathNotifyRecipientType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 16), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelSendPathNotifyRecipientType.setDescription('This object is used to aid in interpretation of\n    gmplsTunnelSendPathNotifyRecipient.')
gmplsTunnelSendPathNotifyRecipient = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 17), InetAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelSendPathNotifyRecipient.setDescription('Indicates to a downstream LSR the address to which it should\n     send upstream Notify messages relating to this tunnel.\n\n     This object is only valid when signaling a tunnel using RSVP.\n\n     It is also not valid at the tail end of the tunnel since no Path\n     messages are sent from that LSR for this tunnel.\n\n     If set to 0, no Notify Request object will be included in the\n     outgoing Path messages.\n\n     This object is interpreted in the context of the value of\n     gmplsTunnelSendPathNotifyRecipientType.  If this object is set to\n     0, the value of gmplsTunnelSendPathNotifyRecipientType MUST be\n     set to unknown(0).')
gmplsTunnelAdminStatusFlags = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 18), IANAGmplsAdminStatusInformationTC()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelAdminStatusFlags.setDescription('Determines the setting of the Admin Status flags in the\n      Admin Status object or TLV, as described in RFC 3471.  Setting\n      this field to a non-zero value will result in the inclusion of\n      the Admin Status object on signaling messages.\n\n      The values to use are defined in the TEXTUAL-CONVENTION\n      IANAGmplsAdminStatusInformationTC found in the\n      IANA-GMPLS-TC-MIB module.\n\n      This value of this object can be modified when the\n      corresponding mplsTunnelRowStatus and mplsTunnelAdminStatus\n      is active(1).  By doing so, a new signaling message will be\n      triggered including the requested Admin Status object or\n      TLV.')
gmplsTunnelExtraParamsPtr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 1, 1, 19), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelExtraParamsPtr.setDescription('Some tunnels will run over transports that can usefully support\n     technology-specific additional parameters (for example,\n     Synchronous Optical Network (SONET) resource usage).  Such\n     parameters can be supplied in an external table and referenced\n     from here.\n\n     A value of zeroDotzero in this attribute indicates that there\n     is no such additional information.')
gmplsTunnelHopTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 2), )
if mibBuilder.loadTexts: gmplsTunnelHopTable.setDescription('The gmplsTunnelHopTable sparsely extends the mplsTunnelHopTable\n     of MPLS-TE-STD-MIB.  It is used to indicate the Explicit Labels\n     to be used in an explicit path for a GMPLS tunnel defined in the\n     mplsTunnelTable and gmplsTunnelTable, when it is established\n     using signaling.  It does not insert new hops, but does define\n     new values for hops defined in the mplsTunnelHopTable.\n\n     Each row in this table is indexed by the same indexes as in the\n     mplsTunnelHopTable.  It is acceptable for some rows in the\n     mplsTunnelHopTable to have corresponding entries in this table\n     and some to have no corresponding entry in this table.\n\n     The storage type for this entry is given by the value\n     of mplsTunnelHopStorageType in the corresponding entry in the\n     mplsTunnelHopTable.\n\n     The row status of an entry in this table is controlled by\n     mplsTunnelHopRowStatus in the corresponding entry in the\n     mplsTunnelHopTable.  That is, it is not permitted to create a row\n     in this table, or to modify an existing row, when the\n     corresponding mplsTunnelHopRowStatus has the value active(1).')
gmplsTunnelHopEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 2, 1), ).setIndexNames((0, "MPLS-TE-STD-MIB", "mplsTunnelHopListIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelHopPathOptionIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelHopIndex"))
if mibBuilder.loadTexts: gmplsTunnelHopEntry.setDescription('An entry in this table represents additions to a tunnel hop\n     defined in mplsTunnelHopEntry.  At an ingress to a tunnel, an\n     entry in this table is created by a network administrator for an\n     ERLSP to be set up by a signaling protocol.  At transit and\n     egress nodes, an entry in this table may be used to represent the\n     explicit path instructions received using the signaling\n     protocol.')
gmplsTunnelHopLabelStatuses = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 2, 1, 1), Bits().clone(namedValues=NamedValues(("forwardPresent", 0), ("reversePresent", 1),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelHopLabelStatuses.setDescription('This bitmask indicates the presence of labels indicated by the\n     gmplsTunnelHopExplicitForwardLabel or\n     gmplsTunnelHopExplicitForwardLabelPtr, and\n     gmplsTunnelHopExplicitReverseLabel or\n     gmplsTunnelHopExplicitReverseLabelPtr objects.\n\n     For the Present bits, a set bit indicates that a label is\n     present for this hop in the route.  This allows zero to be a\n     valid label value.')
gmplsTunnelHopExplicitForwardLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 2, 1, 2), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelHopExplicitForwardLabel.setDescription('If gmplsTunnelHopLabelStatuses object indicates that a Forward\n     Label is present and gmplsTunnelHopExplicitForwardLabelPtr\n     contains the value zeroDotZero, then the label to use on this\n     hop is represented by the value of this object.')
gmplsTunnelHopExplicitForwardLabelPtr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 2, 1, 3), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelHopExplicitForwardLabelPtr.setDescription('If the gmplsTunnelHopLabelStatuses object indicates that a\n     Forward Label is present, this object contains a pointer to a\n     row in another MIB table (such as the gmplsLabelTable of\n     GMPLS-LABEL-STD-MIB) that contains the label to use on this hop\n     in the forward direction.\n\n     If the gmplsTunnelHopLabelStatuses object indicates that a\n     Forward Label is present and this object contains the value\n     zeroDotZero, then the label to use on this hop is found in the\n     gmplsTunnelHopExplicitForwardLabel object.')
gmplsTunnelHopExplicitReverseLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 2, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelHopExplicitReverseLabel.setDescription('If the gmplsTunnelHopLabelStatuses object indicates that a\n     Reverse Label is present and\n     gmplsTunnelHopExplicitReverseLabelPtr contains the value\n     zeroDotZero, then the label to use on this hop is found in\n     this object encoded as a 32-bit integer.')
gmplsTunnelHopExplicitReverseLabelPtr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 2, 1, 5), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gmplsTunnelHopExplicitReverseLabelPtr.setDescription('If the gmplsTunnelHopLabelStatuses object indicates that a\n     Reverse Label is present, this object contains a pointer to a\n     row in another MIB table (such as the gmplsLabelTable of\n     GMPLS-LABEL-STD-MIB) that contains the label to use on this hop\n     in the reverse direction.\n\n     If the gmplsTunnelHopLabelStatuses object indicates that a\n     Reverse Label is present and this object contains the value\n     zeroDotZero, then the label to use on this hop is found in the\n     gmplsTunnelHopExplicitReverseLabel object.')
gmplsTunnelARHopTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 3), )
if mibBuilder.loadTexts: gmplsTunnelARHopTable.setDescription('The gmplsTunnelARHopTable sparsely extends the\n     mplsTunnelARHopTable of MPLS-TE-STD-MIB.  It is used to\n     indicate the labels currently in use for a GMPLS tunnel\n     defined in the mplsTunnelTable and gmplsTunnelTable, as\n     reported by the signaling protocol.  It does not insert\n     new hops, but does define new values for hops defined in\n     the mplsTunnelARHopTable.\n\n     Each row in this table is indexed by the same indexes as in the\n     mplsTunnelARHopTable.  It is acceptable for some rows in the\n     mplsTunnelARHopTable to have corresponding entries in this table\n     and some to have no corresponding entry in this table.\n\n     Note that since the information necessary to build entries\n     within this table is not provided by some signaling protocols\n     and might not be returned in all cases of other signaling\n     protocols, implementation of this table and the\n     mplsTunnelARHopTable is optional.  Furthermore, since the\n     information in this table is actually provided by the\n     signaling protocol after the path has been set up, the entries\n     in this table are provided only for observation, and hence,\n     all variables in this table are accessible exclusively as\n     read-only.')
gmplsTunnelARHopEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 3, 1), ).setIndexNames((0, "MPLS-TE-STD-MIB", "mplsTunnelARHopListIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelARHopIndex"))
if mibBuilder.loadTexts: gmplsTunnelARHopEntry.setDescription('An entry in this table represents additions to a tunnel hop\n     visible in mplsTunnelARHopEntry.  An entry is created by the\n     signaling protocol for a signaled ERLSP set up by the signaling\n     protocol.\n\n     At any node on the LSP (ingress, transit, or egress), this table\n     and the mplsTunnelARHopTable (if the tables are supported and if\n     the signaling protocol is recording actual route information)\n     contain the actual route of the whole tunnel.  If the signaling\n     protocol is not recording the actual route, this table MAY\n     report the information from the gmplsTunnelHopTable or the\n     gmplsTunnelCHopTable.\n\n     Note that the recording of actual labels is distinct from the\n     recording of the actual route in some signaling protocols.  This\n     feature is enabled using the gmplsTunnelAttributes object.')
gmplsTunnelARHopLabelStatuses = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 3, 1, 1), Bits().clone(namedValues=NamedValues(("forwardPresent", 0), ("reversePresent", 1), ("forwardGlobal", 2), ("reverseGlobal", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelARHopLabelStatuses.setDescription('This bitmask indicates the presence and status of labels\n     indicated by the gmplsTunnelARHopExplicitForwardLabel or\n     gmplsTunnelARHopExplicitForwardLabelPtr, and\n     gmplsTunnelARHopExplicitReverseLabel or\n     gmplsTunnelARHopExplicitReverseLabelPtr objects.\n\n     For the Present bits, a set bit indicates that a label is\n     present for this hop in the route.\n\n     For the Global bits, a set bit indicates that the label comes\n     from the Global Label Space; a clear bit indicates that this is\n     a Per-Interface label.  A Global bit only has meaning if the\n     corresponding Present bit is set.')
gmplsTunnelARHopExplicitForwardLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 3, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelARHopExplicitForwardLabel.setDescription('If the gmplsTunnelARHopLabelStatuses object indicates that a\n     Forward Label is present and\n     gmplsTunnelARHopExplicitForwardLabelPtr contains the value\n     zeroDotZero, then the label in use on this hop is found in this\n     object encoded as a 32-bit integer.')
gmplsTunnelARHopExplicitForwardLabelPtr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 3, 1, 3), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelARHopExplicitForwardLabelPtr.setDescription('If the gmplsTunnelARHopLabelStatuses object indicates that a\n     Forward Label is present, this object contains a pointer to a\n     row in another MIB table (such as the gmplsLabelTable of\n     GMPLS-LABEL-STD-MIB) that contains the label in use on this hop\n     in the forward direction.\n\n     If the gmplsTunnelARHopLabelStatuses object indicates that a\n     Forward Label is present and this object contains the value\n     zeroDotZero, then the label in use on this hop is found in the\n     gmplsTunnelARHopExplicitForwardLabel object.')
gmplsTunnelARHopExplicitReverseLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 3, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelARHopExplicitReverseLabel.setDescription('If the gmplsTunnelARHopLabelStatuses object indicates that a\n     Reverse Label is present and\n     gmplsTunnelARHopExplicitReverseLabelPtr contains the value\n     zeroDotZero, then the label in use on this hop is found in this\n     object encoded as a 32-bit integer.')
gmplsTunnelARHopExplicitReverseLabelPtr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 3, 1, 5), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelARHopExplicitReverseLabelPtr.setDescription('If the gmplsTunnelARHopLabelStatuses object indicates that a\n     Reverse Label is present, this object contains a pointer to a\n     row in another MIB table (such as the gmplsLabelTable of\n     GMPLS-LABEL-STD-MIB) that contains the label in use on this hop\n     in the reverse direction.\n\n     If the gmplsTunnelARHopLabelStatuses object indicates that a\n     Reverse Label is present and this object contains the value\n     zeroDotZero, then the label in use on this hop is found in the\n     gmplsTunnelARHopExplicitReverseLabel object.')
gmplsTunnelARHopProtection = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 3, 1, 6), Bits().clone(namedValues=NamedValues(("localAvailable", 0), ("localInUse", 1),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelARHopProtection.setDescription('Availability and usage of protection on the reported link.\n\n     localAvailable\n       This flag is set to indicate that the link downstream of this\n       node is protected via a local repair mechanism.\n\n     localInUse\n       This flag is set to indicate that a local repair mechanism is\n       in use to maintain this tunnel (usually in the face of an\n       outage of the link it was previously routed over).')
gmplsTunnelCHopTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 4), )
if mibBuilder.loadTexts: gmplsTunnelCHopTable.setDescription('The gmplsTunnelCHopTable sparsely extends the\n     mplsTunnelCHopTable of MPLS-TE-STD-MIB.  It is used to indicate\n     additional information about the hops of a GMPLS tunnel defined\n     in the mplsTunnelTable and gmplsTunnelTable, as computed by a\n     constraint-based routing protocol, based on the\n     mplsTunnelHopTable and the gmplsTunnelHopTable.\n\n     Each row in this table is indexed by the same indexes as in the\n     mplsTunnelCHopTable.  It is acceptable for some rows in the\n     mplsTunnelCHopTable to have corresponding entries in this table\n     and some to have no corresponding entry in this table.\n\n     Please note that since the information necessary to build\n     entries within this table may not be supported by some LSRs,\n     implementation of this table is optional.\n\n     Furthermore, since the information in this table is actually\n     provided by a path computation component after the path has been\n     computed, the entries in this table are provided only for\n     observation, and hence, all objects in this table are accessible\n     exclusively as read-only.')
gmplsTunnelCHopEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 4, 1), ).setIndexNames((0, "MPLS-TE-STD-MIB", "mplsTunnelCHopListIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelCHopIndex"))
if mibBuilder.loadTexts: gmplsTunnelCHopEntry.setDescription('An entry in this table represents additions to a computed tunnel\n     hop visible in mplsTunnelCHopEntry.  An entry is created by a\n     path computation component based on the hops specified in the\n     corresponding mplsTunnelHopTable and gmplsTunnelHopTable.\n\n     At a transit LSR, this table (if the table is supported) MAY\n     contain the path computed by a path computation engine on (or on\n     behalf of) the transit LSR.')
gmplsTunnelCHopLabelStatuses = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 4, 1, 1), Bits().clone(namedValues=NamedValues(("forwardPresent", 0), ("reversePresent", 1),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelCHopLabelStatuses.setDescription('This bitmask indicates the presence of labels indicated by the\n     gmplsTunnelCHopExplicitForwardLabel or\n     gmplsTunnelCHopExplicitForwardLabelPtr and\n     gmplsTunnelCHopExplicitReverseLabel or\n     gmplsTunnelCHopExplicitReverseLabelPtr objects.\n\n     A set bit indicates that a label is present for this hop in the\n     route, thus allowing zero to be a valid label value.')
gmplsTunnelCHopExplicitForwardLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 4, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelCHopExplicitForwardLabel.setDescription('If the gmplsTunnelCHopLabelStatuses object indicates that a\n     Forward Label is present and\n     gmplsTunnelCHopExplicitForwardLabelPtr contains the value\n     zeroDotZero, then the label to use on this hop is found in this\n     object encoded as a 32-bit integer.')
gmplsTunnelCHopExplicitForwardLabelPtr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 4, 1, 3), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelCHopExplicitForwardLabelPtr.setDescription('If the gmplsTunnelCHopLabelStatuses object indicates that a\n     Forward Label is present, this object contains a pointer to a\n     row in another MIB table (such as the gmplsLabelTable of\n     GMPLS-LABEL-STD-MIB) that contains the label to use on this hop\n     in the forward direction.\n\n     If the gmplsTunnelCHopLabelStatuses object indicates that a\n     Forward Label is present and this object contains the value\n     zeroDotZero, then the label to use on this hop is found in the\n     gmplsTunnelCHopExplicitForwardLabel object.')
gmplsTunnelCHopExplicitReverseLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 4, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelCHopExplicitReverseLabel.setDescription('If the gmplsTunnelCHopLabelStatuses object indicates that a\n     Reverse Label is present and\n     gmplsTunnelCHopExplicitReverseLabelPtr contains the value\n     zeroDotZero, then the label to use on this hop is found in this\n     object encoded as a 32-bit integer.')
gmplsTunnelCHopExplicitReverseLabelPtr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 4, 1, 5), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelCHopExplicitReverseLabelPtr.setDescription('If the gmplsTunnelCHopLabelStatuses object indicates that a\n     Reverse Label is present, this object contains a pointer to a\n     row in another MIB table (such as the gmplsLabelTable of\n     GMPLS-LABEL-STD-MIB) that contains the label to use on this hop\n     in the reverse direction.\n\n     If the gmplsTunnelCHopLabelStatuses object indicates that a\n     Reverse Label is present and this object contains the value\n     zeroDotZero, then the label to use on this hop is found in the\n     gmplsTunnelCHopExplicitReverseLabel object.')
gmplsTunnelReversePerfTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 5), )
if mibBuilder.loadTexts: gmplsTunnelReversePerfTable.setDescription('This table augments the gmplsTunnelTable to provide\n     per-tunnel packet performance information for the reverse\n     direction of a bidirectional tunnel.  It can be seen as\n     supplementing the mplsTunnelPerfTable, which augments the\n     mplsTunnelTable.\n\n     For links that do not transport packets, these packet counters\n     cannot be maintained.  For such links, attempts to read the\n     objects in this table will return noSuchInstance.\n\n     A tunnel can be known to be bidirectional by inspecting the\n     gmplsTunnelDirection object.')
gmplsTunnelReversePerfEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 5, 1), )
gmplsTunnelEntry.registerAugmentions(("GMPLS-TE-STD-MIB", "gmplsTunnelReversePerfEntry"))
gmplsTunnelReversePerfEntry.setIndexNames(*gmplsTunnelEntry.getIndexNames())
if mibBuilder.loadTexts: gmplsTunnelReversePerfEntry.setDescription('An entry in this table is created by the LSR for every\n     bidirectional GMPLS tunnel where packets are visible to the\n     LSR.')
gmplsTunnelReversePerfPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelReversePerfPackets.setDescription('Number of packets forwarded on the tunnel in the reverse\n     direction if it is bidirectional.\n\n     This object represents the 32-bit value of the least\n     significant part of the 64-bit value if both\n     gmplsTunnelReversePerfHCPackets and this object are returned.\n     For links that do not transport packets, this packet counter\n     cannot be maintained.  For such links, this value will return\n     noSuchInstance.')
gmplsTunnelReversePerfHCPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 5, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelReversePerfHCPackets.setDescription('High-capacity counter for number of packets forwarded on the\n     tunnel in the reverse direction if it is bidirectional.\n\n     For links that do not transport packets, this packet counter\n     cannot be maintained.  For such links, this value will return\n     noSuchInstance.')
gmplsTunnelReversePerfErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelReversePerfErrors.setDescription('Number of errored packets received on the tunnel in the reverse\n     direction if it is bidirectional.  For links that do not\n     transport packets, this packet counter cannot be maintained.  For\n     such links, this value will return noSuchInstance.')
gmplsTunnelReversePerfBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelReversePerfBytes.setDescription('Number of bytes forwarded on the tunnel in the reverse direction\n     if it is bidirectional.\n\n     This object represents the 32-bit value of the least\n     significant part of the 64-bit value if both\n     gmplsTunnelReversePerfHCBytes and this object are returned.\n\n     For links that do not transport packets, this packet counter\n     cannot be maintained.  For such links, this value will return\n     noSuchInstance.')
gmplsTunnelReversePerfHCBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 5, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelReversePerfHCBytes.setDescription('High-capacity counter for number of bytes forwarded on the\n     tunnel in the reverse direction if it is bidirectional.\n\n     For links that do not transport packets, this packet counter\n     cannot be maintained.  For such links, this value will return\n     noSuchInstance.')
gmplsTunnelErrorTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 6), )
if mibBuilder.loadTexts: gmplsTunnelErrorTable.setDescription('This table augments the mplsTunnelTable.\n\n     This table provides per-tunnel information about errors.  Errors\n     may be detected locally or reported through the signaling\n     protocol.  Error reporting is not exclusive to GMPLS, and this\n     table may be applied in MPLS systems.\n\n     Entries in this table are not persistent over system resets\n     or re-initializations of the management system.')
gmplsTunnelErrorEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 6, 1), )
mplsTunnelEntry.registerAugmentions(("GMPLS-TE-STD-MIB", "gmplsTunnelErrorEntry"))
gmplsTunnelErrorEntry.setIndexNames(*mplsTunnelEntry.getIndexNames())
if mibBuilder.loadTexts: gmplsTunnelErrorEntry.setDescription('An entry in this table is created by the LSR for every tunnel\n     where error information is visible to the LSR.\n\n     Note that systems that read the objects in this table one at\n     a time and do not perform atomic operations to read entire\n     instantiated table rows at once, should, for each conceptual\n     column with valid data, read gmplsTunnelErrorLastTime\n     prior to the other objects in the row and again subsequent to\n     reading the last object of the row.  They should verify that\n     the value of gmplsTunnelErrorLastTime did not change and\n     thereby ensure that all data read belongs to the same error\n     event.')
gmplsTunnelErrorLastErrorType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6,))).clone(namedValues=NamedValues(("noError", 0), ("unknown", 1), ("protocol", 2), ("pathComputation", 3), ("localConfiguration", 4), ("localResources", 5), ("localOther", 6),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelErrorLastErrorType.setDescription('The nature of the last error.  Provides interpretation context\n     for gmplsTunnelErrorProtocolCode and\n     gmplsTunnelErrorProtocolSubcode.\n\n     A value of noError(0) shows that there is no error associated\n     with this tunnel and means that the other objects in this table\n     entry (conceptual row) have no meaning.\n\n     A value of unknown(1) shows that there is an error but that no\n     additional information about the cause is known.  The error may\n     have been received in a signaled message or generated locally.\n\n     A value of protocol(2) or pathComputation(3) indicates the\n     cause of an error and identifies an error that has been received\n     through signaling or will itself be signaled.\n\n     A value of localConfiguration(4), localResources(5) or\n     localOther(6) identifies an error that has been detected\n     by the local node but that will not be reported through\n     signaling.')
gmplsTunnelErrorLastTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 6, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelErrorLastTime.setDescription('The time at which the last error occurred.  This is presented as\n     the value of SysUpTime when the error occurred or was reported\n     to this node.\n\n     If gmplsTunnelErrorLastErrorType has the value noError(0), then\n     this object is not valid and should be ignored.\n\n     Note that entries in this table are not persistent over system\n     resets or re-initializations of the management system.')
gmplsTunnelErrorReporterType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 6, 1, 3), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelErrorReporterType.setDescription('The address type of the error reported.\n\n      This object is used to aid in interpretation of\n      gmplsTunnelErrorReporter.')
gmplsTunnelErrorReporter = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 6, 1, 4), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelErrorReporter.setDescription('The address of the node reporting the last error, or the address\n     of the resource (such as an interface) associated with the\n     error.\n\n     If gmplsTunnelErrorLastErrorType has the value noError(0), then\n     this object is not valid and should be ignored.\n\n     If gmplsTunnelErrorLastErrorType has the value unknown(1),\n     localConfiguration(4), localResources(5), or localOther(6),\n     this object MAY contain a zero value.\n\n     This object should be interpreted in the context of the value of\n     the object gmplsTunnelErrorReporterType.')
gmplsTunnelErrorCode = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 6, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelErrorCode.setDescription('The primary error code associated with the last error.\n\n     The interpretation of this error code depends on the value of\n     gmplsTunnelErrorLastErrorType.  If the value of\n     gmplsTunnelErrorLastErrorType is noError(0), the value of this\n     object should be 0 and should be ignored.  If the value of\n     gmplsTunnelErrorLastErrorType is protocol(2), the error should\n     be interpreted in the context of the signaling protocol\n     identified by the mplsTunnelSignallingProto object.')
gmplsTunnelErrorSubcode = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 6, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelErrorSubcode.setDescription('The secondary error code associated with the last error and the\n     protocol used to signal this tunnel.  This value is interpreted\n     in the context of the value of gmplsTunnelErrorCode.\n     If the value of gmplsTunnelErrorLastErrorType is noError(0), the\n     value of this object should be 0 and should be ignored.')
gmplsTunnelErrorTLVs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 6, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0,65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelErrorTLVs.setDescription('The sequence of interface identifier TLVs reported with the\n     error by the protocol code.  The interpretation of the TLVs and\n     the encoding within the protocol are described in the\n     references.  A value of zero in the first octet indicates that no\n     TLVs are present.')
gmplsTunnelErrorHelpString = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 13, 2, 6, 1, 8), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gmplsTunnelErrorHelpString.setDescription('A textual string containing information about the last error,\n     recovery actions, and support advice.  If there is no help string,\n     this object contains a zero length string.\n     If the value of gmplsTunnelErrorLastErrorType is noError(0),\n     this object should contain a zero length string, but may contain\n     a help string indicating that there is no error.')
gmplsTunnelDown = NotificationType((1, 3, 6, 1, 2, 1, 10, 166, 13, 0, 1)).setObjects(*(("GMPLS-TE-STD-MIB", "mplsTunnelAdminStatus"), ("GMPLS-TE-STD-MIB", "mplsTunnelOperStatus"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorLastErrorType"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorReporterType"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorReporter"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorCode"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorSubcode"),))
if mibBuilder.loadTexts: gmplsTunnelDown.setDescription('This notification is generated when an mplsTunnelOperStatus\n      object for a tunnel in the gmplsTunnelTable is about to enter\n      the down state from some other state (but not from the\n      notPresent state).  This other state is indicated by the\n      included value of mplsTunnelOperStatus.\n\n      The objects in this notification provide additional error\n      information that indicates the reason why the tunnel has\n      transitioned to down(2).\n\n      Note that an implementation MUST only issue one of\n      mplsTunnelDown and gmplsTunnelDown for any single event on a\n      single tunnel.  If the tunnel has an entry in the\n      gmplsTunnelTable, an implementation SHOULD use gmplsTunnelDown\n      for all tunnel-down events and SHOULD NOT use mplsTunnelDown.\n\n      This notification is subject to the control of\n      mplsTunnelNotificationEnable.  When that object is set\n      to false(2), then the notification must not be issued.\n\n      Further, this notification is also subject to\n      mplsTunnelNotificationMaxRate.  That object indicates the\n      maximum number of notifications issued per second.  If events\n      occur more rapidly, the implementation may simply fail to emit\n      some notifications during that period, or may queue them until\n      an appropriate time.  The notification rate applies to the sum\n      of all notifications in the MPLS-TE-STD-MIB and\n      GMPLS-TE-STD-MIB modules applied across the whole of the\n      reporting device.\n\n      mplsTunnelOperStatus, mplsTunnelAdminStatus, mplsTunnelDown,\n      mplsTunnelNotificationEnable, and mplsTunnelNotificationMaxRate\n      objects are found in MPLS-TE-STD-MIB.')
gmplsTeGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 13, 3, 1))
gmplsTeCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 13, 3, 2))
gmplsTeModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 166, 13, 3, 2, 1)).setObjects(*(("MPLS-TE-STD-MIB", "mplsTunnelGroup"), ("MPLS-TE-STD-MIB", "mplsTunnelScalarGroup"), ("GMPLS-TE-STD-MIB", "gmplsTunnelGroup"), ("GMPLS-TE-STD-MIB", "gmplsTunnelScalarGroup"), ("GMPLS-TE-STD-MIB", "gmplsTunnelSignaledGroup"), ("GMPLS-TE-STD-MIB", "gmplsTunnelOptionalGroup"), ("GMPLS-TE-STD-MIB", "gmplsTeNotificationGroup"),))
if mibBuilder.loadTexts: gmplsTeModuleFullCompliance.setDescription('Compliance statement for agents that provide full support for\n      GMPLS-TE-STD-MIB.  Such devices can then be monitored and also\n      be configured using this MIB module.\n\n      The mandatory group has to be implemented by all LSRs that\n      originate, terminate, or act as transit for TE-LSPs/tunnels.\n      In addition, depending on the type of tunnels supported, other\n      groups become mandatory as explained below.')
gmplsTeModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 166, 13, 3, 2, 2)).setObjects(*(("GMPLS-TE-STD-MIB", "gmplsTunnelGroup"), ("GMPLS-TE-STD-MIB", "gmplsTunnelScalarGroup"), ("GMPLS-TE-STD-MIB", "gmplsTunnelSignaledGroup"), ("GMPLS-TE-STD-MIB", "gmplsTunnelOptionalGroup"), ("GMPLS-TE-STD-MIB", "gmplsTeNotificationGroup"),))
if mibBuilder.loadTexts: gmplsTeModuleReadOnlyCompliance.setDescription('Compliance requirement for implementations that only provide\n     read-only support for GMPLS-TE-STD-MIB.  Such devices can then be\n     monitored but cannot be configured using this MIB module.')
gmplsTunnelGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 13, 3, 1, 1)).setObjects(*(("GMPLS-TE-STD-MIB", "gmplsTunnelDirection"), ("GMPLS-TE-STD-MIB", "gmplsTunnelReversePerfPackets"), ("GMPLS-TE-STD-MIB", "gmplsTunnelReversePerfHCPackets"), ("GMPLS-TE-STD-MIB", "gmplsTunnelReversePerfErrors"), ("GMPLS-TE-STD-MIB", "gmplsTunnelReversePerfBytes"), ("GMPLS-TE-STD-MIB", "gmplsTunnelReversePerfHCBytes"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorLastErrorType"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorLastTime"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorReporterType"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorReporter"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorCode"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorSubcode"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorTLVs"), ("GMPLS-TE-STD-MIB", "gmplsTunnelErrorHelpString"), ("GMPLS-TE-STD-MIB", "gmplsTunnelUnnumIf"),))
if mibBuilder.loadTexts: gmplsTunnelGroup.setDescription('Necessary, but not sufficient, set of objects to implement\n     tunnels.  In addition, depending on the type of the tunnels\n     supported (for example, manually configured or signaled,\n     persistent or non-persistent, etc.), the\n     gmplsTunnelSignaledGroup group is mandatory.')
gmplsTunnelSignaledGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 13, 3, 1, 2)).setObjects(*(("GMPLS-TE-STD-MIB", "gmplsTunnelAttributes"), ("GMPLS-TE-STD-MIB", "gmplsTunnelLSPEncoding"), ("GMPLS-TE-STD-MIB", "gmplsTunnelSwitchingType"), ("GMPLS-TE-STD-MIB", "gmplsTunnelLinkProtection"), ("GMPLS-TE-STD-MIB", "gmplsTunnelGPid"), ("GMPLS-TE-STD-MIB", "gmplsTunnelSecondary"), ("GMPLS-TE-STD-MIB", "gmplsTunnelPathComp"), ("GMPLS-TE-STD-MIB", "gmplsTunnelUpstreamNotifyRecipientType"), ("GMPLS-TE-STD-MIB", "gmplsTunnelUpstreamNotifyRecipient"), ("GMPLS-TE-STD-MIB", "gmplsTunnelSendResvNotifyRecipientType"), ("GMPLS-TE-STD-MIB", "gmplsTunnelSendResvNotifyRecipient"), ("GMPLS-TE-STD-MIB", "gmplsTunnelDownstreamNotifyRecipientType"), ("GMPLS-TE-STD-MIB", "gmplsTunnelDownstreamNotifyRecipient"), ("GMPLS-TE-STD-MIB", "gmplsTunnelSendPathNotifyRecipientType"), ("GMPLS-TE-STD-MIB", "gmplsTunnelSendPathNotifyRecipient"), ("GMPLS-TE-STD-MIB", "gmplsTunnelAdminStatusFlags"), ("GMPLS-TE-STD-MIB", "gmplsTunnelHopLabelStatuses"), ("GMPLS-TE-STD-MIB", "gmplsTunnelHopExplicitForwardLabel"), ("GMPLS-TE-STD-MIB", "gmplsTunnelHopExplicitForwardLabelPtr"), ("GMPLS-TE-STD-MIB", "gmplsTunnelHopExplicitReverseLabel"), ("GMPLS-TE-STD-MIB", "gmplsTunnelHopExplicitReverseLabelPtr"),))
if mibBuilder.loadTexts: gmplsTunnelSignaledGroup.setDescription('Objects needed to implement signaled tunnels.')
gmplsTunnelScalarGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 13, 3, 1, 3)).setObjects(*(("GMPLS-TE-STD-MIB", "gmplsTunnelsConfigured"), ("GMPLS-TE-STD-MIB", "gmplsTunnelsActive"),))
if mibBuilder.loadTexts: gmplsTunnelScalarGroup.setDescription('Scalar objects needed to implement MPLS tunnels.')
gmplsTunnelOptionalGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 13, 3, 1, 4)).setObjects(*(("GMPLS-TE-STD-MIB", "gmplsTunnelExtraParamsPtr"), ("GMPLS-TE-STD-MIB", "gmplsTunnelARHopLabelStatuses"), ("GMPLS-TE-STD-MIB", "gmplsTunnelARHopExplicitForwardLabel"), ("GMPLS-TE-STD-MIB", "gmplsTunnelARHopExplicitForwardLabelPtr"), ("GMPLS-TE-STD-MIB", "gmplsTunnelARHopExplicitReverseLabel"), ("GMPLS-TE-STD-MIB", "gmplsTunnelARHopExplicitReverseLabelPtr"), ("GMPLS-TE-STD-MIB", "gmplsTunnelARHopProtection"), ("GMPLS-TE-STD-MIB", "gmplsTunnelCHopLabelStatuses"), ("GMPLS-TE-STD-MIB", "gmplsTunnelCHopExplicitForwardLabel"), ("GMPLS-TE-STD-MIB", "gmplsTunnelCHopExplicitForwardLabelPtr"), ("GMPLS-TE-STD-MIB", "gmplsTunnelCHopExplicitReverseLabel"), ("GMPLS-TE-STD-MIB", "gmplsTunnelCHopExplicitReverseLabelPtr"),))
if mibBuilder.loadTexts: gmplsTunnelOptionalGroup.setDescription('The objects in this group are optional.')
gmplsTeNotificationGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 10, 166, 13, 3, 1, 5)).setObjects(*(("GMPLS-TE-STD-MIB", "gmplsTunnelDown"),))
if mibBuilder.loadTexts: gmplsTeNotificationGroup.setDescription('Set of notifications implemented in this module.  None is\n     mandatory.')
mibBuilder.exportSymbols("GMPLS-TE-STD-MIB", gmplsTunnelARHopTable=gmplsTunnelARHopTable, gmplsTunnelCHopLabelStatuses=gmplsTunnelCHopLabelStatuses, gmplsTunnelReversePerfTable=gmplsTunnelReversePerfTable, gmplsTunnelExtraParamsPtr=gmplsTunnelExtraParamsPtr, gmplsTunnelDirection=gmplsTunnelDirection, gmplsTunnelOptionalGroup=gmplsTunnelOptionalGroup, gmplsTunnelTable=gmplsTunnelTable, gmplsTunnelErrorSubcode=gmplsTunnelErrorSubcode, gmplsTunnelAttributes=gmplsTunnelAttributes, gmplsTunnelErrorCode=gmplsTunnelErrorCode, gmplsTunnelAdminStatusFlags=gmplsTunnelAdminStatusFlags, gmplsTeNotifications=gmplsTeNotifications, gmplsTunnelReversePerfErrors=gmplsTunnelReversePerfErrors, gmplsTunnelSwitchingType=gmplsTunnelSwitchingType, gmplsTunnelGPid=gmplsTunnelGPid, gmplsTunnelSendResvNotifyRecipient=gmplsTunnelSendResvNotifyRecipient, gmplsTunnelErrorHelpString=gmplsTunnelErrorHelpString, gmplsTunnelsConfigured=gmplsTunnelsConfigured, gmplsTeNotificationGroup=gmplsTeNotificationGroup, gmplsTunnelDownstreamNotifyRecipientType=gmplsTunnelDownstreamNotifyRecipientType, gmplsTunnelARHopExplicitReverseLabel=gmplsTunnelARHopExplicitReverseLabel, gmplsTunnelLinkProtection=gmplsTunnelLinkProtection, gmplsTunnelErrorTable=gmplsTunnelErrorTable, gmplsTeScalars=gmplsTeScalars, gmplsTunnelEntry=gmplsTunnelEntry, gmplsTunnelHopTable=gmplsTunnelHopTable, gmplsTunnelARHopExplicitForwardLabel=gmplsTunnelARHopExplicitForwardLabel, gmplsTunnelCHopExplicitForwardLabelPtr=gmplsTunnelCHopExplicitForwardLabelPtr, gmplsTunnelReversePerfHCBytes=gmplsTunnelReversePerfHCBytes, gmplsTunnelUpstreamNotifyRecipientType=gmplsTunnelUpstreamNotifyRecipientType, gmplsTeGroups=gmplsTeGroups, gmplsTeObjects=gmplsTeObjects, gmplsTunnelDownstreamNotifyRecipient=gmplsTunnelDownstreamNotifyRecipient, gmplsTunnelCHopEntry=gmplsTunnelCHopEntry, gmplsTunnelErrorLastErrorType=gmplsTunnelErrorLastErrorType, gmplsTunnelGroup=gmplsTunnelGroup, gmplsTunnelErrorEntry=gmplsTunnelErrorEntry, gmplsTunnelErrorTLVs=gmplsTunnelErrorTLVs, gmplsTunnelsActive=gmplsTunnelsActive, gmplsTunnelSendPathNotifyRecipientType=gmplsTunnelSendPathNotifyRecipientType, gmplsTunnelErrorLastTime=gmplsTunnelErrorLastTime, gmplsTunnelUpstreamNotifyRecipient=gmplsTunnelUpstreamNotifyRecipient, gmplsTunnelARHopLabelStatuses=gmplsTunnelARHopLabelStatuses, gmplsTunnelHopLabelStatuses=gmplsTunnelHopLabelStatuses, gmplsTeStdMIB=gmplsTeStdMIB, gmplsTunnelSignaledGroup=gmplsTunnelSignaledGroup, gmplsTunnelErrorReporter=gmplsTunnelErrorReporter, gmplsTunnelHopEntry=gmplsTunnelHopEntry, gmplsTunnelPathComp=gmplsTunnelPathComp, gmplsTunnelHopExplicitReverseLabel=gmplsTunnelHopExplicitReverseLabel, gmplsTunnelHopExplicitReverseLabelPtr=gmplsTunnelHopExplicitReverseLabelPtr, gmplsTunnelARHopEntry=gmplsTunnelARHopEntry, gmplsTunnelCHopExplicitForwardLabel=gmplsTunnelCHopExplicitForwardLabel, gmplsTunnelReversePerfEntry=gmplsTunnelReversePerfEntry, gmplsTunnelUnnumIf=gmplsTunnelUnnumIf, gmplsTunnelARHopExplicitForwardLabelPtr=gmplsTunnelARHopExplicitForwardLabelPtr, gmplsTunnelSendPathNotifyRecipient=gmplsTunnelSendPathNotifyRecipient, gmplsTeModuleReadOnlyCompliance=gmplsTeModuleReadOnlyCompliance, gmplsTeConformance=gmplsTeConformance, gmplsTunnelCHopTable=gmplsTunnelCHopTable, gmplsTeModuleFullCompliance=gmplsTeModuleFullCompliance, gmplsTunnelSecondary=gmplsTunnelSecondary, gmplsTunnelSendResvNotifyRecipientType=gmplsTunnelSendResvNotifyRecipientType, gmplsTunnelHopExplicitForwardLabel=gmplsTunnelHopExplicitForwardLabel, gmplsTunnelReversePerfBytes=gmplsTunnelReversePerfBytes, gmplsTunnelLSPEncoding=gmplsTunnelLSPEncoding, gmplsTunnelDown=gmplsTunnelDown, gmplsTeCompliances=gmplsTeCompliances, gmplsTunnelErrorReporterType=gmplsTunnelErrorReporterType, gmplsTunnelScalarGroup=gmplsTunnelScalarGroup, PYSNMP_MODULE_ID=gmplsTeStdMIB, gmplsTunnelHopExplicitForwardLabelPtr=gmplsTunnelHopExplicitForwardLabelPtr, gmplsTunnelARHopProtection=gmplsTunnelARHopProtection, gmplsTunnelReversePerfHCPackets=gmplsTunnelReversePerfHCPackets, gmplsTunnelCHopExplicitReverseLabelPtr=gmplsTunnelCHopExplicitReverseLabelPtr, gmplsTunnelARHopExplicitReverseLabelPtr=gmplsTunnelARHopExplicitReverseLabelPtr, gmplsTunnelReversePerfPackets=gmplsTunnelReversePerfPackets, gmplsTunnelCHopExplicitReverseLabel=gmplsTunnelCHopExplicitReverseLabel)
