#
# PySNMP MIB module FRAME-RELAY-DTE-MIB (http://pysnmp.sf.net)
# ASN.1 source http://mibs.snmplabs.com:80/asn1/FRAME-RELAY-DTE-MIB
# Produced by pysmi-0.0.7 at Sun Feb 14 00:13:10 2016
# On host bldfarm platform Linux version 4.1.13-100.fc21.x86_64 by user goose
# Using Python version 3.5.0 (default, Jan  5 2016, 17:11:52) 
#
( ObjectIdentifier, Integer, OctetString, ) = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint")
( InterfaceIndex, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
( ObjectGroup, NotificationGroup, ModuleCompliance, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
( Gauge32, Integer32, ModuleIdentity, MibIdentifier, iso, ObjectIdentity, TimeTicks, Bits, NotificationType, IpAddress, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Unsigned32, transmission, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "Integer32", "ModuleIdentity", "MibIdentifier", "iso", "ObjectIdentity", "TimeTicks", "Bits", "NotificationType", "IpAddress", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Unsigned32", "transmission")
( TextualConvention, DisplayString, RowStatus, TimeStamp, ) = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "RowStatus", "TimeStamp")
frameRelayDTE = ModuleIdentity((1, 3, 6, 1, 2, 1, 10, 32)).setRevisions(("1997-05-01 02:29", "1992-04-01 00:00",))
if mibBuilder.loadTexts: frameRelayDTE.setLastUpdated('9705010229Z')
if mibBuilder.loadTexts: frameRelayDTE.setOrganization('IETF IPLPDN Working Group')
if mibBuilder.loadTexts: frameRelayDTE.setContactInfo('       Caralyn Brown\n            Postal: Cadia Networks, Inc.\n                    1 Corporate Drive\n                    Andover, Massachusetts  01810\n            Tel:    +1 508 689 2400 x133\n            E-Mail: cbrown@cadia.com\n\n                    Fred Baker\n            Postal: Cisco Systems\n                    519 Lado Drive\n                    Santa Barbara, California 93111\n            Tel:    +1 408 526 425\n            E-Mail: fred@cisco.com')
if mibBuilder.loadTexts: frameRelayDTE.setDescription('The MIB module to describe the use of a Frame Relay\n            interface by a DTE.')
class DLCI(Integer32, TextualConvention):
    subtypeSpec = Integer32.subtypeSpec+ValueRangeConstraint(0,8388607)

frDlcmiTable = MibTable((1, 3, 6, 1, 2, 1, 10, 32, 1), )
if mibBuilder.loadTexts: frDlcmiTable.setDescription('The Parameters for the Data Link Connection Management\n            Interface for the frame relay service on this\n            interface.')
frDlcmiEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 32, 1, 1), ).setIndexNames((0, "FRAME-RELAY-DTE-MIB", "frDlcmiIfIndex"))
if mibBuilder.loadTexts: frDlcmiEntry.setDescription('The Parameters for a particular Data Link Connection\n            Management Interface.')
frDlcmiIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 1, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frDlcmiIfIndex.setDescription('The ifIndex value of the corresponding ifEntry.')
frDlcmiState = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6,))).clone(namedValues=NamedValues(("noLmiConfigured", 1), ("lmiRev1", 2), ("ansiT1617D", 3), ("ansiT1617B", 4), ("itut933A", 5), ("ansiT1617D1994", 6),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frDlcmiState.setDescription('This variable states which Data Link Connection\n            Management scheme is active (and by implication, what\n            DLCI it uses) on the Frame Relay interface.')
frDlcmiAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4,))).clone(namedValues=NamedValues(("q921", 1), ("q922March90", 2), ("q922November90", 3), ("q922", 4),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frDlcmiAddress.setDescription('This variable states which address format is in use on\n            the Frame Relay interface.')
frDlcmiAddressLen = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4,))).clone(namedValues=NamedValues(("twoOctets", 2), ("threeOctets", 3), ("fourOctets", 4),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frDlcmiAddressLen.setDescription('This variable states the address length in octets.  In\n            the case of Q922 format, the length indicates the\n            entire length of the address including the control\n            portion.')
frDlcmiPollingInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5,30)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: frDlcmiPollingInterval.setDescription('This is the number of seconds between successive\n            status enquiry messages.')
frDlcmiFullEnquiryInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,255)).clone(6)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frDlcmiFullEnquiryInterval.setDescription('Number of status enquiry intervals that pass before\n            issuance of a full status enquiry message.')
frDlcmiErrorThreshold = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,10)).clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frDlcmiErrorThreshold.setDescription('This is the maximum number of unanswered Status\n            Enquiries the equipment shall accept before declaring\n            the interface down.')
frDlcmiMonitoredEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,10)).clone(4)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frDlcmiMonitoredEvents.setDescription("This is the number of status polling intervals over\n            which the error threshold is counted.  For example, if\n            within 'MonitoredEvents' number of events the station\n            receives 'ErrorThreshold' number of errors, the\n            interface is marked as down.")
frDlcmiMaxSupportedVCs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 1, 1, 9), DLCI()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frDlcmiMaxSupportedVCs.setDescription("The maximum number of Virtual Circuits allowed for\n            this interface.  Usually dictated by the Frame Relay\n            network.\n\n            In response to a SET, if a value less than zero or\n            higher than the agent's maximal capability is\n            configured, the agent should respond badValue")
frDlcmiMulticast = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("nonBroadcast", 1), ("broadcast", 2),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frDlcmiMulticast.setDescription('This indicates whether the Frame Relay interface is\n            using a multicast service.')
frDlcmiStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("running", 1), ("fault", 2), ("initializing", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frDlcmiStatus.setDescription('This indicates the status of the Frame Relay interface\n            as determined by the performance of the dlcmi.  If no\n            dlcmi is running, the Frame Relay interface will stay\n            in the running state indefinitely.')
frDlcmiRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 1, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frDlcmiRowStatus.setDescription('SNMP Version 2 Row Status Variable.  Writable objects\n            in the table may be written in any RowStatus state.')
frCircuitTable = MibTable((1, 3, 6, 1, 2, 1, 10, 32, 2), )
if mibBuilder.loadTexts: frCircuitTable.setDescription('A table containing information about specific Data\n            Link Connections (DLC) or virtual circuits.')
frCircuitEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 32, 2, 1), ).setIndexNames((0, "FRAME-RELAY-DTE-MIB", "frCircuitIfIndex"), (0, "FRAME-RELAY-DTE-MIB", "frCircuitDlci"))
if mibBuilder.loadTexts: frCircuitEntry.setDescription('The information regarding a single Data Link\n            Connection.  Discontinuities in the counters contained\n            in this table are indicated by the value in\n            frCircuitCreationTime.')
frCircuitIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 2, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCircuitIfIndex.setDescription('The ifIndex Value of the ifEntry this virtual circuit\n            is layered onto.')
frCircuitDlci = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 2, 1, 2), DLCI()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCircuitDlci.setDescription('The Data Link Connection Identifier for this virtual\n            circuit.')
frCircuitState = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("invalid", 1), ("active", 2), ("inactive", 3),)).clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frCircuitState.setDescription("Indicates whether the particular virtual circuit is\n            operational.  In the absence of a Data Link Connection\n            Management Interface, virtual circuit entries (rows)\n            may be created by setting virtual circuit state to\n            'active', or deleted by changing Circuit state to\n            'invalid'.\n\n            Whether or not the row actually disappears is left to\n            the implementation, so this object may actually read as\n            'invalid' for some arbitrary length of time.  It is\n            also legal to set the state of a virtual circuit to\n            'inactive' to temporarily disable a given circuit.\n\n            The use of 'invalid' is deprecated in this SNMP Version\n            2 MIB, in favor of frCircuitRowStatus.")
frCircuitReceivedFECNs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCircuitReceivedFECNs.setDescription('Number of frames received from the network indicating\n            forward congestion since the virtual circuit was\n            created.  This occurs when the remote DTE sets the FECN\n            flag, or when a switch in the network enqueues the\n            frame to a trunk whose transmission queue is\n            congested.')
frCircuitReceivedBECNs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCircuitReceivedBECNs.setDescription('Number of frames received from the network indicating\n            backward congestion since the virtual circuit was\n            created.  This occurs when the remote DTE sets the BECN\n            flag, or when a switch in the network receives the\n            frame from a trunk whose transmission queue is\n            congested.')
frCircuitSentFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCircuitSentFrames.setDescription('The number of frames sent from this virtual circuit\n            since it was created.')
frCircuitSentOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCircuitSentOctets.setDescription('The number of octets sent from this virtual circuit\n            since it was created.  Octets counted are the full\n            frame relay header and the payload, but do not include\n            the flag characters or CRC.')
frCircuitReceivedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCircuitReceivedFrames.setDescription('Number of frames received over this virtual circuit\n            since it was created.')
frCircuitReceivedOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCircuitReceivedOctets.setDescription('Number of octets received over this virtual circuit\n            since it was created.  Octets counted include the full\n            frame relay header, but do not include the flag\n            characters or the CRC.')
frCircuitCreationTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 2, 1, 10), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCircuitCreationTime.setDescription('The value of sysUpTime when the virtual circuit was\n            created, whether by the Data Link Connection Management\n            Interface or by a SetRequest.')
frCircuitLastTimeChange = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 2, 1, 11), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCircuitLastTimeChange.setDescription('The value of sysUpTime when last there was a change in\n            the virtual circuit state')
frCircuitCommittedBurst = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frCircuitCommittedBurst.setDescription('This variable indicates the maximum amount of data, in\n            bits, that the network agrees to transfer under normal\n            conditions, during the measurement interval.')
frCircuitExcessBurst = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frCircuitExcessBurst.setDescription('This variable indicates the maximum amount of\n            uncommitted data bits that the network will attempt to\n            deliver over the measurement interval.\n\n            By default, if not configured when creating the entry,\n            the Excess Information Burst Size is set to the value\n            of ifSpeed.')
frCircuitThroughput = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frCircuitThroughput.setDescription("Throughput is the average number of 'Frame Relay\n            Information Field' bits transferred per second across a\n            user network interface in one direction, measured over\n            the measurement interval.\n\n            If the configured committed burst rate and throughput\n            are both non-zero, the measurement interval, T, is\n                T=frCircuitCommittedBurst/frCircuitThroughput.\n\n            If the configured committed burst rate and throughput\n            are both zero, the measurement interval, T, is\n                       T=frCircuitExcessBurst/ifSpeed.")
frCircuitMulticast = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4,))).clone(namedValues=NamedValues(("unicast", 1), ("oneWay", 2), ("twoWay", 3), ("nWay", 4),)).clone('unicast')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frCircuitMulticast.setDescription('This indicates whether this VC is used as a unicast VC\n            (i.e. not multicast) or the type of multicast service\n            subscribed to')
frCircuitType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCircuitType.setDescription('Indication of whether the VC was manually created\n            (static), or dynamically created (dynamic) via the data\n            link control management interface.')
frCircuitDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCircuitDiscards.setDescription('The number of inbound frames dropped because of format\n            errors, or because the VC is inactive.')
frCircuitReceivedDEs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCircuitReceivedDEs.setDescription("Number of frames received from the network indicating\n            that they were eligible for discard since the virtual\n            circuit was created.  This occurs when the remote DTE\n            sets the DE flag, or when in remote DTE's switch\n            detects that the frame was received as Excess Burst\n            data.")
frCircuitSentDEs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frCircuitSentDEs.setDescription('Number of frames sent to the network indicating that\n            they were eligible for discard since the virtual\n            circuit was created.   This occurs when the local DTE\n            sets the DE flag, indicating that during Network\n            congestion situations those frames should be discarded\n            in preference of other frames sent without the DE bit\n            set.')
frCircuitLogicalIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 2, 1, 20), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frCircuitLogicalIfIndex.setDescription('Normally the same value as frDlcmiIfIndex, but\n            different when an implementation associates a virtual\n            ifEntry with a DLC or set of DLCs in order to associate\n            higher layer objects such as the ipAddrEntry with a\n            subset of the virtual circuits on a Frame Relay\n            interface. The type of such ifEntries is defined by the\n            higher layer object; for example, if PPP/Frame Relay is\n            implemented, the ifType of this ifEntry would be PPP.\n            If it is not so defined, as would be the case with an\n            ipAddrEntry, it should be of type Other.')
frCircuitRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 2, 1, 21), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frCircuitRowStatus.setDescription('This object is used to create a new row or modify or\n            destroy an existing row in the manner described in the\n            definition of the RowStatus textual convention.\n            Writable objects in the table may be written in any\n            RowStatus state.')
frErrTable = MibTable((1, 3, 6, 1, 2, 1, 10, 32, 3), )
if mibBuilder.loadTexts: frErrTable.setDescription('A table containing information about Errors on the\n            Frame Relay interface.  Discontinuities in the counters\n            contained in this table are the same as apply to the\n            ifEntry associated with the Interface.')
frErrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 32, 3, 1), ).setIndexNames((0, "FRAME-RELAY-DTE-MIB", "frErrIfIndex"))
if mibBuilder.loadTexts: frErrEntry.setDescription('The error information for a single frame relay\n            interface.')
frErrIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 3, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frErrIfIndex.setDescription('The ifIndex Value of the corresponding ifEntry.')
frErrType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10,))).clone(namedValues=NamedValues(("unknownError", 1), ("receiveShort", 2), ("receiveLong", 3), ("illegalAddress", 4), ("unknownAddress", 5), ("dlcmiProtoErr", 6), ("dlcmiUnknownIE", 7), ("dlcmiSequenceErr", 8), ("dlcmiUnknownRpt", 9), ("noErrorSinceReset", 10),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frErrType.setDescription('The type of error that was last seen  on  this interface:\n\n     receiveShort: frame was not long enough to allow\n             demultiplexing - the address field was incomplete,\n             or for virtual circuits using Multiprotocol over\n             Frame Relay, the protocol identifier was missing\n             or incomplete.\n\n     receiveLong: frame exceeded maximum length configured for this\n                  interface.\n\n     illegalAddress: address field did not match configured format.\n\n     unknownAddress: frame received on a virtual circuit which was not\n                     active or administratively disabled.\n\n     dlcmiProtoErr: unspecified error occurred when attempting to\n                    interpret link maintenance frame.\n\n     dlcmiUnknownIE: link maintenance frame contained an Information\n                     Element type which is not valid for the\n                     configured link maintenance protocol.\n\n     dlcmiSequenceErr: link maintenance frame contained a sequence\n                       number other than the expected value.\n\n     dlcmiUnknownRpt: link maintenance frame contained a Report Type\n                      Information Element whose value was not valid\n                      for the configured link maintenance protocol.\n\n     noErrorSinceReset: no errors have been detected since the last\n                        cold start or warm start.')
frErrData = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1,1600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frErrData.setDescription('An octet string containing as much of the error packet\n            as possible.  As a minimum, it must contain the Q.922\n            Address or as much as was delivered.  It is desirable\n            to include all header and demultiplexing information.')
frErrTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 3, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frErrTime.setDescription('The value of sysUpTime at which the error was\n            detected.')
frErrFaults = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frErrFaults.setDescription('The number of times the interface has gone down since\n            it was initialized.')
frErrFaultTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 32, 3, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frErrFaultTime.setDescription('The value of sysUpTime at the time when the interface\n            was taken down due to excessive errors.  Excessive\n            errors is defined as the time when a DLCMI exceeds the\n            frDlcmiErrorThreshold number of errors within\n            frDlcmiMonitoredEvents. See FrDlcmiEntry for further\n            details.')
frameRelayTrapControl = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 32, 4))
frameRelayTraps = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 32, 0))
frTrapState = MibScalar((1, 3, 6, 1, 2, 1, 10, 32, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2),)).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frTrapState.setDescription('This variable indicates whether the system produces\n            the frDLCIStatusChange trap.')
frTrapMaxRate = MibScalar((1, 3, 6, 1, 2, 1, 10, 32, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,3600000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frTrapMaxRate.setDescription('This variable indicates the number of milliseconds\n            that must elapse between trap emissions.  If events\n            occur more rapidly, the impementation may simply fail\n            to trap, or may queue traps until an appropriate time.')
frDLCIStatusChange = NotificationType((1, 3, 6, 1, 2, 1, 10, 32, 0, 1)).setObjects(*(("FRAME-RELAY-DTE-MIB", "frCircuitState"),))
if mibBuilder.loadTexts: frDLCIStatusChange.setDescription('This trap indicates that the indicated Virtual Circuit\n            has changed state.  It has either been created or\n            invalidated, or has toggled between the active and\n            inactive states.  If, however, the reason for the state\n            change is due to the DLCMI going down, per-DLCI traps\n            should not be generated.')
frConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 32, 6))
frGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 32, 6, 1))
frCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 32, 6, 2))
frCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 32, 6, 2, 1)).setObjects(*(("FRAME-RELAY-DTE-MIB", "frPortGroup"), ("FRAME-RELAY-DTE-MIB", "frCircuitGroup"), ("FRAME-RELAY-DTE-MIB", "frErrGroup"), ("FRAME-RELAY-DTE-MIB", "frTrapGroup"), ("FRAME-RELAY-DTE-MIB", "frNotificationGroup"),))
if mibBuilder.loadTexts: frCompliance.setDescription('The compliance statement ')
frCompliance0 = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 32, 6, 2, 2)).setObjects(*(("FRAME-RELAY-DTE-MIB", "frPortGroup0"), ("FRAME-RELAY-DTE-MIB", "frCircuitGroup0"), ("FRAME-RELAY-DTE-MIB", "frErrGroup0"), ("FRAME-RELAY-DTE-MIB", "frTrapGroup0"), ("FRAME-RELAY-DTE-MIB", "frNotificationGroup"),))
if mibBuilder.loadTexts: frCompliance0.setDescription('The compliance statement for objects and the trap\n            defined in RFC 1315.')
frPortGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 32, 6, 1, 1)).setObjects(*(("FRAME-RELAY-DTE-MIB", "frDlcmiIfIndex"), ("FRAME-RELAY-DTE-MIB", "frDlcmiState"), ("FRAME-RELAY-DTE-MIB", "frDlcmiAddress"), ("FRAME-RELAY-DTE-MIB", "frDlcmiAddressLen"), ("FRAME-RELAY-DTE-MIB", "frDlcmiPollingInterval"), ("FRAME-RELAY-DTE-MIB", "frDlcmiFullEnquiryInterval"), ("FRAME-RELAY-DTE-MIB", "frDlcmiErrorThreshold"), ("FRAME-RELAY-DTE-MIB", "frDlcmiMonitoredEvents"), ("FRAME-RELAY-DTE-MIB", "frDlcmiMaxSupportedVCs"), ("FRAME-RELAY-DTE-MIB", "frDlcmiMulticast"), ("FRAME-RELAY-DTE-MIB", "frDlcmiStatus"), ("FRAME-RELAY-DTE-MIB", "frDlcmiRowStatus"),))
if mibBuilder.loadTexts: frPortGroup.setDescription('The objects necessary to control the Link Management\n            Interface for a Frame Relay Interface as well as\n            maintain the error statistics on this interface.')
frCircuitGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 32, 6, 1, 2)).setObjects(*(("FRAME-RELAY-DTE-MIB", "frCircuitIfIndex"), ("FRAME-RELAY-DTE-MIB", "frCircuitDlci"), ("FRAME-RELAY-DTE-MIB", "frCircuitState"), ("FRAME-RELAY-DTE-MIB", "frCircuitReceivedFECNs"), ("FRAME-RELAY-DTE-MIB", "frCircuitReceivedBECNs"), ("FRAME-RELAY-DTE-MIB", "frCircuitSentFrames"), ("FRAME-RELAY-DTE-MIB", "frCircuitSentOctets"), ("FRAME-RELAY-DTE-MIB", "frCircuitReceivedFrames"), ("FRAME-RELAY-DTE-MIB", "frCircuitReceivedOctets"), ("FRAME-RELAY-DTE-MIB", "frCircuitCreationTime"), ("FRAME-RELAY-DTE-MIB", "frCircuitLastTimeChange"), ("FRAME-RELAY-DTE-MIB", "frCircuitCommittedBurst"), ("FRAME-RELAY-DTE-MIB", "frCircuitExcessBurst"), ("FRAME-RELAY-DTE-MIB", "frCircuitThroughput"), ("FRAME-RELAY-DTE-MIB", "frCircuitMulticast"), ("FRAME-RELAY-DTE-MIB", "frCircuitType"), ("FRAME-RELAY-DTE-MIB", "frCircuitDiscards"), ("FRAME-RELAY-DTE-MIB", "frCircuitReceivedDEs"), ("FRAME-RELAY-DTE-MIB", "frCircuitSentDEs"), ("FRAME-RELAY-DTE-MIB", "frCircuitLogicalIfIndex"), ("FRAME-RELAY-DTE-MIB", "frCircuitRowStatus"),))
if mibBuilder.loadTexts: frCircuitGroup.setDescription('The objects necessary to control the Virtual Circuits\n            layered onto a Frame Relay Interface.')
frTrapGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 32, 6, 1, 3)).setObjects(*(("FRAME-RELAY-DTE-MIB", "frTrapState"), ("FRAME-RELAY-DTE-MIB", "frTrapMaxRate"),))
if mibBuilder.loadTexts: frTrapGroup.setDescription("The objects necessary to control a Frame Relay\n            Interface's notification messages.")
frErrGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 32, 6, 1, 4)).setObjects(*(("FRAME-RELAY-DTE-MIB", "frErrIfIndex"), ("FRAME-RELAY-DTE-MIB", "frErrType"), ("FRAME-RELAY-DTE-MIB", "frErrData"), ("FRAME-RELAY-DTE-MIB", "frErrTime"), ("FRAME-RELAY-DTE-MIB", "frErrFaults"), ("FRAME-RELAY-DTE-MIB", "frErrFaultTime"),))
if mibBuilder.loadTexts: frErrGroup.setDescription('Objects designed to assist in debugging Frame Relay\n            Interfaces.')
frNotificationGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 10, 32, 6, 1, 5)).setObjects(*(("FRAME-RELAY-DTE-MIB", "frDLCIStatusChange"),))
if mibBuilder.loadTexts: frNotificationGroup.setDescription('Traps which may be used to enhance event driven\n            management of the interface.')
frPortGroup0 = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 32, 6, 1, 6)).setObjects(*(("FRAME-RELAY-DTE-MIB", "frDlcmiIfIndex"), ("FRAME-RELAY-DTE-MIB", "frDlcmiState"), ("FRAME-RELAY-DTE-MIB", "frDlcmiAddress"), ("FRAME-RELAY-DTE-MIB", "frDlcmiAddressLen"), ("FRAME-RELAY-DTE-MIB", "frDlcmiPollingInterval"), ("FRAME-RELAY-DTE-MIB", "frDlcmiFullEnquiryInterval"), ("FRAME-RELAY-DTE-MIB", "frDlcmiErrorThreshold"), ("FRAME-RELAY-DTE-MIB", "frDlcmiMonitoredEvents"), ("FRAME-RELAY-DTE-MIB", "frDlcmiMaxSupportedVCs"), ("FRAME-RELAY-DTE-MIB", "frDlcmiMulticast"),))
if mibBuilder.loadTexts: frPortGroup0.setDescription('The objects necessary to control the Link Management\n            Interface for a Frame Relay Interface as well as\n            maintain the error statistics on this interface from\n            RFC 1315.')
frCircuitGroup0 = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 32, 6, 1, 7)).setObjects(*(("FRAME-RELAY-DTE-MIB", "frCircuitIfIndex"), ("FRAME-RELAY-DTE-MIB", "frCircuitDlci"), ("FRAME-RELAY-DTE-MIB", "frCircuitState"), ("FRAME-RELAY-DTE-MIB", "frCircuitReceivedFECNs"), ("FRAME-RELAY-DTE-MIB", "frCircuitReceivedBECNs"), ("FRAME-RELAY-DTE-MIB", "frCircuitSentFrames"), ("FRAME-RELAY-DTE-MIB", "frCircuitSentOctets"), ("FRAME-RELAY-DTE-MIB", "frCircuitReceivedFrames"), ("FRAME-RELAY-DTE-MIB", "frCircuitReceivedOctets"), ("FRAME-RELAY-DTE-MIB", "frCircuitCreationTime"), ("FRAME-RELAY-DTE-MIB", "frCircuitLastTimeChange"), ("FRAME-RELAY-DTE-MIB", "frCircuitCommittedBurst"), ("FRAME-RELAY-DTE-MIB", "frCircuitExcessBurst"), ("FRAME-RELAY-DTE-MIB", "frCircuitThroughput"),))
if mibBuilder.loadTexts: frCircuitGroup0.setDescription('The objects necessary to control the Virtual Circuits\n            layered onto a Frame Relay Interface from RFC 1315.')
frErrGroup0 = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 32, 6, 1, 8)).setObjects(*(("FRAME-RELAY-DTE-MIB", "frErrIfIndex"), ("FRAME-RELAY-DTE-MIB", "frErrType"), ("FRAME-RELAY-DTE-MIB", "frErrData"), ("FRAME-RELAY-DTE-MIB", "frErrTime"),))
if mibBuilder.loadTexts: frErrGroup0.setDescription('Objects designed to assist in debugging Frame Relay\n            Interfaces from RFC 1315.')
frTrapGroup0 = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 32, 6, 1, 9)).setObjects(*(("FRAME-RELAY-DTE-MIB", "frTrapState"),))
if mibBuilder.loadTexts: frTrapGroup0.setDescription("The objects necessary to control a Frame Relay\n            Interface's notification messages from RFC 1315.")
mibBuilder.exportSymbols("FRAME-RELAY-DTE-MIB", frErrTable=frErrTable, frDlcmiPollingInterval=frDlcmiPollingInterval, frameRelayDTE=frameRelayDTE, frCompliance0=frCompliance0, frErrType=frErrType, frDlcmiIfIndex=frDlcmiIfIndex, frCircuitReceivedFrames=frCircuitReceivedFrames, frDlcmiTable=frDlcmiTable, frTrapGroup=frTrapGroup, frErrEntry=frErrEntry, frCircuitReceivedFECNs=frCircuitReceivedFECNs, frErrGroup0=frErrGroup0, frCircuitSentFrames=frCircuitSentFrames, frErrFaultTime=frErrFaultTime, frCircuitReceivedOctets=frCircuitReceivedOctets, frDlcmiFullEnquiryInterval=frDlcmiFullEnquiryInterval, frDlcmiEntry=frDlcmiEntry, frDlcmiErrorThreshold=frDlcmiErrorThreshold, frCircuitDiscards=frCircuitDiscards, frGroups=frGroups, frTrapMaxRate=frTrapMaxRate, frCircuitGroup0=frCircuitGroup0, frCircuitType=frCircuitType, frameRelayTrapControl=frameRelayTrapControl, frCircuitMulticast=frCircuitMulticast, frDlcmiMulticast=frDlcmiMulticast, frCircuitSentOctets=frCircuitSentOctets, frCircuitIfIndex=frCircuitIfIndex, frCircuitState=frCircuitState, frCircuitEntry=frCircuitEntry, frDlcmiAddressLen=frDlcmiAddressLen, frPortGroup=frPortGroup, frErrFaults=frErrFaults, frCircuitExcessBurst=frCircuitExcessBurst, frDlcmiStatus=frDlcmiStatus, frNotificationGroup=frNotificationGroup, frPortGroup0=frPortGroup0, frCircuitGroup=frCircuitGroup, frErrGroup=frErrGroup, frCircuitCommittedBurst=frCircuitCommittedBurst, frCircuitLogicalIfIndex=frCircuitLogicalIfIndex, frCircuitReceivedDEs=frCircuitReceivedDEs, frCircuitSentDEs=frCircuitSentDEs, frTrapState=frTrapState, frCircuitTable=frCircuitTable, frDlcmiAddress=frDlcmiAddress, frCircuitCreationTime=frCircuitCreationTime, PYSNMP_MODULE_ID=frameRelayDTE, frDlcmiMonitoredEvents=frDlcmiMonitoredEvents, frDlcmiRowStatus=frDlcmiRowStatus, frErrData=frErrData, DLCI=DLCI, frErrIfIndex=frErrIfIndex, frDLCIStatusChange=frDLCIStatusChange, frCompliances=frCompliances, frCompliance=frCompliance, frCircuitThroughput=frCircuitThroughput, frTrapGroup0=frTrapGroup0, frErrTime=frErrTime, frCircuitLastTimeChange=frCircuitLastTimeChange, frCircuitDlci=frCircuitDlci, frConformance=frConformance, frDlcmiMaxSupportedVCs=frDlcmiMaxSupportedVCs, frDlcmiState=frDlcmiState, frameRelayTraps=frameRelayTraps, frCircuitRowStatus=frCircuitRowStatus, frCircuitReceivedBECNs=frCircuitReceivedBECNs)
