#
# PySNMP MIB module APPC-MIB (http://pysnmp.sf.net)
# ASN.1 source http://mibs.snmplabs.com:80/asn1/APPC-MIB
# Produced by pysmi-0.0.7 at Sun Feb 14 00:05:05 2016
# On host bldfarm platform Linux version 4.1.13-100.fc21.x86_64 by user goose
# Using Python version 3.5.0 (default, Jan  5 2016, 17:11:52) 
#
( ObjectIdentifier, OctetString, Integer, ) = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint")
( snanauMIB, ) = mibBuilder.importSymbols("SNA-NAU-MIB", "snanauMIB")
( ModuleCompliance, NotificationGroup, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
( TimeTicks, iso, Unsigned32, ObjectIdentity, Counter32, NotificationType, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Counter64, Bits, Integer32, MibIdentifier, ModuleIdentity, mib_2, ) = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "iso", "Unsigned32", "ObjectIdentity", "Counter32", "NotificationType", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Counter64", "Bits", "Integer32", "MibIdentifier", "ModuleIdentity", "mib-2")
( DisplayString, InstancePointer, TextualConvention, DateAndTime, ) = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "InstancePointer", "TextualConvention", "DateAndTime")
appcMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 34, 3))
if mibBuilder.loadTexts: appcMIB.setLastUpdated('9512150000Z')
if mibBuilder.loadTexts: appcMIB.setOrganization('IETF SNA NAU MIB Working Group')
if mibBuilder.loadTexts: appcMIB.setContactInfo('\n                        Michael Allen\n                        Wall Data Inc.\n                        P.O.Box 1120\n                        Duval, WA 98019, USA\n                        Tel:    1 206 844 3505\n                        E-mail: mallen@hq.walldata.com\n\n                        Bob Clouston\n                        Cisco Systems\n                        7025 Kit Creek Road\n                        P.O. Box 14987\n                        Research Triangle Park, NC 27709, USA\n                        Tel:    1 919 472 2333\n                        E-mail: clouston@cisco.com\n\n                        Zbigniew Kielczewski\n                        Cisco Systems\n                        3100 Smoketree Court\n                        Raleigh, NC 27604, USA\n                        Tel:    1 919 871 6326\n                        E-mail: zbig@cisco.com\n\n\n\n\n                        William Kwan\n                        Jupiter Technology Inc.\n                        200 Prospect Street\n                        Waltham, MA 02254, USA\n                        Tel:    1 617 894 9300, x423\n                        E-mail: billk@jti.com\n\n                        Bob Moore\n                        IBM Corporation\n                        800 Park Offices Drive\n                        CNMA/664\n                        P.O. Box 12195\n                        Research Triangle Park, NC 27709, USA\n                        Tel:    1 919 254 4436\n                        E-mail: remoore@ralvm6.vnet.ibm.com\n                ')
if mibBuilder.loadTexts: appcMIB.setDescription('This is the MIB module for objects used to manage network\n          devices with APPC capabilities.')
appcObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 1))
appcGlobal = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 1, 1))
appcLu = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 1, 2))
appcTp = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 1, 3))
appcSession = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 1, 4))
appcConversation = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 1, 5))
appcCPIC = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 1, 6))
class SnaSenseData(DisplayString, TextualConvention):
    subtypeSpec = DisplayString.subtypeSpec+ValueSizeConstraint(8,8)
    fixedLength = 8

appcCntrlAdminGroup = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 1))
appcCntrlAdminStat = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCntrlAdminStat.setDescription('Indicates the desired state of statistics collection:\n\n              notActive  collection of counters is not active.\n              active     collection of counters is active.\n\n           When this object is set to notActive, all of the entries are\n           removed from the appcSessStatsTable.')
appcCntrlAdminRscv = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCntrlAdminRscv.setDescription('Indicates the desired state of RSCV information collection:\n              notActive  collection of route selection control vectors\n                         is not active.\n              active     collection of route selection control vectors\n                         is active.')
appcCntrlAdminTrace = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCntrlAdminTrace.setDescription('Indicates the desired state of tracing:\n\n              notActive  collection of tracing information is not active\n              active     collection of tracing information is active')
appcCntrlAdminTraceParm = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCntrlAdminTraceParm.setDescription('Specifies the parameter to be used in conjunction with\n          activating tracing.  The actual content is implementation\n          dependent.')
appcCntrlOperGroup = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 2))
appcCntrlOperStat = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCntrlOperStat.setDescription("Indicates the current collection options in effect:\n\n              notActive  collection of counters is not active.\n              active     collection of counters is active.\n\n          Statistical entries are present in the appcSessStatsTable\n          only when the value of this object is 'active'.")
appcCntrlOperStatTime = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 2, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCntrlOperStatTime.setDescription('Time since the appcCntrlOperStat object last changed.\n           This time is in hundreds of a second.')
appcCntrlOperRscv = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCntrlOperRscv.setDescription('Indicates the current collection options in effect:\n\n              notActive  collection of route selection control vectors\n                         is not active.\n              active     collection of route selection control vectors\n                         is active.')
appcCntrlOperRscvTime = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 2, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCntrlOperRscvTime.setDescription('Time since the appcCntrlOperRscv object last changed.\n           This time is in hundreds of a second.')
appcCntrlOperTrace = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCntrlOperTrace.setDescription('Indicates the current state of tracing:\n\n              notActive  collection of tracing information is not active.\n              active     collection of tracing information is active.')
appcCntrlOperTraceTime = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 2, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCntrlOperTraceTime.setDescription('Time since the appcCntrlOperTrace object last changed.\n           This time is in hundreds of a second.')
appcCntrlOperTraceParm = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 2, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCntrlOperTraceParm.setDescription('Specifies the parameter used in conjunction with activating\n           tracing. The actual content is implementation dependent.')
appcGlobalObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3))
appcUpTime = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcUpTime.setDescription('The time, in hundredths of a second, since the\n          APPC portion of the system was last reinitialized.')
appcDefaultModeName = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcDefaultModeName.setDescription('Specifies the mode name to be used under the following\n           conditions:\n\n              When an incoming BIND request contains a mode name not\n              defined at the local node.  The parameters defined for\n              this mode are used for the inbound implicit mode\n              capability.\n\n              When an APPC program issues an [MC_]ALLOCATE,\n              [MC_]SEND_CONVERSATION, or CNOS verb, or when a CPI-C\n              program issues an Allocate (CMALLC) call,\n              specifying a mode name not defined at the local node.  The\n              parameters defined for this mode are used for the outbound\n              implicit mode capability.\n\n           This mode name must match a defined entry in the\n           appcModeAdminTable.')
appcDefaultLuName = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcDefaultLuName.setDescription('Specifies the name of the local LU that is to serve as the\n          default LU.  This is the default LU to which are routed inbound\n\n          BIND requests that exclude the secondary LU name.  This field\n          is from 1 to 17 characters in length, including a period (.)\n          which separates the NetId from the NAU name if the NetId is\n          present.  This local LU name must match a defined entry in the\n          appcLluAdminTable.')
appcDefaultImplInbndPlu = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("no", 1), ("yes", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcDefaultImplInbndPlu.setDescription('Specifies whether or not inbound implicit partner LU support\n          is enabled.  The following values are defined:\n\n              no   -  Specifies that inbound implicit partner LU support\n                      is disabled, which means that an incoming bind that\n                      specifies a partner LU that is not defined at the\n                      local node will be rejected.\n\n              yes  -  Specifies that inbound implicit partner LU support\n                      is enabled, which provides the capability to accept\n                      an incoming BIND request that contains a partner LU\n                      name that is not defined at the local node.')
appcDefaultMaxMcLlSndSize = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcDefaultMaxMcLlSndSize.setDescription('Specifies the maximum size of a logical record to be used for\n          a mapped conversation when sending data to either the inbound\n          or outbound implicit partner LU.  This size is the maximum\n          number of bytes in a single logical record, as indicated in the\n          LL field of the record.  The default value is 32767.\n\n          Note that this object does not limit the maximum size that an\n          application program can supply on the Send Data call for a\n          mapped conversation.')
appcDefaultFileSpec = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcDefaultFileSpec.setDescription("The local file specification that is to be searched by the\n           APPC attach manager when no DEFINE_TP verb has been issued\n           for the TP name received on an incoming attach.  In this\n           case, the attach manager will attempt to start a program\n           whose file name is the same as the incoming TP name.  If\n           found, the program is loaded. If not found, the attach is\n           rejected.\n\n           The value '*' indicates that the normal search path for\n           executable programs is to be used for locating an undefined\n           transaction program.\n\n           A null string indicates that there is no default file\n           specification for undefined transaction programs.")
appcDefaultTpOperation = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("other", 1), ("queuedOperatorStarted", 2), ("queuedOperatorPreloaded", 3), ("queuedAmStarted", 4), ("nonqueuedAmStarted", 5),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcDefaultTpOperation.setDescription('Specifies how the program will be started.\n\n              other - Specifies that the default TP operation is none of\n                      the methods specified below. It may be a\n                      product-specific method.\n\n              queuedOperatorStarted - Specifies that one version of the\n                      program will be run at a time.  If an incoming\n                      attach arrives and the program has not been started\n                      yet, APPC will issue a message to the operator to\n                      start the specified program.  Subsequent attaches\n                      that arrive while the program is active will be\n                      queued.\n\n              queuedOperatorPreloaded - Specifies that one version\n\n                      of the program will be run at a time.  If an\n                      incoming attach arrives and the program has not\n                      been started yet, the Attach will be rejected.  The\n                      APPC attach manager determines that a TP has\n                      started upon reception of an APPC RECEIVE_ALLOCATE\n                      verb, or a CPI-C Accept_Conversation (CMACCP) or\n                      Specify_Local_TP_Name (CMSLTP) call.  No message is\n                      sent to the operator.  Subsequent attaches that\n                      arrive while the program is active are queued.\n\n              queuedAmStarted - Specifies that one version of the\n                      program will be run at a time and will be started\n                      by the APPC attach manager.  Subsequent attaches\n                      that arrive while the program is active will be\n                      queued.\n\n              nonqueuedAmStarted - Specifies that multiple copies of\n                      the program will be run at a time and will be\n                      started by the APPC attach manager. ')
appcDefaultTpConvSecRqd = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("no", 1), ("yes", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcDefaultTpConvSecRqd.setDescription('Specifies whether or not conversation security will be used\n          for default TPs.\n\n              no   -  Specifies that the incoming attach does not have to\n                      contain security information.\n              yes  -  Specifies that the incoming attach must contain\n                      valid authentication information (e.g., user ID and\n                      password).')
appcLocalCpName = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLocalCpName.setDescription('Specifies the name of the local control point.  This field is\n          from 0 to 17 characters in length, including a period (.) which\n\n          separates the NetId from the NAU name if the NetId is present.\n          A null string indicates that the value is unknown.')
appcActiveSessions = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveSessions.setDescription('Specifies the total number of active APPC sessions supported\n          by this implementation.  Sessions for which both LUs are local\n          are counted twice.')
appcActiveHprSessions = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveHprSessions.setDescription('Specifies the total number of active HPR APPC sessions.')
appcCnosControl = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4))
appcCnosCommand = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("initSesslimit", 1), ("changeSesslimit", 2), ("resetSesslimit", 3),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCnosCommand.setDescription('Specifies the CNOS command or verb to issue.  First set the\n          values of the particular CNOS parameter objects (from the range\n          { appcCnosControl 2 } through { appcCnosControl 8 }) that apply\n          to the CNOS command to be executed, set the three CNOS target\n          objects ({ appcCnosControl 9 } through { appcCnosControl 11 }),\n          then set this object to the command to be executed.\n\n          Here is the list of parameter objects that must be set for each\n          of the CNOS commands:\n\n             INIT_SESSION_LIMIT -\n                appcCnosMaxSessLimit\n                appcCnosMinCwinLimit\n                appcCnosMinClosLimit\n                appcCnosTargetLocLuName\n                appcCnosTargetParLuName\n                appcCnosTargetModeName\n\n             CHANGE_SESSION_LIMIT -\n                appcCnosMaxSessLimit\n                appcCnosMinCwinLimit\n                appcCnosMinClosLimit\n                appcCnosResponsible\n                appcCnosTargetLocLuName\n                appcCnosTargetParLuName\n                appcCnosTargetModeName\n\n             RESET_SESSION_LIMIT -\n                appcCnosResponsible\n                appcCnosDrainPart\n                appcCnosForce\n                appcCnosTargetLocLuName\n                appcCnosTargetParLuName\n                appcCnosTargetModeName\n          ')
appcCnosMaxSessLimit = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCnosMaxSessLimit.setDescription('Specifies the maximum value that the local LU is to use,\n          during CNOS processing, for the session limit.  The local LU,\n          as a target LU, will negotiate a higher session limit it\n          receives in the CNOS request down to this maximum value.  The\n\n          local LU, as a source LU, will restrict the session limit it\n          sends in a CNOS request to a value less than or equal to this\n          maximum value.\n\n           If set (i.e., greater than 0), this overrides the maximum\n           session limit defined in the appcModeAdminTable.\n\n           This parameter should be set to the desired value before\n           setting the command (appcCnosCommand).\n\n           This parameter applies to the INITIALIZE_SESSION_LIMIT and\n           CHANGE_SESSION_LIMIT verbs.')
appcCnosMinCwinLimit = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCnosMinCwinLimit.setDescription('Specifies the default minimum contention winner sessions\n          limit.\n\n          This parameter should be set to the desired value before\n          setting the command (appcCnosCommand).\n\n          This parameter applies to the INITIALIZE_SESSION_LIMIT and\n          CHANGE_SESSION_LIMIT verbs.')
appcCnosMinClosLimit = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCnosMinClosLimit.setDescription('Specifies the default minimum contention loser sessions limit.\n\n           This parameter should be set to the desired value before\n           setting the command (appcCnosCommand).\n\n           This parameter applies to the INITIALIZE_SESSION_LIMIT and\n           CHANGE_SESSION_LIMIT verbs.')
appcCnosDrainSelf = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("no", 1), ("yes", 2),)).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCnosDrainSelf.setDescription('Specifies whether the local LU is draining its conversations\n          for this mode.  When a mode session limit is reset (via a CNOS\n          RESET_SESSION_LIMIT request), the local LU could be set to\n          process all queued conversations before deactivating all of the\n          sessions (using the SNA Bracket Initiation Stopped or BIS\n          protocol).\n\n          This parameter should be set to the desired value before\n          setting the command (appcCnosCommand).\n\n          This parameter applies only to the RESET_SESSION_LIMIT verb.')
appcCnosDrainPart = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("no", 1), ("yes", 2),)).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCnosDrainPart.setDescription('Specifies whether the partner LU is draining its conversations\n          for this mode.  When a mode session limit is reset (via a CNOS\n          RESET_SESSION_LIMIT request), the partner LU could be set to\n          process all queued conversations before deactivating all of the\n          sessions (using the SNA Bracket Initiation Stop or BIS\n          protocol).\n\n          This parameter should be set to the desired value before\n          setting the command (appcCnosCommand).\n\n          This parameter applies only to the RESET_SESSION_LIMIT verb.')
appcCnosResponsible = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("source", 1), ("target", 2),)).clone('source')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCnosResponsible.setDescription('Specifies which LU is responsible for selecting and\n          deactivating sessions as a result of a change that decreases\n          the session limit or the maximum number of contention winner\n          sessions for the source or target LU.  If no session need to be\n          deactivated, this parameter is ignored.\n\n                source  -       specifies that the source (local) LU is\n                                responsible.  The target (partner) LU\n                                cannot negotiate this value.\n                target  -       specifies that the target (partner) LU is\n                                responsible. The target LU can negotiate\n                                this value to source.\n\n           This parameter should be set to the desired value before\n           setting the command (appcCnosCommand).\n\n           This parameter applies to the RESET_SESSION_LIMIT and\n           CHANGE_SESSION_LIMIT verbs.')
appcCnosForce = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("no", 1), ("yes", 2),)).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCnosForce.setDescription('Specifies whether the local LU should force the resetting of\n          the session limit when certain error conditions occur that\n          prevent the successful exchange of CNOS request and reply.\n\n           This parameter should be set to the desired value before\n\n           setting the command (appcCnosCommand).\n\n           This parameter applies only to the RESET_SESSION_LIMIT verb.')
appcCnosTargetLocLuName = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCnosTargetLocLuName.setDescription('The SNA name of the local LU to which the CNOS command is\n           to be applied. This field is from 1 to 17 characters in\n           length, including a period (.) which separates the\n           NetId from the NAU name if the NetId is present.\n\n           This object should be set to the desired value before setting\n           the command (appcCnosCommand).\n\n           This parameter applies to all CNOS verbs.')
appcCnosTargetParLuName = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCnosTargetParLuName.setDescription('The SNA name of the partner LU to which the CNOS command is\n           to be applied. This field is from 1 to 17 characters in\n           length, including a period (.) which separates the\n           NetId from the NAU name if the NetId is present.\n\n           This object should be set to the desired value before setting\n           the command (appcCnosCommand).\n\n           This parameter applies to all CNOS verbs.')
appcCnosTargetModeName = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCnosTargetModeName.setDescription('Specifies the mode name to which the CNOS command is to be\n\n           applied.\n\n           This object should be set to the desired value before setting\n           the command (appcCnosCommand).\n\n           This parameter applies to all CNOS verbs.')
appcLluAdminTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1), )
if mibBuilder.loadTexts: appcLluAdminTable.setDescription('APPC Local LU Admin Table.')
appcLluAdminEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1, 1), ).setIndexNames((0, "APPC-MIB", "appcLluAdminName"))
if mibBuilder.loadTexts: appcLluAdminEntry.setDescription('Information about local APPC LUs. ')
appcLluAdminName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17)))
if mibBuilder.loadTexts: appcLluAdminName.setDescription('Specifies the name of the local LU.  This field is from 1 to\n          17 characters in length, including a period (.) which separates\n          the NetId from the NAU name if the NetId is present.')
appcLluAdminDepType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("dependent", 1), ("independent", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluAdminDepType.setDescription('This value identifies whether the LU is dependent or\n          independent.')
appcLluAdminLocalAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1,1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluAdminLocalAddress.setDescription('The local address for this LU is a byte with a value ranging\n          from 0 to 254.  For dependent LUs, this value ranges from 1 to\n\n          254; for independent LUs this value is always 0.')
appcLluAdminSessLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluAdminSessLimit.setDescription('The maximum number of sessions supported by this LU.')
appcLluAdminBindRspMayQ = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("no", 1), ("yes", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluAdminBindRspMayQ.setDescription('Indicates whether or not the local LU, as the sender of a BIND\n          request, allows a partner partner LU to delay sending the BIND\n          response if the partner LU cannot process the BIND request\n          immediately.')
appcLluAdminCompression = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("prohibited", 1), ("required", 2), ("negotiable", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluAdminCompression.setDescription('Specifies whether compression is supported. The local LU uses\n           this value for negotiation during session activation\n           (SNA BIND).\n\n              prohibited  -  specifies that no compression is to be used.\n              required    -  specifies that compression is required.\n              negotiable  -  specifies that the usage of compression\n                             is to be negotiated between the LUs. The\n                             level of compression is also negotiated.')
appcLluAdminInBoundCompLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("none", 1), ("rle", 2), ("lz9", 3), ("lz10", 4), ("lz12", 5),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluAdminInBoundCompLevel.setDescription('Specifies the maximum level of compression supported for\n          inbound data.  The local LU uses this value in conjunction with\n          appcLluAdminCompression for negotiation during session\n          activation (SNA BIND).\n              none  -  specifies that no compression is to be used.\n              rle   -  specifies run-length encoding compression\n                       in which a 1 or 2 byte sequence substitution is\n                       used for each repeated run of the same character.\n              lz9   -  specifies Lempel-Ziv-like compression in which\n                       9 bit codes are used to substitute repeated\n                       substrings in the data stream.  These codes are\n                       indices that refer to entries in a common\n                       dictionary generated adaptively at both sender and\n                       receiver as the data flows and compression occurs.\n                       The larger number bits used for the code, the more\n                       storage space is required for the dictionary, but\n                       the larger the compression ratio.\n              lz10  -  specifies a 10 bit code Lempel-Ziv-like compression.\n              lz12  -  specifies a 12 bit code Lempel-Ziv-like compression.')
appcLluAdminOutBoundCompLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("none", 1), ("rle", 2), ("lz9", 3), ("lz10", 4), ("lz12", 5),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluAdminOutBoundCompLevel.setDescription('Specifies the maximum level of compression supported for\n          outbound data.  The local LU uses this value in conjunction\n          with appcLluAdminCompression for negotiation during session\n          activation (SNA BIND).\n\n              none  -  specifies that no compression is to be used.\n              rle   -  specifies run-length encoding compression\n                       in which a 1 or 2 byte sequence substitution is\n                       used for each repeated run of the same character.\n              lz9   -  specifies Lempel-Ziv-like compression in which\n                       9 bit codes are used to substitute repeated\n                       substrings in the data stream.  These codes are\n                       indices that refer to entries in a common\n                       dictionary generated adaptively at both sender and\n                       receiver as the data flows and compression occurs.\n                       The larger of number bits used for the code, the\n                       more storage space is required for the dictionary,\n                       but the larger the compression ratio.\n              lz10  -  specifies a 10 bit code Lempel-Ziv-like compression.\n              lz12  -  specifies a 12 bit code Lempel-Ziv-like compression.')
appcLluAdminCompRleBeforeLZ = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("no", 1), ("yes", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluAdminCompRleBeforeLZ.setDescription('Specifies whether run-length encoding is to be applied to the\n          data before applying Lempel-Ziv-like compression.  The local LU\n          uses this value for negotiation during session activation (SNA\n          BIND).  This parameter is only supported if LZ compression is\n          used.')
appcLluAdminAlias = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluAdminAlias.setDescription('A local alias for the local LU.  If not known or\n           not applicable, this object contains a zero-length\n           string.')
appcLluOperTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2), )
if mibBuilder.loadTexts: appcLluOperTable.setDescription('APPC Local LU Operational Table.')
appcLluOperEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1), ).setIndexNames((0, "APPC-MIB", "appcLluOperName"))
if mibBuilder.loadTexts: appcLluOperEntry.setDescription('Information about local APPC LUs.')
appcLluOperName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17)))
if mibBuilder.loadTexts: appcLluOperName.setDescription('Specifies the name of the local LU.  This field is from 1 to\n          17 characters in length, including a period (.) which separates\n          the NetId from the NAU name if the NetId is present.')
appcLluOperDepType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("dependent", 1), ("independent", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluOperDepType.setDescription('This value identifies whether the LU is dependent or\n          independent.')
appcLluOperLocalAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1,1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluOperLocalAddress.setDescription('The local address for this LU is a byte with a value ranging\n          from 0 to 254.  For dependent LUs, this value ranges from 1 to\n          254; for independent LUs this value is always 0.')
appcLluOperSessLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluOperSessLimit.setDescription('The maximum number of sessions supported by this LU.')
appcLluOperBindRspMayQ = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("no", 1), ("yes", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluOperBindRspMayQ.setDescription('Indicates whether or not the local LU, as the sender of a BIND\n          request, allows a partner LU to delay sending the BIND\n          response if the partner LU cannot process the BIND request\n          immediately.')
appcLluOperCompression = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("prohibited", 1), ("required", 2), ("negotiable", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluOperCompression.setDescription('Specifies whether compression is supported.  The local LU uses\n          this value for negotiation during session activation (SNA\n          BIND).\n\n              prohibited  -  specifies that no compression is to be used.\n              required    -  specifies that compression is required.\n              negotiable  -  specifies that the usage of compression\n                             is to be negotiated between the LUs. The\n                             level of compression is also negotiated.')
appcLluOperInBoundCompLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("none", 1), ("rle", 2), ("lz9", 3), ("lz10", 4), ("lz12", 5),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluOperInBoundCompLevel.setDescription('Specifies the maximum level of compression supported for\n          inbound data.  The local LU uses this value in conjunction with\n          appcLluOperCompression for negotiation during session\n          activation (SNA BIND).\n\n              none  -  specifies that no compression is to be used.\n              rle   -  specifies run-length encoding compression\n                       in which a 1 or 2 byte sequence substitution is\n                       used for each repeated run of the same character.\n              lz9   -  specifies Lempel-Ziv-like compression in which\n                       9 bit codes are used to substitute repeated\n                       substrings in the data stream.  These codes are\n                       indices that refer to entries in a common\n                       dictionary generated adaptively at both sender and\n                       receiver as the data flows and compression occurs.\n                       The larger of number bits used for the code, the\n\n                       more storage space is required for the dictionary,\n                       but the larger the compression ratio.\n              lz10  -  specifies a 10 bit code Lempel-Ziv-like compression.\n              lz12  -  specifies a 12 bit code Lempel-Ziv-like compression.')
appcLluOperOutBoundCompLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("none", 1), ("rle", 2), ("lz9", 3), ("lz10", 4), ("lz12", 5),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluOperOutBoundCompLevel.setDescription('Specifies the maximum level of compression supported for\n          outbound data.  The local LU uses this value in conjunction\n          with appcLluAdminCompression for negotiation during session\n          activation (SNA BIND).\n\n              none  -  specifies that no compression is to be used.\n              rle   -  specifies run-length encoding compression\n                       in which a 1 or 2 byte sequence substitution is\n                       used for each repeated run of the same character.\n              lz9   -  specifies Lempel-Ziv-like compression in which\n                       9 bit codes are used to substitute repeated\n                       substrings in the data stream.  These codes are\n                       indices that refer to entries in a common\n                       dictionary generated adaptively at both sender and\n                       receiver as the data flows and compression occurs.\n                       The larger of number bits used for the code, the\n                       more storage space is required for the dictionary,\n                       but the larger the compression ratio.\n              lz10  -  specifies a 10 bit code Lempel-Ziv-like compression.\n              lz12  -  specifies a 12 bit code Lempel-Ziv-like compression.')
appcLluOperCompRleBeforeLZ = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("no", 1), ("yes", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluOperCompRleBeforeLZ.setDescription('Specifies whether run-length encoding is to be applied to the\n          data before applying Lempel-Ziv-like compression.  The local LU\n          uses this value for negotiation during session activation (SNA\n          BIND).  This parameter is only supported if LZ compression is\n          used.')
appcLluOperAlias = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluOperAlias.setDescription('A local alias for the local LU.  If not known or\n           not applicable, this object contains a zero-length\n           string.')
appcLluOperActiveSessions = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluOperActiveSessions.setDescription('Specifies the total number of active APPC sessions for this\n          LU.')
appcLuPairAdminTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 3), )
if mibBuilder.loadTexts: appcLuPairAdminTable.setDescription('APPC Partner LU administrative Table')
appcLuPairAdminEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 3, 1), ).setIndexNames((0, "APPC-MIB", "appcLuPairAdminLocLuName"), (0, "APPC-MIB", "appcLuPairAdminParLuName"))
if mibBuilder.loadTexts: appcLuPairAdminEntry.setDescription('Entry of APPC Partner LU Information Table.\n          It is indexed by the local and partner LU Names.')
appcLuPairAdminLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17)))
if mibBuilder.loadTexts: appcLuPairAdminLocLuName.setDescription("The SNA name of the local LU to which this partner LU\n           definition applies. This field is from 1 to 17 characters in\n           length, including a period (.) which separates the\n           NetId from the NAU name if the NetId is present.\n\n           The reserved value '*ALL' indicates that the partner LU\n           definition applies to all local LUs, and not just to a single\n           local LU.")
appcLuPairAdminParLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17)))
if mibBuilder.loadTexts: appcLuPairAdminParLuName.setDescription('The SNA name of the partner LU.\n           This field is from 1 to 17 characters in\n           length, including a period (.) which separates the\n           NetId from the NAU name if the NetId is present.')
appcLuPairAdminParLuAlias = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairAdminParLuAlias.setDescription('A local alias for the partner LU.  If not known or\n           not applicable, this object contains a zero-length\n           string.')
appcLuPairAdminSessLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairAdminSessLimit.setDescription('The maximum number of sessions supported by this partner LU.')
appcLuPairAdminSessSec = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("required", 1), ("accepted", 2), ("notAllowed", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairAdminSessSec.setDescription('Specifies the type of session-level security information that\n          a local LU will accept on BIND requests it receives from the\n          partner LU.\n\n          required    -   Specifies that the BIND request must carry\n                          session level verification information that\n                          will be verified upon receipt.\n          accepted    -   Specifies that the BIND request may carry\n                          session level verification information that\n                          will be verified upon receipt.\n          notAllowed  -   Specifies that the BIND request must not carry\n                          session level verification information.')
appcLuPairAdminSecAccept = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("none", 1), ("conversation", 2), ("alreadyVerified", 3), ("persistentVerification", 4), ("aVandpV", 5),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairAdminSecAccept.setDescription('Specifies support for different levels of access security\n           information in ATTACH requests received from this partner LU.\n\n           Possible values are:\n\n                none    -   No access security information will be\n                            accepted on allocation requests (ATTACH) from\n                            this LU.\n                conversation\n                        -   Allocation requests will not be accepted that\n                            include already verified or persistent\n                            verification indicators.  Accept\n                            conversation-level access security\n                            information, which must include both a user\n                            Id and password, and may also include a\n                            profile.\n                alreadyVerified\n                        -   Allocation requests will be accepted that\n                            include already verified indicators.\n                            Persistent verification indicators will not\n                            be accepted.\n                persistentVerification\n                        -   Allocation requests will be accepted that\n                            include persistent verification indicators.\n                            Already verified indicators will not be\n                            accepted.\n                aVandpV -   Allocation requests will be accepted that\n                            include already verified or persistent\n                            verification indicators.')
appcLuPairAdminLinkObjId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 3, 1, 7), InstancePointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairAdminLinkObjId.setDescription('Specifies the link associated with this partner LU.  This\n          value points to the row in the table containing information on\n\n          the link instance.  (e.g., the sdlcLSAdminTable of the SNA DLC\n          MIB module).  This object may be NULL if the link is not\n          specified or if a link is not applicable (as for APPN-level\n          nodes).')
appcLuPairAdminParaSessSup = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("no", 1), ("yes", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairAdminParaSessSup.setDescription('Defined Parallel Sessions Supported.\n\n          Indicates whether or not multiple sessions between the partner\n          LU and its associated local LU are permitted.  Parallel session\n          support also indicates that Change Number of Sessions (CNOS)\n          will be used to negotiate session limits between the LUs.')
appcLuPairOperTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4), )
if mibBuilder.loadTexts: appcLuPairOperTable.setDescription('Table of active partner/local LU pairs.  Two entries are\n          present in the table when both LUs in a pair are local.')
appcLuPairOperEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4, 1), ).setIndexNames((0, "APPC-MIB", "appcLuPairOperLocLuName"), (0, "APPC-MIB", "appcLuPairOperParLuName"))
if mibBuilder.loadTexts: appcLuPairOperEntry.setDescription('Entry representing one partner/local LU pair.')
appcLuPairOperLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17)))
if mibBuilder.loadTexts: appcLuPairOperLocLuName.setDescription('The SNA name of the local LU.  This field is from 1 to 17\n          characters in length, including a period (.) which separates\n          the NetId from the NAU name if the NetId is present.\n\n          If this object has the same value as appcLluOperName,\n          then the two entries being indexed apply to the same\n          resource (specifically, to the same local LU).')
appcLuPairOperParLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17)))
if mibBuilder.loadTexts: appcLuPairOperParLuName.setDescription('The SNA name of the partner LU.\n           This field is from 1 to 17 characters in\n           length, including a period (.) which separates the\n           NetId from the NAU name if the NetId is present.')
appcLuPairOperParLuAlias = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairOperParLuAlias.setDescription('A local alias for the partner LU.  If not known or\n           not applicable, this object contains a zero-length\n           string.')
appcLuPairOperSessLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairOperSessLimit.setDescription('The maximum number of sessions supported by this partner LU.')
appcLuPairOperSessSec = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("required", 1), ("accepted", 2), ("notAllowed", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairOperSessSec.setDescription('Specifies the type of security information that a local LU\n          will accept on BIND requests it receives from the partner LU.\n\n          required    -   Specifies that the BIND request must carry\n                          session level verification information that\n                          will be verified upon receipt.\n          accepted    -   Specifies that the BIND request may carry\n                          session level verification information that\n                          will be verified upon receipt.\n          notAllowed  -   Specifies that the BIND request must not carry\n                          session level verification information.')
appcLuPairOperSecAccept = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("none", 1), ("conversation", 2), ("alreadyVerified", 3), ("persistentVerification", 4), ("aVandpV", 5),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairOperSecAccept.setDescription('Specifies support for different levels of security acceptance\n           information in ATTACH requests received from this partner LU.\n\n           Possible values are:\n\n                none    -   No access security information will be\n                            accepted on allocation requests (ATTACH) from\n                            this LU.\n                conversation\n                        -   Allocation requests will not be accepted that\n                            include already verified or persistent\n                            verification indicators.  Accept\n                            conversation-level access security\n                            information, which must include both a user\n                            Id and password, and may also include a\n                            profile.\n                alreadyVerified\n                        -   Allocation requests will be accepted that\n                            include already verified indicators.\n                            Persistent verification indicators will not\n                            be accepted.\n                persistentVerification\n                        -   Allocation requests will be accepted that\n                            include persistent verification indicators.\n                            Already verified indicators will not be\n                            accepted.\n                aVandpV -   Allocation requests will be accepted that\n                            include already verified or persistent\n                            verification indicators.')
appcLuPairOperLinkObjId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4, 1, 7), InstancePointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairOperLinkObjId.setDescription('Specifies the link associated with this partner LU.  This\n          value points to the row in the table containing information on\n          the link instance.  (e.g., the sdlcLSAdminTable of the SNA DLC\n          MIB module).  This object may be NULL if the link is not\n          specified or if a link is not applicable (as for APPN-level\n          nodes).')
appcLuPairOperParaSessSup = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("no", 1), ("yes", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairOperParaSessSup.setDescription('Active Parallel Sessions Supported.\n\n           Indicates whether or not multiple session between the partner\n           LU and its associated local LU are permitted.  Parallel\n           session support also indicates that Change Number of Sessions\n           (CNOS) will be used to negotiate session limits between the\n           LUs.')
appcLuPairOperParaSessSupLS = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("no", 1), ("yes", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairOperParaSessSupLS.setDescription('Active Parallel Sessions Supported - last starting value.\n\n           This object represents the initial value proposed by the local\n           LU the last time this capability was negotiated, i.e., when\n           the first session was bound between the local LU and its\n           partner.')
appcLuPairOperState = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairOperState.setDescription('The value identifies the current operational state of this LU\n          pair:\n\n                  inactive (1) - no active or pending session exists\n                                 between the LUs.\n                  active (2)   - an active or pending session exists\n\n                                 between the LUs.')
appcModeAdminTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5), )
if mibBuilder.loadTexts: appcModeAdminTable.setDescription('APPC Mode Table')
appcModeAdminEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1), ).setIndexNames((0, "APPC-MIB", "appcModeAdminLocLuName"), (0, "APPC-MIB", "appcModeAdminParLuName"), (0, "APPC-MIB", "appcModeAdminModeName"))
if mibBuilder.loadTexts: appcModeAdminEntry.setDescription('Entry of APPC Mode Information Table.')
appcModeAdminLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17)))
if mibBuilder.loadTexts: appcModeAdminLocLuName.setDescription("The SNA name of the local LU to which this mode definition\n           applies.  This field is from 1 to 17 characters in length,\n           including a period (.)  which separates the NetId from the\n           NAU name if the NetId is present.\n\n           The reserved value '*ALL' indicates that the mode definition\n           applies to all local LUs for the SNA node identified by\n           appcLocalCpName, and not just to a single local LU.")
appcModeAdminParLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17)))
if mibBuilder.loadTexts: appcModeAdminParLuName.setDescription("The SNA name of the partner LU to which this mode definition\n           applies.  This field is from 1 to 17 characters in length,\n           including a period (.) which separates the NetId from the\n           NAU name if the NetId is present.\n\n           The reserved value '*ALL' indicates that the mode definition\n           applies to all partner LUs for the SNA node identified by\n           appcModeAdminLocLuName, and not just to a single partner LU.")
appcModeAdminModeName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,8)))
if mibBuilder.loadTexts: appcModeAdminModeName.setDescription('Specifies the mode name. A mode defines the characteristics\n           for a group of sessions. The mode name can be blank (8\n           space characters). ')
appcModeAdminCosName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminCosName.setDescription('Specifies the class of service (COS) name associated with\n           this mode.  If the implementation does not support COS names,\n           a null string is returned.')
appcModeAdminSessEndTpName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminSessEndTpName.setDescription("Specifies the name of the transaction program (TP) to be\n          invoked when a session using this mode is deactivated or ended.\n          If no such TP is defined, this object is a null string.  When\n          the TP name consists entirely of displayable EBCDIC code\n          points, it is mapped directly to the equivalent ASCII display\n          string.  However, registered TP names always have a non-\n          displayable EBCDIC code point (value less than or equal to\n          x'3F') as the first character, so they cannot be directly\n          mapped to an ASCII display string.  These TP names are\n          converted to a display string that is equivalent to a\n          hexadecimal display of the EBCDIC code points.  For example,\n          the 2-byte TP name x'06F1' (CNOS) is converted to the 6-byte\n          ASCII display string '06F1' (including the two single quotes).\n          ")
appcModeAdminMaxSessLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminMaxSessLimit.setDescription('Specifies the maximum value that the local LU is to use,\n          during CNOS processing, for the session limit.  The local LU,\n          as a target LU, will negotiate a higher session limit it\n\n          receives in the CNOS request down to this maximum value.  The\n          local LU, as a source LU, will restrict the session limit it\n          sends in a CNOS request to a value less than or equal to this\n          maximum value.')
appcModeAdminMinCwinLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminMinCwinLimit.setDescription('Specifies the default minimum contention winner sessions\n          limit.  Some implementations internally issue a\n          INITIALIZE_SESSION_LIMIT verb when a Mode is created.  This\n          value is the parameter used for the CNOS processing of that\n          verb.  This parameter is not used when issuing an explicit\n          INITIALIZE_SESSION_LIMIT verb.  The equivalent object in\n          appcCnosCommandTable is used.')
appcModeAdminMinClosLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminMinClosLimit.setDescription('Specifies the default minimum contention loser sessions limit.\n          Some implementations internally issue a\n          INITIALIZE_SESSION_LIMIT verb when a Mode is created.  This\n          value is the parameter used for the CNOS processing of that\n          verb.  This is the same as target minimum contention winner\n          sessions.  This parameter is not used when issuing an explicit\n          INITIALIZE_SESSION_LIMIT verb.  The equivalent object in\n          appcCnosCommandTable is used.')
appcModeAdminConWinAutoActLmt = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminConWinAutoActLmt.setDescription('Specifies the limit on the number of contention winner\n          sessions to be automatically activated when the minimum number\n          of contention winner sessions increases (as a result of CNOS\n          processing).  The actual number of sessions activated is the\n          lesser of this value and the new minimum number of contention\n          winner sessions.  ')
appcModeAdminRecvPacWinSz = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminRecvPacWinSz.setDescription('Specifies the size of the receive pacing window. This value is\n           used for negotiation during session activations (SNA BIND).\n\n           The meaning of this value when set to 0 depends on whether\n           adaptive pacing is supported:\n              adaptive pacing        No limit on window size\n              fixed pacing           No pacing is supported')
appcModeAdminSendPacWinSz = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminSendPacWinSz.setDescription('Specifies the size of the send pacing window. This value is\n           used for negotiation during session activations (SNA BIND).\n\n           The meaning of this value when set to 0 depends on whether\n           adaptive pacing is supported:\n              adaptive pacing        No limit on window size\n              fixed pacing           No pacing is supported')
appcModeAdminPrefRecvRuSz = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminPrefRecvRuSz.setDescription('Specifies the preferred receive RU (Request Unit) size of\n          normal-flow requests on the sessions.  This value must be less\n          than or equal to the value specified in\n          appcModeAdminRecvRuSzUpBnd and greater than or equal to the\n          value specified in appcModeAdminRecvRuSzLoBnd.\n\n           The local LU specifies this value for the receive maximum RU\n           size in session activation (SNA BIND) requests and responses.\n           It will allow negotiation up to the appcModeAdminRecvRuSzUpBnd\n           value or down to the appcModeAdminRecvRuSzLoBnd value.')
appcModeAdminPrefSendRuSz = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminPrefSendRuSz.setDescription('Specifies the preferred send RU (Request Unit) size of normal-\n          flow requests on the sessions.  This value must be less than or\n          equal to the value specified in appcModeAdminSendRuSzUpBnd and\n          greater than or equal to the value specified in\n          appcModeAdminSendRuSzLoBnd.\n\n           The local LU specifies this value for the send maximum RU\n           size in session activation (SNA BIND) requests and responses.\n           It will allow negotiation up to the appcModeAdminSendRuSzUpBnd\n           value or down to the appcModeAdminSendRuSzLoBnd value.')
appcModeAdminRecvRuSzUpBnd = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminRecvRuSzUpBnd.setDescription('Specifies the upper bound for the maximum receive RU\n           (Request Unit) size of normal-flow requests. This is used\n           for negotiation during session activations (SNA BIND). ')
appcModeAdminSendRuSzUpBnd = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminSendRuSzUpBnd.setDescription('Specifies the upper bound for the maximum send RU (Request\n          Unit) size of normal-flow requests.  This is used for\n          negotiation during session activations (SNA BIND).  ')
appcModeAdminRecvRuSzLoBnd = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminRecvRuSzLoBnd.setDescription('Specifies the lower bound for the maximum receive RU (Request\n\n          Unit) size of normal-flow requests.  This is used for\n          negotiation during session activations (SNA BIND).  ')
appcModeAdminSendRuSzLoBnd = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminSendRuSzLoBnd.setDescription('Specifies the lower bound for the maximum send RU (Request\n          Unit) size of normal-flow requests.  This is used for\n          negotiation during session activations (SNA BIND).  ')
appcModeAdminSingSessReinit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("notApplicable", 1), ("operatorControlled", 2), ("primaryOnly", 3), ("secondaryOnly", 4), ("primaryOrSecondary", 5),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminSingSessReinit.setDescription('Specifies the responsibility for session reinitiation of a\n          single session with the partner LU (when the session goes\n          down).  The local LU uses this parameter to specify the session\n          reinitiation responsibility in session activation (SNA BIND)\n          requests and responses.\n\n                notApplicable      - specifies that this parameter has\n                                     no meaning since the value of\n                                     appcLuPairAdminParaSessSup is yes.\n                                     The field in the SNA BIND is\n                                     reserved (set to zero).\n                operatorControlled - specifies that neither LU will\n                                     automatically attempt to reinitiate\n                                     the session.  The operator on either\n                                     side will manually reactivate the\n                                     session.  A contention race (both\n                                     side reinitiating at the same time)\n                                     is won by the LU with the\n                                     lexicographically greater fully-\n                                     qualified LU name.\n                primaryOnly        - specifies that the primary LU will\n\n                                     automatically attempt to reinitiate\n                                     the session.\n                secondaryOnly      - specifies that the secondary LU will\n                                     automatically attempt to reinitiate\n                                     the session.\n                primaryOrSecondary - specifies that either the primary or\n                                     the secondary may automatically\n                                     attempt to reinitiate the session.\n                                     A contention race is handled the\n                                     same way as with operatorControlled.\n          ')
appcModeAdminCompression = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("prohibited", 1), ("required", 2), ("negotiable", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminCompression.setDescription('Specifies whether compression is supported.  The local LU uses\n          this value for negotiation during session activation (SNA\n          BIND).\n\n              prohibited  -  specifies that no compression is to be used.\n              required    -  specifies that compression is required.\n              negotiable  -  specifies that the usage of compression\n                             is to be negotiated between the LUs. The\n                             level of compression is also negotiated.')
appcModeAdminInBoundCompLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("none", 1), ("rle", 2), ("lz9", 3), ("lz10", 4), ("lz12", 5),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminInBoundCompLevel.setDescription('Specifies the maximum level of compression supported for\n          inbound data.  The local LU uses this value in conjunction with\n          appcModeAdminCompression for negotiation during session\n\n          activation (SNA BIND).\n\n              none  -  specifies that no compression is to be used.\n              rle   -  specifies run-length encoding compression\n                       in which a 1 or 2 byte sequence substitution is\n                       used for each repeated run of the same character.\n              lz9   -  specifies Lempel-Ziv-like compression in which\n                       9 bit codes are used to substitute repeated\n                       substrings in the data stream.  These codes are\n                       indices that refer to entries in a common\n                       dictionary generated adaptively at both sender and\n                       receiver as the data flows and compression occurs.\n                       The larger of number bits used for the code, the\n                       more storage space is required for the dictionary,\n                       but the larger the compression ratio.\n              lz10  -  specifies a 10 bit code Lempel-Ziv-like compression.\n              lz12  -  specifies a 12 bit code Lempel-Ziv-like compression.')
appcModeAdminOutBoundCompLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("none", 1), ("rle", 2), ("lz9", 3), ("lz10", 4), ("lz12", 5),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminOutBoundCompLevel.setDescription('Specifies the maximum level of compression supported for\n          outbound data.  The local LU uses this value in conjunction\n          with appcModeAdminCompression for negotiation during session\n          activation (SNA BIND).\n\n              none  -  specifies that no compression is to be used.\n              rle   -  specifies run-length encoding compression\n                       in which a 1 or 2 byte sequence substitution is\n                       used for each repeated run of the same character.\n              lz9   -  specifies Lempel-Ziv-like compression in which\n                       9 bit codes are used to substitute repeated\n                       substrings in the data stream.  These codes are\n                       indices that refer to entries in a common\n                       dictionary generated adaptively at both sender and\n                       receiver as the data flows and compression occurs.\n                       The larger of number bits used for the code, the\n                       more storage space is required for the dictionary,\n\n                       but the larger the compression ratio.\n              lz10  -  specifies a 10 bit code Lempel-Ziv-like compression.\n              lz12  -  specifies a 12 bit code Lempel-Ziv-like compression.')
appcModeAdminCompRleBeforeLZ = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("no", 1), ("yes", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminCompRleBeforeLZ.setDescription('Specifies whether run-length encoding is to be applied to the\n          data before applying Lempel-Ziv-like compression.  The local LU\n          uses this value for negotiation during session activation (SNA\n          BIND).  This parameter is only supported if LZ compression is\n          used.')
appcModeAdminSyncLvl = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("none", 1), ("noneConfirm", 2), ("noneConfirmSyncPoint", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminSyncLvl.setDescription('Specifies the sync level support. This value is used for\n           negotiation during session activations (SNA BIND).\n\n                none                 - No sync level is supported.\n                noneConfirm          - None and Confirm levels supported.\n                noneConfirmSyncPoint - None, Confirm, and Sync Point is\n                                       supported.\n          ')
appcModeAdminCrypto = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("notSupported", 1), ("mandatory", 2), ("selective", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminCrypto.setDescription('Specifies whether session-level cryptography is supported.\n           This value is used for negotiation during session activations\n           (SNA BIND).\n                notSupported    -   Specifies session-level cryptography\n                                    is not to be used.\n                mandatory       -   Specifies session-level cryptography\n                                    must be used.\n                selective       -   Specifies session-level cryptography\n                                    is required just on selected requests\n                                    flowing on the sessions.')
appcModeOperTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6), )
if mibBuilder.loadTexts: appcModeOperTable.setDescription('Operational APPC Mode Information.  Two entries are present in\n          the table when both LUs in a pair are local.')
appcModeOperEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1), ).setIndexNames((0, "APPC-MIB", "appcModeOperLocLuName"), (0, "APPC-MIB", "appcModeOperParLuName"), (0, "APPC-MIB", "appcModeOperModeName"))
if mibBuilder.loadTexts: appcModeOperEntry.setDescription('Entry of APPC mode operational information table.  This entry\n          does not augment the appcModeAdminEntry, but reflects an actual\n          operational mode for a given local LU - partner LU pair.')
appcModeOperLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17)))
if mibBuilder.loadTexts: appcModeOperLocLuName.setDescription('The SNA name of the local LU.  This field is from 1 to 17\n          characters in length, including a period (.) which separates\n          the NetId from the NAU name if the NetId is present.\n\n          If this object has the same value as appcLluOperName,\n          then the two entries being indexed apply to the same\n          resource (specifically, to the same local LU).')
appcModeOperParLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17)))
if mibBuilder.loadTexts: appcModeOperParLuName.setDescription('The SNA name of the partner LU.  This field is from 1 to 17\n          characters in length, including a period (.) which separates\n          the NetId from the NAU name if the NetId is present.\n\n          If this object has the same value as appcLuPairOperParLuName,\n          then the two entries being indexed apply to the same\n          resource (specifically, to the same partner LU).')
appcModeOperModeName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,8)))
if mibBuilder.loadTexts: appcModeOperModeName.setDescription('Specifies the mode name. A mode defines the characteristics\n           for a group of sessions. The mode name can be blank (8\n           space characters). ')
appcModeOperCosName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperCosName.setDescription('Specifies the class of service (COS) name associated with\n           this mode.  If the implementation does not support COS names,\n           a zero-length string is returned.')
appcModeOperSessEndTpName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperSessEndTpName.setDescription("Specifies the name of the transaction program (TP) to be\n          invoked when a session using this mode is deactivated or ended.\n          If the name is NULL, no transaction program is invoked.  When\n          the TP name consists entirely of displayable EBCDIC code\n          points, it is mapped directly to the equivalent ASCII display\n          string.  However, registered TP names always have a non-\n          displayable EBCDIC code point (value less than or equal to\n          x'3F') as the first character, so they cannot be directly\n          mapped to an ASCII display string.  These TP names are\n          converted to a display string that is equivalent to a\n          hexadecimal display of the EBCDIC code points.  For example,\n          the 2-byte TP name x'06F1' (CNOS) is converted to the 6-byte\n          ASCII display string '06F1' (including the two single quotes).")
appcModeOperSessLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperSessLimit.setDescription('Specifies the current session limit of this mode as negotiated\n          through APPC CNOS (Change Number of Sessions) processing.\n          Identifies the total number of sessions that can be established\n          between the local and partner LU using this mode.')
appcModeOperMaxSessLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperMaxSessLimit.setDescription('Specifies the maximum value that the local LU is to use,\n          during CNOS processing, for the session limit.  The local LU,\n          as a target LU, will negotiate a higher session limit it\n          receives in the CNOS request down to this maximum value.  The\n          local LU, as a source LU, will restrict the session limit it\n          sends in a CNOS request to a value less than or equal to this\n          maximum value.')
appcModeOperMinCwinLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperMinCwinLimit.setDescription('Specifies the minimum contention winner sessions limit that\n           was negotiated via CNOS processing.')
appcModeOperMinClosLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperMinClosLimit.setDescription('Specifies the minimum contention loser sessions limit that\n           was negotiated via CNOS processing. This is the same as\n           target minimum contention winner sessions.')
appcModeOperConWinAutoActLmt = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperConWinAutoActLmt.setDescription('Specifies the limit on the number of contention winner sessions\n          to be automatically activated when the minimum number of\n          contention winner sessions increases (as a result of CNOS\n          processing). The actual number of sessions activated is the\n          lesser of this value and the new minimum number of contention\n          winner sessions. ')
appcModeOperRecvPacWinSz = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperRecvPacWinSz.setDescription('Specifies the size of the receive pacing window. This value is\n           used for negotiation during session activations (SNA BIND).\n\n           The meaning of this value when set to 0 depends on whether\n           adaptive pacing is supported:\n              adaptive pacing   -     No limit on window size\n              fixed pacing      -     No pacing is supported')
appcModeOperSendPacWinSz = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperSendPacWinSz.setDescription('Specifies the size of the send pacing window. This value is\n           used for negotiation during session activations (SNA BIND).\n\n           The meaning of this value when set to 0 depends on whether\n           adaptive pacing is supported:\n              adaptive pacing        No limit on window size\n              fixed pacing           No pacing is supported')
appcModeOperPrefRecvRuSz = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperPrefRecvRuSz.setDescription('Specifies the preferred receive RU (Request Unit) size of\n          normal-flow requests on the sessions.  This value must be less\n          than or equal to the value specified in\n          appcModeOperRecvRuSzUpBnd and greater than or equal to the\n          value specified in appcModeOperRecvRuSzLoBnd.\n\n           The local LU specifies this value for the receive maximum RU\n           size in session activation (SNA BIND) requests and responses.\n           It will allow negotiation up to the appcModeOperRecvRuSzUpBnd\n           value or down to the appcModeOperRecvRuSzLoBnd value.')
appcModeOperPrefSendRuSz = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperPrefSendRuSz.setDescription('Specifies the preferred send RU (Request Unit) size of normal-\n          flow requests on the sessions.  This value must be less than or\n          equal to the value specified in appcModeOperSendRuSzUpBnd and\n          greater than or equal to the value specified in\n          appcModeOperSendRuSzLoBnd.\n\n           The local LU specifies this value for the send maximum RU\n           size in session activation (SNA BIND) requests and responses.\n           It will allow negotiation up to the appcModeOperSendRuSzUpBnd\n           value or down to the appcModeOperSendRuSzLoBnd value.')
appcModeOperRecvRuSzUpBnd = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperRecvRuSzUpBnd.setDescription('Specifies the upper bound for the maximum receive RU\n           (Request Unit) size of normal-flow requests. This is used\n           for negotiation during session activations (SNA BIND). ')
appcModeOperSendRuSzUpBnd = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperSendRuSzUpBnd.setDescription('Specifies the upper bound for the maximum send RU (Request\n          Unit) size of normal-flow requests.  This is used for\n          negotiation during session activations (SNA BIND).  ')
appcModeOperRecvRuSzLoBnd = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperRecvRuSzLoBnd.setDescription('Specifies the lower bound for the maximum receive RU\n           (Request Unit) size of normal-flow requests. This is used\n           for negotiation during session activations (SNA BIND). ')
appcModeOperSendRuSzLoBnd = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperSendRuSzLoBnd.setDescription('Specifies the lower bound for the maximum send RU\n           (Request Unit) size of normal-flow requests. This is used\n           for negotiation during session activations (SNA BIND). ')
appcModeOperSingSessReinit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("notApplicable", 1), ("operatorControlled", 2), ("primaryOnly", 3), ("secondaryOnly", 4), ("primaryOrSecondary", 5),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperSingSessReinit.setDescription('Specifies the responsibility for session reinitiation of a\n          single session with the partner LU (when the session goes\n          down).  The local LU uses this parameter to specify the session\n          reinitiation responsibility in session activation (SNA BIND)\n          requests and responses.\n\n                notApplicable      - specifies that this parameter has\n                                     no meaning since the value of\n                                     appcLuPairOperParaSessSup is yes.\n                                     The field in the SNA BIND is\n                                     reserved (set to zero).\n                operatorControlled - specifies that neither LU will\n                                     automatically attempt to reinitiate\n                                     the session.  The operator on either\n                                     side will manually reactivate the\n                                     session.  A contention race (both\n                                     side reinitiating at the same time)\n                                     is won by the LU with the\n                                     lexicographically greater fully-\n                                     qualified LU name.\n                primaryOnly        - specifies that the primary LU will\n                                     automatically attempt to reinitiate\n                                     the session.\n                secondaryOnly      - specifies that the secondary LU will\n                                     automatically attempt to reinitiate\n                                     the session.\n                primaryOrSecondary - specifies that either the primary or\n                                     the secondary may automatically\n                                     attempt to reinitiate the session.\n                                     A contention race is handled the\n                                     same way as with operatorControlled.\n          ')
appcModeOperCompression = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("prohibited", 1), ("required", 2), ("negotiable", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperCompression.setDescription('Specifies whether compression is supported.  The local LU uses\n          this value for negotiation during session activation (SNA\n          BIND).\n\n              prohibited  -  specifies that no compression is to be used.\n              required    -  specifies that compression is required.\n              negotiable  -  specifies that the usage of compression\n                             is to be negotiated between the LUs. The\n                             level of compression is also negotiated.')
appcModeOperInBoundCompLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("none", 1), ("rle", 2), ("lz9", 3), ("lz10", 4), ("lz12", 5),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperInBoundCompLevel.setDescription('Specifies the maximum level of compression supported for\n          inbound data.  The local LU uses this value in conjunction with\n          appcModeOperCompression for negotiation during session\n          activation (SNA BIND).\n\n              none  -  specifies that no compression is to be used.\n              rle   -  specifies run-length encoding compression\n                       in which a 1 or 2 byte sequence substitution is\n                       used for each repeated run of the same character.\n              lz9   -  specifies Lempel-Ziv-like compression in which\n                       9 bit codes are used to substitute repeated\n                       substrings in the data stream.  These codes are\n                       indices that refer to entries in a common\n                       dictionary generated adaptively at both sender and\n                       receiver as the data flows and compression occurs.\n                       The larger of number bits used for the code, the\n                       more storage space is required for the dictionary,\n                       but the larger the compression ratio.\n              lz10  -  specifies a 10 bit code Lempel-Ziv-like compression.\n              lz12  -  specifies a 12 bit code Lempel-Ziv-like compression.')
appcModeOperOutBoundCompLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("none", 1), ("rle", 2), ("lz9", 3), ("lz10", 4), ("lz12", 5),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperOutBoundCompLevel.setDescription('Specifies the maximum level of compression supported for\n          outbound data.  The local LU uses this value in conjunction\n          with appcModeOperCompression for negotiation during session\n          activation (SNA BIND).\n\n              none  -  specifies that no compression is to be used.\n              rle   -  specifies run-length encoding compression\n                       in which a 1 or 2 byte sequence substitution is\n                       used for each repeated run of the same character.\n              lz9   -  specifies Lempel-Ziv-like compression in which\n                       9 bit codes are used to substitute repeated\n                       substrings in the data stream.  These codes are\n                       indices that refer to entries in a common\n                       dictionary generated adaptively at both sender and\n                       receiver as the data flows and compression occurs.\n                       The larger of number bits used for the code, the\n                       more storage space is required for the dictionary,\n                       but the larger the compression ratio.\n              lz10  -  specifies a 10 bit code Lempel-Ziv-like compression.\n              lz12  -  specifies a 12 bit code Lempel-Ziv-like compression.')
appcModeOperCompRleBeforeLZ = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("no", 1), ("yes", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperCompRleBeforeLZ.setDescription('Specifies whether run-length encoding is to be applied to the\n          data before applying Lempel-Ziv-like compression.  The local LU\n          uses this value for negotiation during session activation (SNA\n          BIND).  This parameter is only supported if LZ compression is\n          used.')
appcModeOperSyncLvl = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("none", 1), ("noneConfirm", 2), ("noneConfirmSyncPoint", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperSyncLvl.setDescription('Specifies the sync level support for sessions involving this\n           LU pair and mode name.\n\n                none             -       No sync level is supported.\n                noneConfirm      -       None and Confirm level supported.\n                noneConfirmSyncPoint -   None, Confirm and Sync Point is\n                                                supported.\n          ')
appcModeOperCrypto = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("notSupported", 1), ("mandatory", 2), ("selective", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperCrypto.setDescription('Specifies whether session-level cryptography is supported for\n           sessions involving this LU pair and mode name.\n\n                notSupported    -   Specifies session-level cryptography\n                                       is not being used.\n                mandatory       -   Specifies session-level cryptography\n                                       in being used on all requests\n                                       flowing on the sessions.\n                selective       -   Specifies session-level cryptography\n                                       is required just on selected\n                                       requests flowing on the sessions.')
appcModeOperSyncLvlLastStart = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("none", 1), ("noneConfirm", 2), ("noneConfirmSyncPoint", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperSyncLvlLastStart.setDescription('Specifies the sync level support.  This value represents the\n          initial value proposed by the local LU the last time this\n          capability was negotiated, i.e., when the first session was\n          bound between the local LU and its partner.\n\n                none             -      No sync level is supported.\n                noneConfirm      -      None and Confirm level supported.\n                noneConfirmSyncPoint -  None, Confirm and Sync Point is\n                                            supported.\n          ')
appcModeOperCryptoLastStart = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("notSupported", 1), ("mandatory", 2), ("selective", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperCryptoLastStart.setDescription('Specifies whether session-level cryptography is supported.\n           This value represents the initial value proposed by the local\n           LU the last time this capability was negotiated, i.e., when\n           the first session was bound between the local LU and its\n           partner.\n                notSupported    -   Specifies session-level cryptography\n                                       is not to be used.\n                mandatory       -   Specifies session-level cryptography\n                                       must be used.\n                selective       -   Specifies session-level cryptography\n                                       is required just on selected\n                                       requests flowing on the sessions.')
appcModeOperCNOSNeg = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("no", 1), ("yes", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperCNOSNeg.setDescription('Specifies whether CNOS negotiation is in process.  CNOS\n          negotiation is used to set or change the various session limits\n          for a mode.')
appcModeOperActCwin = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 29), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperActCwin.setDescription('Specifies the number of active contention winner sessions.')
appcModeOperActClos = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 30), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperActClos.setDescription('Specifies the number of active contention loser sessions.')
appcModeOperPndCwin = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 31), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperPndCwin.setDescription('Specifies the number of contention winner sessions that are\n           pending activation.')
appcModeOperPndClos = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 32), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperPndClos.setDescription('Specifies the number of contention loser sessions that are\n           pending activation.')
appcModeOperPtmCwin = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 33), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperPtmCwin.setDescription('Specifies the number of contention winner sessions that are\n           pending termination.')
appcModeOperPtmClos = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 34), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperPtmClos.setDescription('Specifies the number of contention loser sessions that are\n           pending termination.')
appcModeOperDrainSelf = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("no", 1), ("yes", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperDrainSelf.setDescription('Specifies whether the local LU is draining its conversations\n          for this mode.  When a mode session limit is reset (via a CNOS\n          RESET_SESSION_LIMIT request), the local LU could be set to\n          process all queued conversations before deactivating all of the\n          sessions (using the SNA Bracket Initiation Stopped or BIS\n          protocol).  ')
appcModeOperDrainPart = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("no", 1), ("yes", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperDrainPart.setDescription('Specifies whether the partner LU is draining its conversations\n          for this mode.  When a mode session limit is reset (via a CNOS\n          RESET_SESSION_LIMIT request), the partner LU could be set to\n          process all queued conversations before deactivating all of the\n\n          sessions (using the SNA Bracket Initiation Stop or BIS\n          protocol).  ')
appcTpAdminTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1), )
if mibBuilder.loadTexts: appcTpAdminTable.setDescription('APPC Local TP Table')
appcTpAdminEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1), ).setIndexNames((0, "APPC-MIB", "appcTpAdminLocLuName"), (0, "APPC-MIB", "appcTpAdminTpName"))
if mibBuilder.loadTexts: appcTpAdminEntry.setDescription('Entry of APPC Local TP Information Table.')
appcTpAdminLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17)))
if mibBuilder.loadTexts: appcTpAdminLocLuName.setDescription("The SNA name of the local LU to which this TP definition\n           applies. This field is from 1 to 17 characters in length,\n           including a period (.) which separates the NetId from the NAU\n           name if the NetId is present.\n\n           The reserved value '*ALL' indicates that the TP definition\n           applies to all local LUs, and not just to a single local LU.")
appcTpAdminTpName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,64)))
if mibBuilder.loadTexts: appcTpAdminTpName.setDescription("The local transaction program name. This name is sent on an\n           ATTACH remote allocation request.\n\n           When the TP name consists entirely of displayable EBCDIC\n           code points, it is mapped directly to the equivalent ASCII\n           display string.  However, registered TP names always have a\n           non-displayable EBCDIC code point (value less than or equal to\n           x'3F') as the first character, so they cannot be directly\n           mapped to an ASCII display string.  These TP names are\n           converted to a display string that is equivalent to a\n           hexadecimal display of the EBCDIC code points.  For example,\n           the 2-byte TP name x'06F1' (CNOS) is converted to the 6-byte\n           ASCII display string '06F1' (including the two single quotes).")
appcTpAdminFileSpec = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminFileSpec.setDescription('The local file specification of the transaction program.\n          May be a zero-length string if not applicable.')
appcTpAdminStartParm = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminStartParm.setDescription('A parameter string passed to the transaction program when it\n           is started.  May be a zero-length string if not supported. ')
appcTpAdminTpOperation = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("other", 1), ("queuedOperatorStarted", 2), ("queuedOperatorPreloaded", 3), ("queuedAmStarted", 4), ("nonqueuedAmStarted", 5),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminTpOperation.setDescription('Specifies how the program will be started.\n              other - Specifies that the program operation is none of\n                      the methods specified. It may be a\n                      product-specific method.\n\n              queuedOperatorStarted - Specifies that one version of the\n                      program will be run at a time.  If an incoming\n                      attach arrives and the program has not been started\n                      yet, APPC will issue a message to the operator to\n                      start the specified program.  Subsequent attaches\n                      that arrive while the program is active will be\n                      queued.\n\n              queuedOperatorPreloaded - Specifies that one version of the\n                      program will be run at a time.  If an incoming\n                      attach arrives and the program has not been started\n                      yet, the Attach will be rejected.  The APPC attach\n                      manager determines that a TP has started upon\n                      reception of an APPC RECEIVE_ALLOCATE verb, or a\n                      CPI-C Accept_Conversation (CMACCP) or\n                      Specify_Local_TP_Name (CMSLTP) call.  No message is\n                      sent to the operator.  Subsequent attaches that\n                      arrive while the program is active are queued.\n\n              queuedAmStarted - Specifies that one version of the\n                      program will be run at a time and will be started\n                      by the APPC attach manager.  Subsequent attaches\n\n                      that arrive while the program is active will be\n                      queued.\n\n              nonqueuedAmStarted - Specifies that multiple copies of the\n                      program will be run at a time and will be started\n                      by the APPC attach manager.')
appcTpAdminInAttachTimeout = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminInAttachTimeout.setDescription('This object specifies the number of seconds incoming attaches\n          will be queued waiting for an APPC program to issue a\n          RECEIVE_ALLOCATE verb or for a CPI-C program to issue an\n          Accept_Conversation (CMACCP) call.  This parameter is\n          meaningful only when appcTpAdminTpOperation has one of the\n          following values:\n                     queuedOperatorStarted\n                     queuedOperatorPreloaded\n                     queuedAmStarted\n\n          A value of zero indicates that there is no timeout.')
appcTpAdminRcvAllocTimeout = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminRcvAllocTimeout.setDescription("This object specifies the number of seconds an APPC program's\n          RECEIVE_ALLOCATE verb or a CPI-C program's Accept_Conversation\n          (CMACCP) call will wait for an incoming attach to arrive.\n\n          A value of zero indicates that there is no timeout.")
appcTpAdminSyncLvl = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7,))).clone(namedValues=NamedValues(("none", 1), ("confirm", 2), ("noneAndConfirm", 3), ("syncpoint", 4), ("noneAndSyncpoint", 5), ("confirmAndSyncpoint", 6), ("all", 7),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminSyncLvl.setDescription('Indicates the synchronization level or levels that the\n          transaction program supports.  The levels are defined as\n          follows:\n\n               none      - allocation requests indicating a\n                           synchronization level of none are allowed to\n                           start the program.\n               confirm   - allocation requests indicating a\n                           synchronization level of confirm are allowed\n                           to start the program.\n               syncpoint - allocation requests indicating a\n                           synchronization level of sync point are\n                           allowed to start the program.')
appcTpAdminInstLmt = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminInstLmt.setDescription('The maximum number of concurrent instances of this transaction\n           program that will be supported for a local LU.  A value of\n           zero indicates that there is no limit.')
appcTpAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("enabled", 1), ("tempDisabled", 2), ("permDisabled", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminStatus.setDescription('Indicates the status of the TP relative to starting execution\n          when the local LU receives an allocation (ATTACH) request\n          naming this program.\n\n                enabled         -    the local LU can start the program.\n                tempDisabled    -    the local LU cannot start the\n\n                                     program. The local LU rejects the\n                                     request with an indication that the\n                                     TP is not available but retry is\n                                     possible.\n                permDisabled    -    the local LU cannot start the\n                                     program. The local LU rejects the\n                                     request with an indication that the\n                                     TP is not available and retry is\n                                     not possible.')
appcTpAdminLongRun = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("no", 1), ("yes", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminLongRun.setDescription('Indicates whether this is a long-running transaction program\n          (i.e., one that stays around even after the conversation goes\n          away).')
appcTpAdminConvType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("basic", 1), ("mapped", 2), ("basicOrMapped", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminConvType.setDescription('Specifies the conversation type (basic or mapped) that will be\n          used by the TP.  This value is verified upon receipt of an\n          incoming attach.  The acceptable values are:\n\n                 basic         - Indicates that this transaction program\n                                 supports basic conversations.\n\n                 mapped        - Indicates that this transaction program\n                                 supports mapped conversations.\n\n                 basicOrMapped - Indicates that this transaction program\n                                 supports both basic and mapped\n                                 conversations.')
appcTpAdminConvDuplex = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("half", 1), ("full", 2), ("halfOrFull", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminConvDuplex.setDescription('Specifies the conversation duplex type (half or full) that\n          will be used by the TP.  This value is verified upon receipt of\n          an incoming attach.  The acceptable values are:\n\n                 half       - Indicates that this transaction program\n                              supports half duplex conversations.\n\n                 full       - Indicates that this transaction program\n                              supports full duplex conversations.\n\n                 halfOrFull - Indicates that this transaction program\n                              supports either half or full duplex\n                              conversations.')
appcTpAdminConvSecReq = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("no", 1), ("yes", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminConvSecReq.setDescription('Indicates whether conversation-level security information is\n          required on incoming attaches designating this TP name.\n          Conversation-level security verification is always performed on\n          those requests that include security information.\n\n                 yes - Indicates that conversation-level security\n                       information is required.  ATTACHs designating the\n                       transaction program must carry a user_id and\n                       either a password or an already verified\n                       indicator.\n\n                 no  - Indicates that no security information is\n                       required.  ATTACHs designating the transaction\n\n                       program can omit or include security information.')
appcTpAdminVerPip = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("no", 1), ("yes", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminVerPip.setDescription('Specifies whether the number of PIP (Program Initialization\n           Parameters) subfields should be verified against the number\n           expected (appcTpAdminPipSubNum).')
appcTpAdminPipSubNum = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminPipSubNum.setDescription('Specifies the number of PIP subfields expected by the TP.')
appcActSessTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1), )
if mibBuilder.loadTexts: appcActSessTable.setDescription('Table of active APPC sessions.  Two entries are present in the\n          table when both session partners are local.')
appcActSessEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1), ).setIndexNames((0, "APPC-MIB", "appcActSessLocLuName"), (0, "APPC-MIB", "appcActSessParLuName"), (0, "APPC-MIB", "appcActSessIndex"))
if mibBuilder.loadTexts: appcActSessEntry.setDescription('Entry of APPC Session Information Table.  Indexed by LU pair\n          and integer-valued session index.')
appcActSessLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17)))
if mibBuilder.loadTexts: appcActSessLocLuName.setDescription('Specifies the name of the local LU for the session.  This\n          field is from 1 to 17 characters in length, including a period\n          (.) which separates the NetId from the NAU name if the NetId is\n\n          present.\n\n          If this object has the same value as appcLluOperName, then the\n          two entries being indexed apply to the same resource\n          (specifically, to the same local LU).')
appcActSessParLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17)))
if mibBuilder.loadTexts: appcActSessParLuName.setDescription('Specifies the name of the partner LU for the session.  This\n          field is from 1 to 17 characters in length, including a period\n          (.) which separates the NetId from the NAU name if the NetId is\n          present.\n\n          If this object has the same value as appcLuPairOperParLuName,\n          then the two entries being indexed apply to the same resource\n          (specifically, to the same partner LU).')
appcActSessIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 3), Integer32())
if mibBuilder.loadTexts: appcActSessIndex.setDescription('This value identifies the index of the session, which is\n          unique for this LU pair.  It is recommended that an Agent not\n          reuse the index of a deactivated session for a significant\n          period of time (e.g., one week).')
appcActSessPcidCpName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 4), DisplayString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0,0),ValueSizeConstraint(3,17),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessPcidCpName.setDescription('The network-qualified CP name of the node at which the session\n          and PCID originated.  For APPN and LEN nodes, this is either CP\n          name of the APPN node at which the origin LU is located or the\n          CP name of the NN serving the LEN node at which the origin LU\n          is located.  This field is from 3 to 17 characters in length,\n          including a period (.) which separates the NetId from the NAU\n          name.  A null string indicates that the value is unknown.')
appcActSessPcid = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 5), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0,0),ValueSizeConstraint(8,8),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessPcid.setDescription('The procedure correlation identifier (PCID) of a session.  It\n          is an 8-octet value assigned by the control point providing\n          session services for the primary LU.  A null string indicates\n          that the value is unknown.')
appcActSessPluIndicator = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("localLuIsPlu", 1), ("partnerLuIsPlu", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessPluIndicator.setDescription("Indicates which LU is the PLU for this session.  For\n          independent LUs, the PLU (primary LU) is the one that initiated\n          the session (sent BIND), while the SLU (secondary LU) is the\n          one that accepted the session initiation (received BIND).\n\n          The 'local' LU is the one identified by appcLluOperName.\n\n          The 'partner' LU is the one identified by\n          appcLuPairOperParLuName.")
appcActSessModeName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessModeName.setDescription('The mode name used for this session.')
appcActSessCosName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessCosName.setDescription('The Class of Service (COS) name used for this session.\n          A null string indicates that the value is unknown.')
appcActSessTransPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("unknown", 1), ("low", 2), ("medium", 3), ("high", 4), ("network", 5),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessTransPriority.setDescription('The transmission priority of this session.\n              1 = unknown priority\n              2 = low priority\n              3 = medium priority\n              4 = high priority\n              5 = network priority\n          ')
appcActSessEnhanceSecSup = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("none", 1), ("level1", 2), ("level2", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessEnhanceSecSup.setDescription('Enhanced security supported. Indicates the level of enhanced\n          security support:\n\n             1 = none\n             2 = level 1\n             3 = level 2\n          ')
appcActSessSendPacingType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("none", 1), ("fixed", 2), ("adaptive", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessSendPacingType.setDescription('The type of pacing being used for sending data.')
appcActSessSendRpc = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessSendRpc.setDescription('The send residual pace count.  This represents the number of\n          MUs that can still be sent in the current session window.')
appcActSessSendNxWndwSize = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessSendNxWndwSize.setDescription('The size of the next window which will be used to send data.')
appcActSessRecvPacingType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("none", 1), ("fixed", 2), ("adaptive", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessRecvPacingType.setDescription('The type of pacing being used for receiving data.')
appcActSessRecvRpc = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessRecvRpc.setDescription('The receive residual pace count.  This represents the number\n\n          of MUs that can still be received in the current session\n          window.')
appcActSessRecvNxWndwSize = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessRecvNxWndwSize.setDescription('The size of the next window which will be used to receive\n          data.')
appcActSessRscv = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0,255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessRscv.setDescription('The route selection control vector (RSCV CV2B) used for this\n          session.  It is present for APPN-level implementations.\n          LEN-level implementations will return a null string.  The\n          internal format of this vector is described in SNA Formats.\n          This object contains an uninterpreted copy of the control\n          vector (including the length and key fields).')
appcActSessInUse = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("no", 1), ("yes", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessInUse.setDescription('Specifies whether the session is currently in use (i.e., in\n           bracket with a conversation).')
appcActSessMaxSndRuSize = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessMaxSndRuSize.setDescription('The maximum RU size used on this session for sending RUs.')
appcActSessMaxRcvRuSize = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessMaxRcvRuSize.setDescription('The maximum RU size used on this session for receiving RUs.')
appcActSessSndPacingSize = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessSndPacingSize.setDescription('The size of the send pacing window on this session.')
appcActSessRcvPacingSize = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessRcvPacingSize.setDescription('The size of the receive pacing window on this session.')
appcActSessOperState = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4,))).clone(namedValues=NamedValues(("unbound", 1), ("pendingBind", 2), ("bound", 3), ("pendingUnbind", 4),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcActSessOperState.setDescription("The value indicates the current operational state of the\n          session.\n\n                  'unbound (1)' - session has been  unbound;\n                        in this state it will be removed from the\n                        session table by the Agent.\n\n                  'pendingBind (2)' - this state has different\n                        meanings for dependent and independent LUs;\n\n                        for dependent LU - waiting for BIND from\n                        the host, for independent LU - waiting for\n                        BIND response.  When a session enters this\n                        state, the corresponding entry in the\n                        session table is created by the Agent.\n\n                  'bound (3)' - session has been successfully bound.\n\n                  'pendingUnbind (4)' - session enters this state\n                        when an UNBIND is sent and before the\n                        rsp(UNBIND) is received.\n\n          Session deactivation:\n\n                  If a session is in the operational state\n                  'bound (3)' then setting the value of this\n                  object to 'unbound (1)' will initiate the\n                  session shutdown.\n\n                  If a session is in the operational state\n                  'pendingBind (2)' then setting the value of this\n                  object to 'unbound (1)' will initiate the session\n                  shutdown.\n\n                  If a session is in the operational state\n                  'pendingUnbind (4)' for an abnormally long period\n                  of time (e.g., three minutes) then setting the value\n                  of this object to 'unbound (1)' will change the\n                  session operational state to 'unbound (1)'. ")
appcActSessUpTime = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 24), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessUpTime.setDescription('The length of time the session has been active, measured in\n          hundredths of a second.')
appcActSessRtpNceId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0,8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessRtpNceId.setDescription('The local HPR Network Connection Endpoint of the session.')
appcActSessRtpTcid = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 26), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0,0),ValueSizeConstraint(8,8),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessRtpTcid.setDescription('The local RTP connection TCID of the session.')
appcActSessLinkIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 27), InstancePointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessLinkIndex.setDescription('This value identifies the link over which the session passes.\n          This value points to the row in the table containing\n          information on the link instance.  (e.g., the sdlcLSAdminTable\n          of the SNA DLC MIB module).  This object may be NULL if the\n          link is not specified or if a link is not applicable (as for\n          APPN-level nodes).')
appcSessStatsTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2), )
if mibBuilder.loadTexts: appcSessStatsTable.setDescription("This table contains dynamic statistical information relating\n          to active APPC sessions.  The entries in this table cannot be\n          created by a Management Station.  Two entries are present in\n          the table when both session partners are local.  This table is\n          populated only when the value of appcCntrlOperStat is\n          'active'.")
appcSessStatsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1), ).setIndexNames((0, "APPC-MIB", "appcSessStatsLocLuName"), (0, "APPC-MIB", "appcSessStatsParLuName"), (0, "APPC-MIB", "appcSessStatsSessIndex"))
if mibBuilder.loadTexts: appcSessStatsEntry.setDescription('Contains statistics information for an APPC session.  Each\n          entry is created by the Agent.  Objects in this table have\n          read-only access.  Each session from appcActSessTable has one\n          entry in this table.')
appcSessStatsLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17)))
if mibBuilder.loadTexts: appcSessStatsLocLuName.setDescription('Specifies the name of the local LU for the session.  This\n          field is from 1 to 17 characters in length, including a period\n          (.) which separates the NetId from the NAU name if the NetId is\n          present.\n\n          If this object has the same value as appcLluOperName, then the\n          two entries being indexed apply to the same resource\n          (specifically, to the same local LU).')
appcSessStatsParLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17)))
if mibBuilder.loadTexts: appcSessStatsParLuName.setDescription('Specifies the name of the partner LU for the session.  This\n          field is from 1 to 17 characters in length, including a period\n          (.) which separates the NetId from the NAU name if the NetId is\n          present.\n\n          If this object has the same value as appcLuPairOperParLuName,\n          then the two entries being indexed apply to the same resource\n          (specifically, to the same partner LU).')
appcSessStatsSessIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 3), Integer32())
if mibBuilder.loadTexts: appcSessStatsSessIndex.setDescription('This value identifies the index of the session, which is\n          unique for this LU pair.  It is recommended that an Agent not\n          reuse the index of a deactivated session for a significant\n          period of time (e.g., one week).\n\n          If this object has the same value as appcActSessIndex for the\n          same LU pair, then the two entries being indexed apply to the\n          same resource (specifically, to the same session).')
appcSessStatsSentFmdBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcSessStatsSentFmdBytes.setDescription('The number of function management data (FMD) bytes sent by the\n          local LU.')
appcSessStatsSentNonFmdBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcSessStatsSentNonFmdBytes.setDescription('The number of non-function management data (non-FMD) bytes\n          sent by the local LU.')
appcSessStatsRcvdFmdBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcSessStatsRcvdFmdBytes.setDescription('The number of function management data (FMD) bytes received by\n          the local LU.')
appcSessStatsRcvdNonFmdBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcSessStatsRcvdNonFmdBytes.setDescription('The number of non-function management data (non-FMD) bytes\n          received by the local LU.')
appcSessStatsSentFmdRus = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcSessStatsSentFmdRus.setDescription('The number of function management data (FMD) RUs sent by the\n          local LU.')
appcSessStatsSentNonFmdRus = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcSessStatsSentNonFmdRus.setDescription('The number of non-function management data (non-FMD) RUs sent\n          by the local LU.')
appcSessStatsRcvdFmdRus = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcSessStatsRcvdFmdRus.setDescription('The number of function management data (FMD) RUs received by\n          the local LU.')
appcSessStatsRcvdNonFmdRus = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcSessStatsRcvdNonFmdRus.setDescription('The number of non-function management data (non-FMD) RUs\n          received by the local LU.')
appcSessStatsCtrUpTime = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 12), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcSessStatsCtrUpTime.setDescription('The length of time the counters for this session have been\n          active, measured in hundredths of a second.')
appcHistSessTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3), )
if mibBuilder.loadTexts: appcHistSessTable.setDescription('Table of historical information about APPC sessions that\n          terminated abnormally.  Two entries may be present in the table\n          when both session partners are local.  It is an implementation\n          choice how long to retain information about a given session.')
appcHistSessEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3, 1), ).setIndexNames((0, "APPC-MIB", "appcHistSessIndex"))
if mibBuilder.loadTexts: appcHistSessEntry.setDescription('Entry of APPC Session History Table.  This table is indexed by\n          an integer which is continuously incremented until it\n          eventually wraps.')
appcHistSessIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647)))
if mibBuilder.loadTexts: appcHistSessIndex.setDescription('Table index.  The value of the index begins at zero\n           and is incremented up to a maximum value of 2**31-1\n           (2,147,483,647) before wrapping.')
appcHistSessTime = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3, 1, 2), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistSessTime.setDescription('The time at which the session was either terminated or\n           failed to be established.')
appcHistSessType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("recvNegBindRsp", 1), ("sendNegBindRsp", 2), ("sessActRejected", 3), ("unbindSent", 4), ("unbindReceived", 5),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistSessType.setDescription('Indicates the type of event that caused the entry to be made:\n\n               recvNegBindRsp  - Received a negative bind response from\n                                 the partner LU.\n               sendNegBindRsp  - Sent a negative bind response to the\n                                 partner LU.\n               sessActRejected - Session activation rejected by the\n                                 partner LU.\n               unbindSent      - Unbind sent to the partner LU.\n               unbindReceived  - Unbind received from the partner LU.\n\n          These event types correspond to the five SNA/MS Alerts\n          LU62001 through LU62005, documented in the SNA Management\n          Services Reference.')
appcHistSessLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistSessLocLuName.setDescription('The network-qualified local LU name.  This field is from 3 to\n          17 characters in length, including a period (.) which separates\n          the NetId from the NAU name if the NetId is present.')
appcHistSessParLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3,17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistSessParLuName.setDescription('The network-qualified partner LU name.  This field is from 3\n          to 17 characters in length, including a period (.) which\n          separates the NetId from the NAU name if the NetId is present.')
appcHistSessModeName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistSessModeName.setDescription('The mode name of the session.')
appcHistSessUnbindType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1,1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistSessUnbindType.setDescription('The type of unbind which terminated the session.  This\n           value is consists of one (1) octet; and its meaning\n           is defined in SNA Formats.')
appcHistSessSenseData = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3, 1, 8), SnaSenseData()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistSessSenseData.setDescription('The sense data associated with the termination of the\n          session, taken from the negative BIND response or UNBIND\n          request.')
appcHistSessComponentId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistSessComponentId.setDescription('The implementation-specific name of the component which\n          detected the problem.')
appcHistSessDetectModule = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistSessDetectModule.setDescription('The implementation-specific name of the module which\n          detected the problem.')
appcSessRtpTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 4), )
if mibBuilder.loadTexts: appcSessRtpTable.setDescription('A table indicating how many APPC sessions terminating in this\n          node are transported by each RTP connection.')
appcSessRtpEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 4, 1), ).setIndexNames((0, "APPC-MIB", "appcSessRtpNceId"), (0, "APPC-MIB", "appcSessRtpTcid"))
if mibBuilder.loadTexts: appcSessRtpEntry.setDescription('Entry of APPC session RTP table.')
appcSessRtpNceId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 4, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1,8)))
if mibBuilder.loadTexts: appcSessRtpNceId.setDescription('The local Network Connection Endpoint of the RTP connection.')
appcSessRtpTcid = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8,8)).setFixedLength(8))
if mibBuilder.loadTexts: appcSessRtpTcid.setDescription('The local TCID of the RTP connection.')
appcSessRtpSessions = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 4, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcSessRtpSessions.setDescription('The number of APPC sessions terminating in this node\n          that are using this RTP connection.')
appcActiveConvTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1), )
if mibBuilder.loadTexts: appcActiveConvTable.setDescription("Table of information about active APPC Conversations.  In this\n          context 'active' means that a conversation is currently\n          associated with a particular session.  Two entries are present\n          in the table when both LUs for the session are local.")
appcActiveConvEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1), ).setIndexNames((0, "APPC-MIB", "appcActiveConvLocLuName"), (0, "APPC-MIB", "appcActiveConvParLuName"), (0, "APPC-MIB", "appcActiveConvSessIndex"))
if mibBuilder.loadTexts: appcActiveConvEntry.setDescription('Entry representing one active APPC Conversation.')
appcActiveConvLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17)))
if mibBuilder.loadTexts: appcActiveConvLocLuName.setDescription('The SNA name of the local LU for the conversation.  This field\n          is from 1 to 17 characters in length, including a period (.)\n          which separates the NetId from the NAU name if the NetId is\n          present.\n\n          If this object has the same value as appcLluOperName,\n          then the two entries being indexed apply to the same\n          resource (specifically, to the same local LU).')
appcActiveConvParLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17)))
if mibBuilder.loadTexts: appcActiveConvParLuName.setDescription('The SNA name of the partner LU for the conversation.  This\n          field is from 1 to 17 characters in length, including a period\n          (.) which separates the NetId from the NAU name if the NetId is\n          present.\n\n          If this object has the same value as appcLuPairOperParLuName,\n          then the two entries being indexed apply to the same\n          resource (specifically, to the same partner LU).')
appcActiveConvSessIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 3), Integer32())
if mibBuilder.loadTexts: appcActiveConvSessIndex.setDescription('Index of entry in appcActSessTable that is associated with\n          this conversation.  If this object has the same value as\n          appcActSessIndex for the same LU pair, then the two entries\n          being indexed apply to the same resource (specifically, to the\n          same session).')
appcActiveConvId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4,4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvId.setDescription('The 4-byte ID of the conversation.')
appcActiveConvState = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,))).clone(namedValues=NamedValues(("reset", 1), ("send", 2), ("receive", 3), ("confirm", 4), ("confirmSend", 5), ("confirmDealloc", 6), ("pendingDeallocate", 7), ("pendingPost", 8), ("sendReceive", 9), ("sendOnly", 10), ("receiveOnly", 11), ("deferReceive", 12), ("deferDeallocate", 13), ("syncpoint", 14), ("syncpointSend", 15), ("syncpointDeallocate", 16), ("backoutRequired", 17),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvState.setDescription('Indicates the state of the conversation at the instant when\n          the information was retrieved.  The values are:\n\n              reset\n                        The conversation is reset (i.e., deallocated).\n              send\n                        The conversation can send data.  This value also\n                        is returned if the conversation is in\n                        Send-Pending state.\n              receive\n                        The conversation can receive data.\n              confirm\n                        The conversation has received a confirm\n                        indicator.  It can issue an [MC_]CONFIRMED or\n                        [MC_]SEND_ERROR verb to change state.  It will\n                        continue in Receive state if an [MC_]CONFIRMED\n                        verb is issued.\n              confirmSend\n                        The conversation is in Confirm state and changes\n                        to Send state when an [MC_]CONFIRMED verb is\n                        issued.\n              confirmDealloc\n                        The conversation is in Confirm state and becomes\n                        inactive when an [MC_]CONFIRMED verb is issued.\n              pendingDeallocate\n                        The conversation is in Pending-Deallocate state\n                        while it waits for (MC_)DEALLOCATE TYPE\n                        (sync_level) to complete.\n              pendingPost\n                        The conversation is in Pending-Post state while\n                        it waits for the [MC_]RECEIVE_AND_POST verb to\n                        complete its receive function.\n              sendReceive\n                        The full-duplex conversation can send or receive\n                        data.\n              sendOnly\n                        The full-duplex conversation can send data, but\n                        it does not have permission to receive data,\n                        because the partner TP has already deallocated\n                        its side of the conversation.\n              receiveOnly\n                        The full-duplex conversation can receive data,\n                        but it does not have permission to send data,\n                        because it has already deallocated its side of\n                        the conversation.\n              deferReceive\n                        Waiting for a successful SYNCPT verb operation to\n                        go into the receive state.\n              deferDeallocate\n                        Waiting for a successful SYNCPT verb operation to\n                        go into the reset state.\n\n              syncpoint\n                        Need to response to a SYNCPT verb issued.  After\n                        successful operation, the next state will be\n                        receive.\n              syncpointSend\n                        Need to response to a SYNCPT verb issued.  After\n                        successful operation, the next state will be\n                        send.\n              syncpointDeallocate\n                        Need to response to a SYNCPT verb issued.  After\n                        successful operation, the next state will be\n                        reset.\n              backoutRequired\n                        TP must execute a BACKOUT verb to backout the\n                        transaction.')
appcActiveConvType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("basic", 1), ("mapped", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvType.setDescription('Indicates the type of conversation.  The values are:\n\n              basic\n                        Indicates that this conversation supports\n                        basic verbs.\n\n              mapped\n                        Indicates that this conversation supports\n                        mapped verbs.')
appcActiveConvCorrelator = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0,8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvCorrelator.setDescription('This is an 8-byte identifier that the source LU assigns to the\n          conversation; the source LU is the one that sent the allocation\n          request.  The conversation correlator is included on the\n          allocation request.  The conversation correlator uniquely\n\n          identifies a conversation, from among all conversations,\n          between the local and partner LUs.  It may be used, for\n          example, during problem determination associated with a\n          conversation.  A length of 0 indicates that no conversation\n          correlator is defined.')
appcActiveConvSyncLvl = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("none", 1), ("confirm", 2), ("syncpt", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvSyncLvl.setDescription('Indicates the highest sync level support for the conversation.\n          The values are:\n\n                none\n                        Indicates that no sync-level processing can be\n                        performed on this conversation. The\n                        transaction program does not issue verbs or\n                        recognize any returned parameters\n                        relating to any sync-level function.\n\n                confirm\n                        Indicates that confirmation processing can be\n                        performed on this conversation.  The\n                        transaction program can issue verbs and\n                        recognize returned parameters relating to\n                        confirmation.\n\n                syncpt\n                        Indicates that syncpt and confirmation processing\n                        can be performed on this conversation. The\n                        transaction program can issue verbs and recognize\n                        returned parameters relating to syncpt and\n                        confirmation.')
appcActiveConvSource = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("localLu", 1), ("partnerLu", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvSource.setDescription('Indicates whether the local or partner LU is the source of the\n          conversation, that is, which LU started the conversation by\n          sending the allocation request.\n\n               localLu\n                        The local LU is the source of the conversation,\n                        and the partner LU is the target of the\n                        conversation.\n\n               partnerLu\n                        The partner LU is the source of the\n                        conversation, and the local LU is the target of\n                        the conversation.')
appcActiveConvDuplex = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("half", 1), ("full", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvDuplex.setDescription('Indicates the conversation duplex style in effect for the\n          conversation.\n\n            half        Indicates that information can be transferred in\n                        both directions, but only in one direction at a\n                        time.\n\n            full        Indicates that information can be transferred in\n                        both directions at the same time.')
appcActiveConvUpTime = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvUpTime.setDescription('The length of time since the conversation started, measured in\n          hundredths of a second.')
appcActiveConvSendBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvSendBytes.setDescription('Indicates the number of bytes that was sent on the\n          conversation.  The count includes all SNA RU bytes sent,\n          including those in the FMH-5 (Attach), FMH-7 (Error\n          Description), SIGNAL, LUSTAT, and SNA responses; it does not\n          include SNA TH and RH bytes.')
appcActiveConvRcvBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvRcvBytes.setDescription('Indicates the number of bytes that was received on the\n          conversation.  The count includes all SNA RU bytes sent,\n          including those in the FMH-5 (Attach), FMH-7 (Error\n          Description), SIGNAL, LUSTAT, and SNA responses; it does not\n          include SNA TH and RH bytes.')
appcActiveConvUserid = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvUserid.setDescription('The user ID that the initiating program provided in the\n          incoming attach.')
appcActiveConvPcidNauName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 15), DisplayString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0,0),ValueSizeConstraint(3,17),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvPcidNauName.setDescription('The network-qualified NAU name of the\n           node at which the session and PCID originated.  For APPN\n           and LEN nodes, this is either CP name of the APPN node at\n           which the origin LU is located or the CP name of the\n           NN serving the LEN node at which the origin LU is\n           located.  This field is from 3 to 17 characters in\n           length, including a period (.) which separates the\n\n           NetId from the NAU name.  A null string indicates\n           that the value is unknown.')
appcActiveConvPcid = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 16), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0,0),ValueSizeConstraint(8,8),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvPcid.setDescription('The procedure correlation identifier (PCID) of the session.\n          It is an 8-octet value assigned by the control point providing\n          session services for the primary LU.  A null string indicates\n          that the value is unknown.')
appcActiveConvModeName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvModeName.setDescription('The Mode Name used for this conversation.\n           This is a 1-8 character name.')
appcActiveConvLuwIdName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvLuwIdName.setDescription('The SNA name of the LU that initiated the logical unit of work\n           that is associated with this active TP. This field is from\n           1 to 17 characters in length, including a period (.) which\n           separates the NetId from the LU name if the NetId is present.')
appcActiveConvLuwIdInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0,6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvLuwIdInstance.setDescription('The instance identifier for the logical unit of work.')
appcActiveConvLuwIdSequence = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 20), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0,2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvLuwIdSequence.setDescription('The sequence identifier for the logical unit of work.')
appcActiveConvTpName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvTpName.setDescription("The transaction program name which started this conversation.\n          This name could either be from a FMH5 ATTACH for a remotely\n          started conversation, otherwise it could the name of the local\n          TP if available.\n\n          When the TP name consists entirely of displayable EBCDIC code\n          points, it is mapped directly to the equivalent ASCII display\n          string.  However, registered TP names always have a non-\n          displayable EBCDIC code point (value less than or equal to\n          x'3F') as the first character, so they cannot be directly\n          mapped to an ASCII display string.  These TP names are\n          converted to a display string that is equivalent to a\n          hexadecimal display of the EBCDIC code points.  For example,\n          the 2-byte TP name x'06F1' (CNOS) is converted to the 6-byte\n          ASCII display string '06F1' (including the two single quotes).\n\n          This name is NULL if the conversation is started locally\n          (i.e., not with a FMH5 ATTACH).")
appcHistConvTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2), )
if mibBuilder.loadTexts: appcHistConvTable.setDescription('Table of historical information about APPC Conversations that\n\n          ended in error.  Possible categories of error conditions that\n          could be saved in this table are:\n\n                - allocation errors,\n                - deallocate abend,\n                - program errors, and\n                - service errors.')
appcHistConvEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2, 1), ).setIndexNames((0, "APPC-MIB", "appcHistConvIndex"))
if mibBuilder.loadTexts: appcHistConvEntry.setDescription('Entry representing one APPC Conversation.')
appcHistConvIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: appcHistConvIndex.setDescription('Index for entry in Conversation table.  This value identifies\n          the unique index of the conversation.  It is recommended that\n          an Agent not reuse the index of a deactivated conversation for\n          a significant period of time (e.g. one week).')
appcHistConvEndTime = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2, 1, 2), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistConvEndTime.setDescription('The time at which the conversation ended.')
appcHistConvLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistConvLocLuName.setDescription('The name of the local LU for this conversation.  This field is\n          from 1 to 17 characters in length, including a period (.) which\n          separates the NetId from the NAU name if the NetId is present.')
appcHistConvParLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistConvParLuName.setDescription('The SNA name of the partner LU for the conversation.  This\n          field is from 1 to 17 characters in length, including a period\n          (.) which separates the NetId from the NAU name if the NetId is\n          present.')
appcHistConvTpName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistConvTpName.setDescription("The transaction program name which started this conversation.\n          This name could either be from a FMH5 ATTACH for a remotely\n          started conversation, otherwise it could the name of the local\n          TP if available.\n\n          When the TP name consists entirely of displayable EBCDIC code\n          points, it is mapped directly to the equivalent ASCII display\n          string.  However, registered TP names always have a non-\n          displayable EBCDIC code point (value less than or equal to\n          x'3F') as the first character, so they cannot be directly\n          mapped to an ASCII display string.  These TP names are\n          converted to a display string that is equivalent to a\n\n          hexadecimal display of the EBCDIC code points.  For example,\n          the 2-byte TP name x'06F1' (CNOS) is converted to the 6-byte\n          ASCII display string '06F1' (including the two single quotes).\n\n          This name is NULL if the conversation is started locally\n          (i.e., not with a FMH5 ATTACH).")
appcHistConvPcidNauName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2, 1, 6), DisplayString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0,0),ValueSizeConstraint(3,17),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistConvPcidNauName.setDescription('The network-qualified NAU name of the\n           node at which the session and PCID originated.  For APPN\n           and LEN nodes, this is either CP name of the APPN node at\n           which the origin LU is located or the CP name of the\n           NN serving the LEN node at which the origin LU is\n           located.  This field is from 3 to 17 characters in\n           length, including a period (.) which separates the\n           NetId from the NAU name.  A null string indicates that the\n           value is unknown.')
appcHistConvPcid = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2, 1, 7), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0,0),ValueSizeConstraint(8,8),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistConvPcid.setDescription('The procedure correlation identifier (PCID) of the session.\n         It is an 8-octet value assigned by the control point providing\n         session services for the primary LU.  A null string indicates\n         that the value is unknown.')
appcHistConvSenseData = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2, 1, 8), SnaSenseData()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistConvSenseData.setDescription('The sense data associated with the action that ended this\n          conversation, e.g., FMH-7 or UNBIND.')
appcHistConvLogData = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0,32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistConvLogData.setDescription('The first 32 bytes of the data portion of the Log Data GDS\n          Variable that is associated with the last FMH-7 that occurred\n          on this conversation.  If there was no Log Data GDS Variable\n          associated with the FMH-7, this object is null.\n\n          This object reflects only the data portion of the Log Data\n          GDS Variable (i.e. not the LL or GDS Id).')
appcHistConvEndedBy = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("localLu", 1), ("partnerLu", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistConvEndedBy.setDescription('Indicates which LU ended the conversation.')
appcCpicAdminTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 1), )
if mibBuilder.loadTexts: appcCpicAdminTable.setDescription('APPC CPI-C side information table.')
appcCpicAdminEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 1, 1), ).setIndexNames((0, "APPC-MIB", "appcCpicAdminLocLuName"), (0, "APPC-MIB", "appcCpicAdminSymbDestName"))
if mibBuilder.loadTexts: appcCpicAdminEntry.setDescription('Entry of APPC CPI-C side information Table.')
appcCpicAdminLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17)))
if mibBuilder.loadTexts: appcCpicAdminLocLuName.setDescription("The SNA name of the local LU to which this CPI-C side\n          information definition applies.  This field is from 1 to 17\n          characters in length, including a period (.) which separates\n          the NetId from the NAU name if the NetId is present.\n\n          The reserved value '*ALL' indicates that the definition applies\n          to all local LUs, and not just to a single local LU.")
appcCpicAdminSymbDestName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,8)))
if mibBuilder.loadTexts: appcCpicAdminSymbDestName.setDescription('Specifies the symbolic destination name used by CPI-C\n          applications to identify this definition.')
appcCpicAdminParLuAlias = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicAdminParLuAlias.setDescription('A local alias for the partner LU.  If not known or\n\n           not applicable, this object contains a zero-length\n           string.')
appcCpicAdminParLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicAdminParLuName.setDescription('The SNA name of the partner LU.  This field is from 1 to 17\n          characters in length, including a period (.)  which separates\n          the NetId from the NAU name if the NetId is present.')
appcCpicAdminModeName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicAdminModeName.setDescription('Specifies the mode name.  A mode defines the characteristics\n          for a group of sessions.  The mode name can be blank (8 space\n          characters).')
appcCpicAdminTpNameType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("normal", 1), ("snaServiceTp", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicAdminTpNameType.setDescription('Specifies whether the TP name in appcCpicAdminTpName\n          identifies a normal TP or an SNA service TP.  In this context,\n          a normal TP is one with a name consisting only of displayable\n          characters, while an SNA service TP has a name containing\n          octets that do not map to displayable characters.')
appcCpicAdminTpName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicAdminTpName.setDescription("Specifies the name of the partner TP to be used when a CPI-C\n           application initiates a conversation specifying this side\n           information entry.\n\n           Display convention\n\n              When the TP name consists entirely of displayable EBCDIC\n              code points, it is mapped directly to the equivalent ASCII\n              display string.  However, registered TP names always have a\n              non-displayable EBCDIC code point (value less than or equal\n              to x'3F') as the first character, so they cannot be\n              directly mapped to an ASCII display string.  These TP names\n              are converted to a display string that is equivalent to a\n              hexadecimal display of the EBCDIC code points.  For\n              example, the 2-byte TP name x'06F1' (CNOS) is converted to\n              the 6-byte ASCII display string '06F1' (including the two\n              single quotes).")
appcCpicAdminUserid = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicAdminUserid.setDescription('The security userid, if any, associated with the side\n          information definition.')
appcCpicAdminSecurity = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6,))).clone(namedValues=NamedValues(("none", 1), ("same", 2), ("pgm", 3), ("pgmStrong", 4), ("distributed", 5), ("mutual", 6),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicAdminSecurity.setDescription('Specifies the security information to be used for allocating\n          the conversation.\n\n\n            none        - No security information.\n            same        - Use the security environment currently\n                          associated with this TP.\n            pgm         - Use the program-supplied user_id and password.\n            pgmStrong   - Use the program-supplied user_id and password.\n                          The local LU will insure that the password is\n                          not exposed in clear-text form on the physical\n                          network.\n            distributed - Use the security environment and a distributed\n                          security system to generate the authentication\n                          information for this request.  If distributed\n                          security tokens cannot be generated, then fail\n                          the conversation.\n            mutual      - Authenticate both the user to the destination\n                          system and the destination system to the user.')
appcCpicOperTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 2), )
if mibBuilder.loadTexts: appcCpicOperTable.setDescription('APPC CPI-C side information operational table.')
appcCpicOperEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 2, 1), ).setIndexNames((0, "APPC-MIB", "appcCpicOperLocLuName"), (0, "APPC-MIB", "appcCpicOperSymbDestName"))
if mibBuilder.loadTexts: appcCpicOperEntry.setDescription('Entry of APPC CPI-C side information Table.')
appcCpicOperLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17)))
if mibBuilder.loadTexts: appcCpicOperLocLuName.setDescription("The SNA name of the local LU to which this CPI-C side\n          information definition applies.  This field is from 1 to 17\n          characters in length, including a period (.) which separates\n          the NetId from the NAU name if the NetId is present.\n\n          The reserved value '*ALL' indicates that the definition applies\n          to all local LUs, and not just to a single local LU.")
appcCpicOperSymbDestName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,8)))
if mibBuilder.loadTexts: appcCpicOperSymbDestName.setDescription('Specifies the symbolic destination name used by CPI-C\n          applications to identify this definition.')
appcCpicOperParLuAlias = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicOperParLuAlias.setDescription('A local alias for the partner LU.  If not known or not\n          applicable, this object contains a zero-length string.')
appcCpicOperParLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicOperParLuName.setDescription('The SNA name of the partner LU.  This field is from 1 to 17\n          characters in length, including a period (.) which separates\n          the NetId from the NAU name if the NetId is present.')
appcCpicOperModeName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicOperModeName.setDescription('Specifies the mode name.  A mode defines the characteristics\n          for a group of sessions.  The mode name can be blank (8 space\n          characters).')
appcCpicOperTpNameType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("normal", 1), ("snaServiceTp", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicOperTpNameType.setDescription('Specifies whether the TP name in appcCpicOperTpName identifies\n          a normal TP or an SNA service TP.  In this context, a normal TP\n          is one with a name consisting only of displayable characters,\n          while an SNA service TP has a name containing octets that do\n          not map to displayable characters.')
appcCpicOperTpName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1,64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicOperTpName.setDescription("Specifies the name of the partner TP to be used when a CPI-C\n          application initiates a conversation specifying this side\n          information entry.\n\n\n          Display convention\n\n              When the TP name consists entirely of displayable EBCDIC\n              code points, it is mapped directly to the equivalent ASCII\n              display string.  However, registered TP names always have\n              a non-displayable EBCDIC code point (value less than or\n              equal to x'3F') as the first character, so they cannot be\n              directly mapped to an ASCII display string.  These TP\n              names are converted to a display string that is equivalent\n              to a hexadecimal display of the EBCDIC code points.  For\n              example, the 2-byte TP name x'06F1' (CNOS) is converted to\n              the 6-byte ASCII display string '06F1' (including the two\n              single quotes).")
appcCpicOperUserid = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0,10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicOperUserid.setDescription('The security userid, if any, associated with the active side\n          information definition.')
appcCpicOperSecurity = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6,))).clone(namedValues=NamedValues(("none", 1), ("same", 2), ("pgm", 3), ("pgmStrong", 4), ("distributed", 5), ("mutual", 6),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicOperSecurity.setDescription('Specifies the security information to be used for allocating\n          the conversation.\n\n            none        - No security information.\n            same        - Use the security environment currently\n                          associated with this TP.\n            pgm         - Use the program-supplied user_id and password.\n            pgmStrong   - Use the program-supplied user_id and password.\n                          The local LU will insure that the password is\n                          not exposed in clear-text form on the physical\n\n                          network.\n            distributed - Use the security environment and a distributed\n                          security system to generate the authentication\n                          information for this request.  If distributed\n                          security tokens cannot be generated, then fail\n                          the conversation.\n            mutual      - Authenticate both the user to the destination\n                          system and the destination system to the user.')
appcConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 2))
appcCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 2, 1))
appcGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 2, 2))
appcCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 34, 3, 2, 1, 1)).setObjects(*(("APPC-MIB", "appcGlobalConfGroup"), ("APPC-MIB", "appcLluConfGroup"), ("APPC-MIB", "appcParLuConfGroup"), ("APPC-MIB", "appcModeConfGroup"), ("APPC-MIB", "appcTpConfGroup"), ("APPC-MIB", "appcSessionConfGroup"), ("APPC-MIB", "appcControlConfGroup"), ("APPC-MIB", "appcCnosConfGroup"), ("APPC-MIB", "appcCpicConfGroup"), ("APPC-MIB", "appcConversationConfGroup"),))
if mibBuilder.loadTexts: appcCompliance.setDescription('The compliance statement for the SNMPv2 entities which\n          implement the APPC MIB.')
appcGlobalConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 3, 2, 2, 1)).setObjects(*(("APPC-MIB", "appcUpTime"), ("APPC-MIB", "appcDefaultModeName"), ("APPC-MIB", "appcDefaultLuName"), ("APPC-MIB", "appcDefaultImplInbndPlu"), ("APPC-MIB", "appcDefaultMaxMcLlSndSize"), ("APPC-MIB", "appcDefaultFileSpec"), ("APPC-MIB", "appcDefaultTpOperation"), ("APPC-MIB", "appcDefaultTpConvSecRqd"), ("APPC-MIB", "appcLocalCpName"), ("APPC-MIB", "appcActiveSessions"), ("APPC-MIB", "appcActiveHprSessions"),))
if mibBuilder.loadTexts: appcGlobalConfGroup.setDescription('A collection of objects providing the instrumentation of APPC\n          global information and defaults.')
appcLluConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 3, 2, 2, 2)).setObjects(*(("APPC-MIB", "appcLluAdminDepType"), ("APPC-MIB", "appcLluAdminLocalAddress"), ("APPC-MIB", "appcLluAdminSessLimit"), ("APPC-MIB", "appcLluAdminBindRspMayQ"), ("APPC-MIB", "appcLluAdminCompression"), ("APPC-MIB", "appcLluAdminInBoundCompLevel"), ("APPC-MIB", "appcLluAdminOutBoundCompLevel"), ("APPC-MIB", "appcLluAdminCompRleBeforeLZ"), ("APPC-MIB", "appcLluAdminAlias"), ("APPC-MIB", "appcLluOperDepType"), ("APPC-MIB", "appcLluOperLocalAddress"), ("APPC-MIB", "appcLluOperSessLimit"), ("APPC-MIB", "appcLluOperBindRspMayQ"), ("APPC-MIB", "appcLluOperCompression"), ("APPC-MIB", "appcLluOperInBoundCompLevel"), ("APPC-MIB", "appcLluOperOutBoundCompLevel"), ("APPC-MIB", "appcLluOperCompRleBeforeLZ"), ("APPC-MIB", "appcLluOperAlias"), ("APPC-MIB", "appcLluOperActiveSessions"),))
if mibBuilder.loadTexts: appcLluConfGroup.setDescription('A collection of objects providing the instrumentation of APPC\n          local LU6.2s.')
appcParLuConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 3, 2, 2, 3)).setObjects(*(("APPC-MIB", "appcLuPairAdminParLuAlias"), ("APPC-MIB", "appcLuPairAdminSessLimit"), ("APPC-MIB", "appcLuPairAdminSessSec"), ("APPC-MIB", "appcLuPairAdminSecAccept"), ("APPC-MIB", "appcLuPairAdminLinkObjId"), ("APPC-MIB", "appcLuPairAdminParaSessSup"), ("APPC-MIB", "appcLuPairOperParLuAlias"), ("APPC-MIB", "appcLuPairOperSessLimit"), ("APPC-MIB", "appcLuPairOperSessSec"), ("APPC-MIB", "appcLuPairOperSecAccept"), ("APPC-MIB", "appcLuPairOperLinkObjId"), ("APPC-MIB", "appcLuPairOperParaSessSup"), ("APPC-MIB", "appcLuPairOperParaSessSupLS"), ("APPC-MIB", "appcLuPairOperState"),))
if mibBuilder.loadTexts: appcParLuConfGroup.setDescription('A collection of objects providing the instrumentation of APPC\n          partner LUs.')
appcModeConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 3, 2, 2, 4)).setObjects(*(("APPC-MIB", "appcModeAdminCosName"), ("APPC-MIB", "appcModeAdminSessEndTpName"), ("APPC-MIB", "appcModeAdminMaxSessLimit"), ("APPC-MIB", "appcModeAdminMinCwinLimit"), ("APPC-MIB", "appcModeAdminMinClosLimit"), ("APPC-MIB", "appcModeAdminConWinAutoActLmt"), ("APPC-MIB", "appcModeAdminRecvPacWinSz"), ("APPC-MIB", "appcModeAdminSendPacWinSz"), ("APPC-MIB", "appcModeAdminPrefRecvRuSz"), ("APPC-MIB", "appcModeAdminPrefSendRuSz"), ("APPC-MIB", "appcModeAdminRecvRuSzUpBnd"), ("APPC-MIB", "appcModeAdminSendRuSzUpBnd"), ("APPC-MIB", "appcModeAdminRecvRuSzLoBnd"), ("APPC-MIB", "appcModeAdminSendRuSzLoBnd"), ("APPC-MIB", "appcModeAdminSingSessReinit"), ("APPC-MIB", "appcModeAdminCompression"), ("APPC-MIB", "appcModeAdminInBoundCompLevel"), ("APPC-MIB", "appcModeAdminOutBoundCompLevel"), ("APPC-MIB", "appcModeAdminCompRleBeforeLZ"), ("APPC-MIB", "appcModeAdminSyncLvl"), ("APPC-MIB", "appcModeAdminCrypto"), ("APPC-MIB", "appcModeOperCosName"), ("APPC-MIB", "appcModeOperSessEndTpName"), ("APPC-MIB", "appcModeOperSessLimit"), ("APPC-MIB", "appcModeOperMaxSessLimit"), ("APPC-MIB", "appcModeOperMinCwinLimit"), ("APPC-MIB", "appcModeOperMinClosLimit"), ("APPC-MIB", "appcModeOperConWinAutoActLmt"), ("APPC-MIB", "appcModeOperRecvPacWinSz"), ("APPC-MIB", "appcModeOperSendPacWinSz"), ("APPC-MIB", "appcModeOperPrefRecvRuSz"), ("APPC-MIB", "appcModeOperPrefSendRuSz"), ("APPC-MIB", "appcModeOperRecvRuSzUpBnd"), ("APPC-MIB", "appcModeOperSendRuSzUpBnd"), ("APPC-MIB", "appcModeOperRecvRuSzLoBnd"), ("APPC-MIB", "appcModeOperSendRuSzLoBnd"), ("APPC-MIB", "appcModeOperSingSessReinit"), ("APPC-MIB", "appcModeOperCompression"), ("APPC-MIB", "appcModeOperInBoundCompLevel"), ("APPC-MIB", "appcModeOperOutBoundCompLevel"), ("APPC-MIB", "appcModeOperCompRleBeforeLZ"), ("APPC-MIB", "appcModeOperSyncLvl"), ("APPC-MIB", "appcModeOperCrypto"), ("APPC-MIB", "appcModeOperSyncLvlLastStart"), ("APPC-MIB", "appcModeOperCryptoLastStart"), ("APPC-MIB", "appcModeOperCNOSNeg"), ("APPC-MIB", "appcModeOperActCwin"), ("APPC-MIB", "appcModeOperActClos"), ("APPC-MIB", "appcModeOperPndCwin"), ("APPC-MIB", "appcModeOperPndClos"), ("APPC-MIB", "appcModeOperPtmCwin"), ("APPC-MIB", "appcModeOperPtmClos"), ("APPC-MIB", "appcModeOperDrainSelf"), ("APPC-MIB", "appcModeOperDrainPart"),))
if mibBuilder.loadTexts: appcModeConfGroup.setDescription('A collection of objects providing the instrumentation of APPC\n          modes.')
appcTpConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 3, 2, 2, 5)).setObjects(*(("APPC-MIB", "appcTpAdminFileSpec"), ("APPC-MIB", "appcTpAdminStartParm"), ("APPC-MIB", "appcTpAdminTpOperation"), ("APPC-MIB", "appcTpAdminInAttachTimeout"), ("APPC-MIB", "appcTpAdminRcvAllocTimeout"), ("APPC-MIB", "appcTpAdminSyncLvl"), ("APPC-MIB", "appcTpAdminInstLmt"), ("APPC-MIB", "appcTpAdminStatus"), ("APPC-MIB", "appcTpAdminLongRun"), ("APPC-MIB", "appcTpAdminConvType"), ("APPC-MIB", "appcTpAdminConvDuplex"), ("APPC-MIB", "appcTpAdminConvSecReq"), ("APPC-MIB", "appcTpAdminVerPip"), ("APPC-MIB", "appcTpAdminPipSubNum"),))
if mibBuilder.loadTexts: appcTpConfGroup.setDescription('A collection of objects providing the instrumentation of APPC\n          Transaction Programs.')
appcSessionConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 3, 2, 2, 6)).setObjects(*(("APPC-MIB", "appcActSessPcidCpName"), ("APPC-MIB", "appcActSessPcid"), ("APPC-MIB", "appcActSessPluIndicator"), ("APPC-MIB", "appcActSessModeName"), ("APPC-MIB", "appcActSessCosName"), ("APPC-MIB", "appcActSessTransPriority"), ("APPC-MIB", "appcActSessEnhanceSecSup"), ("APPC-MIB", "appcActSessSendPacingType"), ("APPC-MIB", "appcActSessSendRpc"), ("APPC-MIB", "appcActSessSendNxWndwSize"), ("APPC-MIB", "appcActSessRecvPacingType"), ("APPC-MIB", "appcActSessRecvRpc"), ("APPC-MIB", "appcActSessRecvNxWndwSize"), ("APPC-MIB", "appcActSessRscv"), ("APPC-MIB", "appcActSessInUse"), ("APPC-MIB", "appcActSessMaxSndRuSize"), ("APPC-MIB", "appcActSessMaxRcvRuSize"), ("APPC-MIB", "appcActSessSndPacingSize"), ("APPC-MIB", "appcActSessRcvPacingSize"), ("APPC-MIB", "appcActSessOperState"), ("APPC-MIB", "appcActSessUpTime"), ("APPC-MIB", "appcActSessRtpNceId"), ("APPC-MIB", "appcActSessRtpTcid"), ("APPC-MIB", "appcActSessLinkIndex"), ("APPC-MIB", "appcSessStatsSentFmdBytes"), ("APPC-MIB", "appcSessStatsSentNonFmdBytes"), ("APPC-MIB", "appcSessStatsRcvdFmdBytes"), ("APPC-MIB", "appcSessStatsRcvdNonFmdBytes"), ("APPC-MIB", "appcSessStatsSentFmdRus"), ("APPC-MIB", "appcSessStatsSentNonFmdRus"), ("APPC-MIB", "appcSessStatsRcvdFmdRus"), ("APPC-MIB", "appcSessStatsRcvdNonFmdRus"), ("APPC-MIB", "appcSessStatsCtrUpTime"), ("APPC-MIB", "appcHistSessTime"), ("APPC-MIB", "appcHistSessType"), ("APPC-MIB", "appcHistSessLocLuName"), ("APPC-MIB", "appcHistSessParLuName"), ("APPC-MIB", "appcHistSessModeName"), ("APPC-MIB", "appcHistSessUnbindType"), ("APPC-MIB", "appcHistSessSenseData"), ("APPC-MIB", "appcHistSessComponentId"), ("APPC-MIB", "appcHistSessDetectModule"), ("APPC-MIB", "appcSessRtpSessions"),))
if mibBuilder.loadTexts: appcSessionConfGroup.setDescription('A collection of objects providing the instrumentation of APPC\n          LU6.2 sessions.')
appcControlConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 3, 2, 2, 7)).setObjects(*(("APPC-MIB", "appcCntrlAdminStat"), ("APPC-MIB", "appcCntrlAdminRscv"), ("APPC-MIB", "appcCntrlAdminTrace"), ("APPC-MIB", "appcCntrlAdminTraceParm"), ("APPC-MIB", "appcCntrlOperStat"), ("APPC-MIB", "appcCntrlOperStatTime"), ("APPC-MIB", "appcCntrlOperRscv"), ("APPC-MIB", "appcCntrlOperRscvTime"), ("APPC-MIB", "appcCntrlOperTrace"), ("APPC-MIB", "appcCntrlOperTraceTime"), ("APPC-MIB", "appcCntrlOperTraceParm"),))
if mibBuilder.loadTexts: appcControlConfGroup.setDescription('A collection of objects providing the instrumentation of APPC\n          control.')
appcCnosConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 3, 2, 2, 8)).setObjects(*(("APPC-MIB", "appcCnosCommand"), ("APPC-MIB", "appcCnosMaxSessLimit"), ("APPC-MIB", "appcCnosMinCwinLimit"), ("APPC-MIB", "appcCnosMinClosLimit"), ("APPC-MIB", "appcCnosDrainSelf"), ("APPC-MIB", "appcCnosDrainPart"), ("APPC-MIB", "appcCnosResponsible"), ("APPC-MIB", "appcCnosForce"), ("APPC-MIB", "appcCnosTargetLocLuName"), ("APPC-MIB", "appcCnosTargetParLuName"), ("APPC-MIB", "appcCnosTargetModeName"),))
if mibBuilder.loadTexts: appcCnosConfGroup.setDescription('A collection of objects providing the instrumentation of APPC\n          CNOS processing.')
appcCpicConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 3, 2, 2, 9)).setObjects(*(("APPC-MIB", "appcCpicAdminParLuAlias"), ("APPC-MIB", "appcCpicAdminParLuName"), ("APPC-MIB", "appcCpicAdminModeName"), ("APPC-MIB", "appcCpicAdminTpNameType"), ("APPC-MIB", "appcCpicAdminTpName"), ("APPC-MIB", "appcCpicAdminUserid"), ("APPC-MIB", "appcCpicAdminSecurity"), ("APPC-MIB", "appcCpicOperParLuAlias"), ("APPC-MIB", "appcCpicOperParLuName"), ("APPC-MIB", "appcCpicOperModeName"), ("APPC-MIB", "appcCpicOperTpNameType"), ("APPC-MIB", "appcCpicOperTpName"), ("APPC-MIB", "appcCpicOperUserid"), ("APPC-MIB", "appcCpicOperSecurity"),))
if mibBuilder.loadTexts: appcCpicConfGroup.setDescription('A collection of objects providing the instrumentation of APPC\n          CPI-C side information.')
appcConversationConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 3, 2, 2, 10)).setObjects(*(("APPC-MIB", "appcActiveConvId"), ("APPC-MIB", "appcActiveConvState"), ("APPC-MIB", "appcActiveConvType"), ("APPC-MIB", "appcActiveConvCorrelator"), ("APPC-MIB", "appcActiveConvSyncLvl"), ("APPC-MIB", "appcActiveConvSource"), ("APPC-MIB", "appcActiveConvDuplex"), ("APPC-MIB", "appcActiveConvUpTime"), ("APPC-MIB", "appcActiveConvSendBytes"), ("APPC-MIB", "appcActiveConvRcvBytes"), ("APPC-MIB", "appcActiveConvUserid"), ("APPC-MIB", "appcActiveConvPcidNauName"), ("APPC-MIB", "appcActiveConvPcid"), ("APPC-MIB", "appcActiveConvModeName"), ("APPC-MIB", "appcActiveConvLuwIdName"), ("APPC-MIB", "appcActiveConvLuwIdInstance"), ("APPC-MIB", "appcActiveConvLuwIdSequence"), ("APPC-MIB", "appcActiveConvTpName"), ("APPC-MIB", "appcHistConvEndTime"), ("APPC-MIB", "appcHistConvLocLuName"), ("APPC-MIB", "appcHistConvParLuName"), ("APPC-MIB", "appcHistConvTpName"), ("APPC-MIB", "appcHistConvPcidNauName"), ("APPC-MIB", "appcHistConvPcid"), ("APPC-MIB", "appcHistConvSenseData"), ("APPC-MIB", "appcHistConvLogData"), ("APPC-MIB", "appcHistConvEndedBy"),))
if mibBuilder.loadTexts: appcConversationConfGroup.setDescription('A collection of objects providing the instrumentation of APPC\n          conversations.')
mibBuilder.exportSymbols("APPC-MIB", appcActSessSendNxWndwSize=appcActSessSendNxWndwSize, appcModeAdminRecvRuSzUpBnd=appcModeAdminRecvRuSzUpBnd, appcModeAdminInBoundCompLevel=appcModeAdminInBoundCompLevel, appcSessStatsSentNonFmdRus=appcSessStatsSentNonFmdRus, appcActiveSessions=appcActiveSessions, appcActiveConvModeName=appcActiveConvModeName, appcCpicAdminParLuName=appcCpicAdminParLuName, appcSessStatsSentFmdRus=appcSessStatsSentFmdRus, appcSessStatsRcvdNonFmdBytes=appcSessStatsRcvdNonFmdBytes, appcActiveConvEntry=appcActiveConvEntry, appcActiveConvLuwIdSequence=appcActiveConvLuwIdSequence, appcTpAdminInAttachTimeout=appcTpAdminInAttachTimeout, appcSessStatsSessIndex=appcSessStatsSessIndex, appcLuPairOperTable=appcLuPairOperTable, appcModeOperCosName=appcModeOperCosName, appcModeOperMinCwinLimit=appcModeOperMinCwinLimit, appcActSessMaxRcvRuSize=appcActSessMaxRcvRuSize, appcActiveConvLuwIdInstance=appcActiveConvLuwIdInstance, appcActSessMaxSndRuSize=appcActSessMaxSndRuSize, appcHistConvSenseData=appcHistConvSenseData, appcLuPairOperState=appcLuPairOperState, appcModeAdminPrefSendRuSz=appcModeAdminPrefSendRuSz, appcTpAdminInstLmt=appcTpAdminInstLmt, appcLuPairOperParLuName=appcLuPairOperParLuName, appcModeOperCNOSNeg=appcModeOperCNOSNeg, appcLuPairOperParLuAlias=appcLuPairOperParLuAlias, appcTpAdminSyncLvl=appcTpAdminSyncLvl, appcCpicAdminParLuAlias=appcCpicAdminParLuAlias, appcLuPairOperSessLimit=appcLuPairOperSessLimit, appcCpicOperSecurity=appcCpicOperSecurity, appcModeOperCryptoLastStart=appcModeOperCryptoLastStart, appcCpicAdminTable=appcCpicAdminTable, appcModeAdminOutBoundCompLevel=appcModeAdminOutBoundCompLevel, appcDefaultModeName=appcDefaultModeName, appcActSessPcid=appcActSessPcid, appcHistConvTable=appcHistConvTable, appcModeOperSendRuSzLoBnd=appcModeOperSendRuSzLoBnd, appcModeOperSingSessReinit=appcModeOperSingSessReinit, appcSessStatsEntry=appcSessStatsEntry, appcActiveConvUserid=appcActiveConvUserid, appcHistSessModeName=appcHistSessModeName, appcModeAdminSyncLvl=appcModeAdminSyncLvl, appcModeOperCrypto=appcModeOperCrypto, appcActSessUpTime=appcActSessUpTime, appcHistSessLocLuName=appcHistSessLocLuName, appcCpicAdminUserid=appcCpicAdminUserid, appcLluOperAlias=appcLluOperAlias, appcCnosTargetParLuName=appcCnosTargetParLuName, appcLuPairOperParaSessSupLS=appcLuPairOperParaSessSupLS, appcLluOperOutBoundCompLevel=appcLluOperOutBoundCompLevel, appcSessStatsParLuName=appcSessStatsParLuName, appcActiveConvCorrelator=appcActiveConvCorrelator, PYSNMP_MODULE_ID=appcMIB, appcCompliance=appcCompliance, appcConformance=appcConformance, appcModeAdminMinClosLimit=appcModeAdminMinClosLimit, appcActSessTable=appcActSessTable, appcActSessRecvRpc=appcActSessRecvRpc, appcActSessRecvPacingType=appcActSessRecvPacingType, appcActSessSendRpc=appcActSessSendRpc, appcActSessInUse=appcActSessInUse, appcSessStatsRcvdNonFmdRus=appcSessStatsRcvdNonFmdRus, appcActSessRcvPacingSize=appcActSessRcvPacingSize, appcCpicOperUserid=appcCpicOperUserid, appcCnosTargetModeName=appcCnosTargetModeName, appcModeOperRecvRuSzUpBnd=appcModeOperRecvRuSzUpBnd, appcSessRtpSessions=appcSessRtpSessions, appcHistSessParLuName=appcHistSessParLuName, appcActSessEnhanceSecSup=appcActSessEnhanceSecSup, appcCntrlOperGroup=appcCntrlOperGroup, appcCpicOperParLuName=appcCpicOperParLuName, appcLuPairAdminSecAccept=appcLuPairAdminSecAccept, appcCpicAdminSecurity=appcCpicAdminSecurity, appcCpicOperSymbDestName=appcCpicOperSymbDestName, appcModeOperSyncLvl=appcModeOperSyncLvl, appcActSessLinkIndex=appcActSessLinkIndex, appcParLuConfGroup=appcParLuConfGroup, appcActSessOperState=appcActSessOperState, appcActSessRtpTcid=appcActSessRtpTcid, appcLocalCpName=appcLocalCpName, appcCnosMinCwinLimit=appcCnosMinCwinLimit, appcActSessSendPacingType=appcActSessSendPacingType, appcModeOperRecvRuSzLoBnd=appcModeOperRecvRuSzLoBnd, appcHistConvEndedBy=appcHistConvEndedBy, appcSessStatsTable=appcSessStatsTable, appcCpicAdminSymbDestName=appcCpicAdminSymbDestName, appcLuPairOperSecAccept=appcLuPairOperSecAccept, appcModeAdminPrefRecvRuSz=appcModeAdminPrefRecvRuSz, appcModeAdminCompression=appcModeAdminCompression, appcModeOperDrainPart=appcModeOperDrainPart, appcModeOperActClos=appcModeOperActClos, appcCpicOperParLuAlias=appcCpicOperParLuAlias, appcCpicOperModeName=appcCpicOperModeName, appcActiveConvLuwIdName=appcActiveConvLuwIdName, appcModeOperActCwin=appcModeOperActCwin, appcTpConfGroup=appcTpConfGroup, appcActiveConvSource=appcActiveConvSource, appcDefaultFileSpec=appcDefaultFileSpec, SnaSenseData=SnaSenseData, appcLluAdminName=appcLluAdminName, appcLluOperDepType=appcLluOperDepType, appcSessRtpNceId=appcSessRtpNceId, appcLuPairAdminLocLuName=appcLuPairAdminLocLuName, appcCnosConfGroup=appcCnosConfGroup, appcTpAdminLocLuName=appcTpAdminLocLuName, appcHistConvIndex=appcHistConvIndex, appcActiveConvTpName=appcActiveConvTpName, appcModeOperEntry=appcModeOperEntry, appcConversation=appcConversation, appcTpAdminStatus=appcTpAdminStatus, appcModeAdminCompRleBeforeLZ=appcModeAdminCompRleBeforeLZ, appcModeOperPndClos=appcModeOperPndClos, appcCntrlOperTrace=appcCntrlOperTrace, appcModeOperCompRleBeforeLZ=appcModeOperCompRleBeforeLZ, appcActSessParLuName=appcActSessParLuName, appcActSessEntry=appcActSessEntry, appcLuPairAdminSessLimit=appcLuPairAdminSessLimit, appcLluOperCompRleBeforeLZ=appcLluOperCompRleBeforeLZ, appcActiveConvDuplex=appcActiveConvDuplex, appcTpAdminTpName=appcTpAdminTpName, appcDefaultImplInbndPlu=appcDefaultImplInbndPlu, appcGroups=appcGroups, appcModeAdminConWinAutoActLmt=appcModeAdminConWinAutoActLmt, appcCntrlAdminStat=appcCntrlAdminStat, appcCnosCommand=appcCnosCommand, appcModeOperSessEndTpName=appcModeOperSessEndTpName, appcCntrlOperStatTime=appcCntrlOperStatTime, appcModeOperOutBoundCompLevel=appcModeOperOutBoundCompLevel, appcLu=appcLu, appcTp=appcTp, appcLluOperActiveSessions=appcLluOperActiveSessions, appcLuPairOperParaSessSup=appcLuPairOperParaSessSup, appcTpAdminFileSpec=appcTpAdminFileSpec, appcTpAdminRcvAllocTimeout=appcTpAdminRcvAllocTimeout, appcTpAdminVerPip=appcTpAdminVerPip, appcHistSessSenseData=appcHistSessSenseData, appcLluOperTable=appcLluOperTable, appcCnosDrainPart=appcCnosDrainPart, appcLluOperName=appcLluOperName, appcLluOperEntry=appcLluOperEntry, appcModeOperMinClosLimit=appcModeOperMinClosLimit, appcLluAdminInBoundCompLevel=appcLluAdminInBoundCompLevel, appcLuPairOperEntry=appcLuPairOperEntry, appcModeOperRecvPacWinSz=appcModeOperRecvPacWinSz, appcSessRtpTcid=appcSessRtpTcid, appcLluAdminEntry=appcLluAdminEntry, appcHistSessUnbindType=appcHistSessUnbindType, appcModeAdminTable=appcModeAdminTable, appcSessionConfGroup=appcSessionConfGroup, appcActSessModeName=appcActSessModeName, appcActiveConvUpTime=appcActiveConvUpTime, appcCpicOperEntry=appcCpicOperEntry, appcSession=appcSession, appcModeOperPrefRecvRuSz=appcModeOperPrefRecvRuSz, appcModeAdminModeName=appcModeAdminModeName, appcLluConfGroup=appcLluConfGroup, appcCpicOperTpNameType=appcCpicOperTpNameType, appcHistSessType=appcHistSessType, appcModeOperPrefSendRuSz=appcModeOperPrefSendRuSz, appcCntrlAdminGroup=appcCntrlAdminGroup, appcCnosMaxSessLimit=appcCnosMaxSessLimit, appcConversationConfGroup=appcConversationConfGroup, appcTpAdminTable=appcTpAdminTable, appcActSessRscv=appcActSessRscv, appcModeOperParLuName=appcModeOperParLuName, appcModeConfGroup=appcModeConfGroup, appcActiveConvType=appcActiveConvType, appcModeAdminSessEndTpName=appcModeAdminSessEndTpName, appcActSessLocLuName=appcActSessLocLuName, appcLluAdminDepType=appcLluAdminDepType, appcModeAdminMinCwinLimit=appcModeAdminMinCwinLimit, appcModeOperLocLuName=appcModeOperLocLuName, appcActSessRtpNceId=appcActSessRtpNceId, appcCpicAdminModeName=appcCpicAdminModeName, appcModeAdminLocLuName=appcModeAdminLocLuName, appcUpTime=appcUpTime, appcSessRtpTable=appcSessRtpTable, appcCpicAdminTpNameType=appcCpicAdminTpNameType, appcCntrlOperStat=appcCntrlOperStat, appcModeOperDrainSelf=appcModeOperDrainSelf, appcActSessIndex=appcActSessIndex, appcActSessPluIndicator=appcActSessPluIndicator, appcModeOperModeName=appcModeOperModeName, appcLluOperLocalAddress=appcLluOperLocalAddress, appcCnosResponsible=appcCnosResponsible, appcLuPairOperLinkObjId=appcLuPairOperLinkObjId, appcActSessRecvNxWndwSize=appcActSessRecvNxWndwSize, appcSessStatsRcvdFmdRus=appcSessStatsRcvdFmdRus, appcSessRtpEntry=appcSessRtpEntry, appcTpAdminPipSubNum=appcTpAdminPipSubNum, appcLluAdminCompRleBeforeLZ=appcLluAdminCompRleBeforeLZ, appcModeOperPtmCwin=appcModeOperPtmCwin, appcModeOperPtmClos=appcModeOperPtmClos, appcCpicAdminLocLuName=appcCpicAdminLocLuName, appcTpAdminEntry=appcTpAdminEntry, appcTpAdminLongRun=appcTpAdminLongRun, appcHistConvEntry=appcHistConvEntry, appcLuPairAdminParLuAlias=appcLuPairAdminParLuAlias, appcModeOperSendRuSzUpBnd=appcModeOperSendRuSzUpBnd, appcLluAdminAlias=appcLluAdminAlias, appcCnosForce=appcCnosForce, appcSessStatsCtrUpTime=appcSessStatsCtrUpTime, appcActiveConvSessIndex=appcActiveConvSessIndex, appcControlConfGroup=appcControlConfGroup, appcModeOperInBoundCompLevel=appcModeOperInBoundCompLevel, appcCnosMinClosLimit=appcCnosMinClosLimit, appcModeOperSessLimit=appcModeOperSessLimit, appcCnosTargetLocLuName=appcCnosTargetLocLuName, appcActiveConvPcid=appcActiveConvPcid, appcLuPairAdminParLuName=appcLuPairAdminParLuName, appcHistSessComponentId=appcHistSessComponentId, appcCntrlOperRscv=appcCntrlOperRscv, appcHistConvPcidNauName=appcHistConvPcidNauName, appcCpicAdminEntry=appcCpicAdminEntry, appcCompliances=appcCompliances, appcActiveConvParLuName=appcActiveConvParLuName, appcModeAdminSendRuSzLoBnd=appcModeAdminSendRuSzLoBnd, appcObjects=appcObjects, appcCntrlAdminTraceParm=appcCntrlAdminTraceParm, appcCnosDrainSelf=appcCnosDrainSelf, appcModeOperSendPacWinSz=appcModeOperSendPacWinSz, appcModeAdminCosName=appcModeAdminCosName, appcModeAdminRecvRuSzLoBnd=appcModeAdminRecvRuSzLoBnd, appcCntrlOperTraceTime=appcCntrlOperTraceTime, appcLluAdminTable=appcLluAdminTable, appcModeOperMaxSessLimit=appcModeOperMaxSessLimit, appcLuPairAdminParaSessSup=appcLuPairAdminParaSessSup, appcSessStatsSentFmdBytes=appcSessStatsSentFmdBytes, appcCnosControl=appcCnosControl, appcActiveConvRcvBytes=appcActiveConvRcvBytes, appcTpAdminTpOperation=appcTpAdminTpOperation, appcGlobalObjects=appcGlobalObjects, appcLluAdminLocalAddress=appcLluAdminLocalAddress, appcModeOperCompression=appcModeOperCompression, appcHistConvLocLuName=appcHistConvLocLuName, appcModeAdminRecvPacWinSz=appcModeAdminRecvPacWinSz, appcModeOperConWinAutoActLmt=appcModeOperConWinAutoActLmt, appcActiveConvPcidNauName=appcActiveConvPcidNauName, appcModeOperPndCwin=appcModeOperPndCwin, appcDefaultTpConvSecRqd=appcDefaultTpConvSecRqd, appcSessStatsLocLuName=appcSessStatsLocLuName, appcActiveConvSendBytes=appcActiveConvSendBytes, appcHistConvEndTime=appcHistConvEndTime, appcCPIC=appcCPIC, appcHistConvPcid=appcHistConvPcid, appcLuPairOperSessSec=appcLuPairOperSessSec, appcLluAdminSessLimit=appcLluAdminSessLimit, appcCntrlAdminTrace=appcCntrlAdminTrace, appcHistSessTime=appcHistSessTime, appcDefaultTpOperation=appcDefaultTpOperation, appcCntrlOperTraceParm=appcCntrlOperTraceParm, appcLuPairAdminTable=appcLuPairAdminTable, appcModeAdminEntry=appcModeAdminEntry, appcLluAdminCompression=appcLluAdminCompression)
mibBuilder.exportSymbols("APPC-MIB", appcActSessCosName=appcActSessCosName, appcHistSessEntry=appcHistSessEntry, appcModeAdminSingSessReinit=appcModeAdminSingSessReinit, appcActiveConvState=appcActiveConvState, appcLluOperBindRspMayQ=appcLluOperBindRspMayQ, appcMIB=appcMIB, appcActiveHprSessions=appcActiveHprSessions, appcModeAdminParLuName=appcModeAdminParLuName, appcTpAdminStartParm=appcTpAdminStartParm, appcLluOperCompression=appcLluOperCompression, appcSessStatsRcvdFmdBytes=appcSessStatsRcvdFmdBytes, appcModeOperTable=appcModeOperTable, appcActiveConvTable=appcActiveConvTable, appcModeAdminSendRuSzUpBnd=appcModeAdminSendRuSzUpBnd, appcActiveConvLocLuName=appcActiveConvLocLuName, appcHistSessTable=appcHistSessTable, appcDefaultMaxMcLlSndSize=appcDefaultMaxMcLlSndSize, appcCpicAdminTpName=appcCpicAdminTpName, appcTpAdminConvDuplex=appcTpAdminConvDuplex, appcModeAdminMaxSessLimit=appcModeAdminMaxSessLimit, appcCpicOperTpName=appcCpicOperTpName, appcLluAdminBindRspMayQ=appcLluAdminBindRspMayQ, appcHistConvTpName=appcHistConvTpName, appcDefaultLuName=appcDefaultLuName, appcHistConvParLuName=appcHistConvParLuName, appcCpicOperTable=appcCpicOperTable, appcLluOperInBoundCompLevel=appcLluOperInBoundCompLevel, appcLuPairAdminEntry=appcLuPairAdminEntry, appcCntrlOperRscvTime=appcCntrlOperRscvTime, appcLuPairAdminLinkObjId=appcLuPairAdminLinkObjId, appcCntrlAdminRscv=appcCntrlAdminRscv, appcActSessTransPriority=appcActSessTransPriority, appcLuPairAdminSessSec=appcLuPairAdminSessSec, appcModeOperSyncLvlLastStart=appcModeOperSyncLvlLastStart, appcActiveConvId=appcActiveConvId, appcActSessPcidCpName=appcActSessPcidCpName, appcGlobal=appcGlobal, appcHistSessIndex=appcHistSessIndex, appcActiveConvSyncLvl=appcActiveConvSyncLvl, appcModeAdminSendPacWinSz=appcModeAdminSendPacWinSz, appcModeAdminCrypto=appcModeAdminCrypto, appcActSessSndPacingSize=appcActSessSndPacingSize, appcHistConvLogData=appcHistConvLogData, appcTpAdminConvType=appcTpAdminConvType, appcLuPairOperLocLuName=appcLuPairOperLocLuName, appcLluAdminOutBoundCompLevel=appcLluAdminOutBoundCompLevel, appcTpAdminConvSecReq=appcTpAdminConvSecReq, appcSessStatsSentNonFmdBytes=appcSessStatsSentNonFmdBytes, appcCpicOperLocLuName=appcCpicOperLocLuName, appcHistSessDetectModule=appcHistSessDetectModule, appcCpicConfGroup=appcCpicConfGroup, appcLluOperSessLimit=appcLluOperSessLimit, appcGlobalConfGroup=appcGlobalConfGroup)
