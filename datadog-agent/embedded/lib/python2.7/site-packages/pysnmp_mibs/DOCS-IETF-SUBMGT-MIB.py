#
# PySNMP MIB module DOCS-IETF-SUBMGT-MIB (http://pysnmp.sf.net)
# ASN.1 source http://mibs.snmplabs.com:80/asn1/DOCS-IETF-SUBMGT-MIB
# Produced by pysmi-0.0.7 at Sun Feb 14 00:10:10 2016
# On host bldfarm platform Linux version 4.1.13-100.fc21.x86_64 by user goose
# Using Python version 3.5.0 (default, Jan  5 2016, 17:11:52) 
#
( OctetString, ObjectIdentifier, Integer, ) = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint")
( diffServDataPathStorage, diffServAlgDropStorage, diffServMIBMultiFieldClfrGroup, diffServClfrElementStatus, diffServMIBCounterGroup, diffServActionStorage, diffServClfrElementStorage, diffServCountActStorage, diffServAlgDropStatus, diffServMIBClfrGroup, diffServMIBAlgDropGroup, diffServDataPathStatus, diffServMultiFieldClfrDstAddr, diffServClfrStorage, diffServMIBActionGroup, diffServClfrStatus, diffServMIBClfrElementGroup, diffServMIBDataPathGroup, diffServAlgDropType, diffServMultiFieldClfrAddrType, diffServMultiFieldClfrSrcAddr, diffServMultiFieldClfrStorage, ) = mibBuilder.importSymbols("DIFFSERV-MIB", "diffServDataPathStorage", "diffServAlgDropStorage", "diffServMIBMultiFieldClfrGroup", "diffServClfrElementStatus", "diffServMIBCounterGroup", "diffServActionStorage", "diffServClfrElementStorage", "diffServCountActStorage", "diffServAlgDropStatus", "diffServMIBClfrGroup", "diffServMIBAlgDropGroup", "diffServDataPathStatus", "diffServMultiFieldClfrDstAddr", "diffServClfrStorage", "diffServMIBActionGroup", "diffServClfrStatus", "diffServMIBClfrElementGroup", "diffServMIBDataPathGroup", "diffServAlgDropType", "diffServMultiFieldClfrAddrType", "diffServMultiFieldClfrSrcAddr", "diffServMultiFieldClfrStorage")
( docsIfCmtsCmStatusEntry, docsIfCmtsCmStatusIndex, ) = mibBuilder.importSymbols("DOCS-IF-MIB", "docsIfCmtsCmStatusEntry", "docsIfCmtsCmStatusIndex")
( InetAddressType, InetAddress, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
( NotificationGroup, ObjectGroup, ModuleCompliance, ) = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
( Counter64, TimeTicks, iso, Integer32, ObjectIdentity, MibIdentifier, Gauge32, Unsigned32, IpAddress, NotificationType, Counter32, mib_2, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, ModuleIdentity, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "TimeTicks", "iso", "Integer32", "ObjectIdentity", "MibIdentifier", "Gauge32", "Unsigned32", "IpAddress", "NotificationType", "Counter32", "mib-2", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "ModuleIdentity")
( StorageType, RowStatus, DisplayString, TextualConvention, TimeStamp, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "StorageType", "RowStatus", "DisplayString", "TextualConvention", "TimeStamp", "TruthValue")
docsSubMgt = ModuleIdentity((1, 3, 6, 1, 2, 1, 125)).setRevisions(("2005-03-29 00:00",))
if mibBuilder.loadTexts: docsSubMgt.setLastUpdated('200503290000Z')
if mibBuilder.loadTexts: docsSubMgt.setOrganization('IETF IP over Cable Data Network (IPCDN) Working\n                     Group')
if mibBuilder.loadTexts: docsSubMgt.setContactInfo('        Wilson Sawyer\n         Postal: 50 Kelly Brook Lane\n                 East Hampstead, NH 03826\n                 U.S.A.\n\n         Phone:  +1 603 382 7080\n         E-mail: wsawyer@ieee.org\n\n         IETF IPCDN Working Group\n         General Discussion: ipcdn@ietf.org\n         Subscribe: http://www.ietf.org/mailman/listinfo/ipcdn\n         Archive: ftp://ftp.ietf.org/ietf-mail-archive/ipcdn\n         Co-chairs: Richard Woundy, Richard_Woundy@cable.comcast.com\n                    Jean-Francois Mule, jf.mule@cablelabs.com')
if mibBuilder.loadTexts: docsSubMgt.setDescription("This is the CMTS centric subscriber management MIB for\n    DOCSIS-compliant CMTS.  It provides the objects to allow a Cable\n    Modem Termination operator to control the IP addresses and\n    protocols associated with subscribers' cable modems.\n\n\n\n\n\n\n    Copyright (C) The Internet Society (2005).  This version of this\n    MIB module is part of RFC 4036; see the RFC itself for full legal\n    notices.")
docsSubMgtObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 125, 1))
docsSubMgtCpeControlTable = MibTable((1, 3, 6, 1, 2, 1, 125, 1, 1), )
if mibBuilder.loadTexts: docsSubMgtCpeControlTable.setDescription('This table AUGMENTs the docsIfCmtsCmStatusTable, adding\n    four WRITEable objects, as well as a read-only object, all of\n    which reflect the state of subscriber management on a particular\n    CM.')
docsSubMgtCpeControlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 125, 1, 1, 1), )
docsIfCmtsCmStatusEntry.registerAugmentions(("DOCS-IETF-SUBMGT-MIB", "docsSubMgtCpeControlEntry"))
docsSubMgtCpeControlEntry.setIndexNames(*docsIfCmtsCmStatusEntry.getIndexNames())
if mibBuilder.loadTexts: docsSubMgtCpeControlEntry.setDescription('A row in the docsSubMgtCpeControlTable.  All values are set\n    at successful modem registration, either from the system default,\n    or from objects included in the DOCSIS registration request sent\n    upstream to the CMTS from the CM.  The contents of this entry are\n    meaningless unless the corresponding docsIfCmtsCmStatusValue (see\n    reference) is registrationComplete(6).  The persistence of this\n    row is determined solely by the lifespan of the corresponding\n    docsIfCmtsCmStatusEntry (normally StorageType=volatile).')
docsSubMgtCpeControlMaxCpeIp = MibTableColumn((1, 3, 6, 1, 2, 1, 125, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsSubMgtCpeControlMaxCpeIp.setDescription('The number of simultaneous IP addresses permitted behind\n    the CM.  If this is set to zero, all CPE traffic from the CM is\n    dropped.  If the provisioning object corresponding to\n    docsSubMgtCpeIpTable includes more CPE IP address entries for\n    this modem than the value of this object, then this object is\n    set to the count of the number of rows in docsSubMgtCpeIpTable\n    that have the same docsIfCmtsCmStatusIndex value.  (For example,\n    if the CM has 5 IP addresses specified for it, this value is 5.)\n    This limit applies to learned and DOCSIS-provisioned entries\n    but not to entries added through some administrative\n    process at the CMTS.  If not set through DOCSIS provisioning,\n    this object defaults to docsSubMgtCpeMaxIpDefault.  Note that\n    this object is only meaningful if docsSubMgtCpeControlActive\n    is true.')
docsSubMgtCpeControlActive = MibTableColumn((1, 3, 6, 1, 2, 1, 125, 1, 1, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsSubMgtCpeControlActive.setDescription('Controls the application of subscriber management to\n    this cable modem.  If this is set to true, CMTS-based CPE\n    control is active, and all the actions required by the various\n    filter tables and controls apply at the CMTS.  If this is set\n    to false, no subscriber management filtering is done at the\n    CMTS (but other filters may apply).  If not set through DOCSIS\n    provisioning, this object defaults to\n    docsSubMgtCpeActiveDefault.')
docsSubMgtCpeControlLearnable = MibTableColumn((1, 3, 6, 1, 2, 1, 125, 1, 1, 1, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsSubMgtCpeControlLearnable.setDescription('Controls whether the CMTS may learn (and pass traffic\n    for) CPE IP addresses associated with a cable modem.  If this is\n    set to true, the CMTS may learn up to docsSubMgtMaxCpeIp\n\n\n\n    addresses (less any DOCSIS-provisioned entries) related to this\n    CM.  Those IP addresses are added (by internal process) to the\n    docsSubMgtCpeIpTable.  The nature of the learning mechanism is\n    not specified here.\n\n    If not set through DOCSIS provisioning, this object defaults to\n    docsSubMgtCpeLearnableDefault.  Note that this object is only\n    meaningful if docsSubMgtCpeControlActive is true.')
docsSubMgtCpeControlReset = MibTableColumn((1, 3, 6, 1, 2, 1, 125, 1, 1, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsSubMgtCpeControlReset.setDescription("This object always returns false on read.  If this object is\n    set to true, the rows with 'learned' addresses in\n    docsSubMgtCpeIpTable for this CM are deleted from that table.")
docsSubMgtCpeControlLastReset = MibTableColumn((1, 3, 6, 1, 2, 1, 125, 1, 1, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsSubMgtCpeControlLastReset.setDescription('The value of sysUpTime when docsSubMgtCpeControlReset was\n    last set true.  Zero if never reset.')
docsSubMgtCpeMaxIpDefault = MibScalar((1, 3, 6, 1, 2, 1, 125, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsSubMgtCpeMaxIpDefault.setDescription('The default value for docsSubMgtCpeControlMaxCpeIp if not\n    signaled in the DOCSIS Registration request.  This value should\n    be treated as nonvolatile; if set, its value should persist\n    across device resets.')
docsSubMgtCpeActiveDefault = MibScalar((1, 3, 6, 1, 2, 1, 125, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsSubMgtCpeActiveDefault.setDescription('The default value for docsSubMgtCpeControlActive if not\n\n\n\n    signaled in the DOCSIS Registration request.  This value should\n    be treated as nonvolatile; if set, its value should persist\n    across device resets.')
docsSubMgtCpeLearnableDefault = MibScalar((1, 3, 6, 1, 2, 1, 125, 1, 4), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsSubMgtCpeLearnableDefault.setDescription('The default value for docsSubMgtCpeControlLearnable if not\n    signaled in the DOCSIS Registration request.  This value should\n    be treated as nonvolatile; if set, its value should persist\n    across device resets.')
docsSubMgtCpeIpTable = MibTable((1, 3, 6, 1, 2, 1, 125, 1, 5), )
if mibBuilder.loadTexts: docsSubMgtCpeIpTable.setDescription('A table of CPE IP addresses known on a per-CM basis.')
docsSubMgtCpeIpEntry = MibTableRow((1, 3, 6, 1, 2, 1, 125, 1, 5, 1), ).setIndexNames((0, "DOCS-IF-MIB", "docsIfCmtsCmStatusIndex"), (0, "DOCS-IETF-SUBMGT-MIB", "docsSubMgtCpeIpIndex"))
if mibBuilder.loadTexts: docsSubMgtCpeIpEntry.setDescription("An entry in the docsSubMgtCpeIpTable.  The first index is\n    the specific modem we're referring to, and the second index is\n    the specific CPE IP entry.")
docsSubMgtCpeIpIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 125, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647)))
if mibBuilder.loadTexts: docsSubMgtCpeIpIndex.setDescription('The index of this CPE IP address relative to the indexed CM.\n    An entry is created either through the included CPE IP addresses\n    in the provisioning object, or via learning.\n\n    If docsSubMgtCpeControlActive is true and a CMTS receives\n    an IP packet from a CM that contains a source IP address that\n    does not match one of the docsSubMgtCpeIpAddr entries for this\n    CM, one of two things occurs.  If the number of entries is less\n    than docsSubMgtCpeControlMaxCpeIp, the source address is added to\n    the table and the packet is forwarded.  If the number of entries\n    equals the docsSubMgtCpeControlMaxCpeIp, then the packet is\n    dropped.')
docsSubMgtCpeIpAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 125, 1, 5, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsSubMgtCpeIpAddressType.setDescription('The type of internet address of docsSubMgtCpeIpAddr.')
docsSubMgtCpeIpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 125, 1, 5, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsSubMgtCpeIpAddr.setDescription('The IP address either set from provisioning or learned via\n    address gleaning or other forwarding means.  See\n    docsSubMgtCpeIpIndex for the mechanism.\n\n    The type of this address is determined by the value of\n    docsSubMgtCpeIpAddressType.')
docsSubMgtCpeIpLearned = MibTableColumn((1, 3, 6, 1, 2, 1, 125, 1, 5, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsSubMgtCpeIpLearned.setDescription('If true, this entry was learned from IP packets sent\n    upstream rather than from the provisioning objects.')
docsSubMgtCmFilterTable = MibTable((1, 3, 6, 1, 2, 1, 125, 1, 6), )
if mibBuilder.loadTexts: docsSubMgtCmFilterTable.setDescription('Binds filter groups to modems, identifying for each modem\n    the upstream and downstream filter groups that apply to packets\n    for that modem.  Normally, this table reflects the filter group\n    values signaled by DOCSIS Registration, although values may be\n    overridden by management action.\n\n    For each of the columns in this table, zero is a distinguished\n    value, indicating that the default filtering action is to be\n    taken rather than that associated with a filter group number.\n    Zero is used if the filter group is not signaled by DOCSIS\n    registration.')
docsSubMgtCmFilterEntry = MibTableRow((1, 3, 6, 1, 2, 1, 125, 1, 6, 1), )
docsIfCmtsCmStatusEntry.registerAugmentions(("DOCS-IETF-SUBMGT-MIB", "docsSubMgtCmFilterEntry"))
docsSubMgtCmFilterEntry.setIndexNames(*docsIfCmtsCmStatusEntry.getIndexNames())
if mibBuilder.loadTexts: docsSubMgtCmFilterEntry.setDescription('Binds a filter group to each direction of traffic for a\n    modem.  The filters in this entry apply if\n    docsSubMgtCpeControlActive is true.\n\n    The contents of this entry are meaningless unless the\n    corresponding docsIfCmtsCmStatusValue (see reference) is\n    registrationComplete(6).  The persistence of this row is\n    determined solely by the lifespan of the corresponding\n    docsIfCmtsCmStatusEntry (normally StorageType=volatile).')
docsSubMgtCmFilterSubDownstream = MibTableColumn((1, 3, 6, 1, 2, 1, 125, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsSubMgtCmFilterSubDownstream.setDescription('The filter group applied to traffic destined for subscribers\n    attached to the referenced CM.  Upon row creation, this is set\n    either to zero (use default classification, the\n    diffServClfrElementSpecific=zeroDotZero row of\n    diffServClfrElementTable) or to the value in the provisioning\n    object sent upstream from the CM to the CMTS during registration.\n    The value of this object is the same as that of the filter group\n    index appearing as docsSubMgtFilterGroupIndex.')
docsSubMgtCmFilterSubUpstream = MibTableColumn((1, 3, 6, 1, 2, 1, 125, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsSubMgtCmFilterSubUpstream.setDescription('The filter group applied to traffic originating from\n    subscribers attached to the referenced CM.  Upon row creation\n    this is set to either zero (use default classification, the\n    diffServClfrElementSpecific=zeroDotZero row of\n    diffServClfrElementTable), or to the value in the provisioning\n    object sent upstream from the CM to the CMTS.  The value of this\n    object is the same as that of the filter group index appearing as\n    docsSubMgtFilterGroupIndex.')
docsSubMgtCmFilterCmDownstream = MibTableColumn((1, 3, 6, 1, 2, 1, 125, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsSubMgtCmFilterCmDownstream.setDescription('The filter group applied to traffic destined for the\n    referenced CM itself.  Upon row creation this is set either to\n    zero (use default classification, the\n    diffServClfrElementSpecific=zeroDotZero row of\n    diffServClfrElementTable), or to the value in the provisioning\n    object sent upstream from the CM to the CMTS during registration.\n    The value of this object is the same as that of the filter group\n    index appearing as docsSubMgtFilterGroupIndex.')
docsSubMgtCmFilterCmUpstream = MibTableColumn((1, 3, 6, 1, 2, 1, 125, 1, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsSubMgtCmFilterCmUpstream.setDescription('The filter group applied to traffic originating from the\n    referenced CM itself.  This is set upon row creation to either\n\n\n\n    zero (use default classification, the\n    diffServClfrElementSpecific=zeroDotZero row of\n    diffServClfrElementTable), or to the value in the provisioning\n    object sent upstream from the CM to the CMTS during registration.\n    The value of this object is the same as the filter group index\n    appearing as docsSubMgtFilterGroupIndex.')
docsSubMgtFilterGroupTable = MibTable((1, 3, 6, 1, 2, 1, 125, 1, 7), )
if mibBuilder.loadTexts: docsSubMgtFilterGroupTable.setDescription('Provides a collection of referenceable entries to which\n    diffServClfrElementSpecific refers.  This table provides filter\n    group indices that can be compared with those signaled during\n    DOCSIS registration.  A packet matches an entry from this table\n    if the packet originated from or is destined to a cable modem\n    that registered this index as one of its four filter groups\n    (see docsSubMgtCmFilterTable), and if the packet direction and\n    MAC address select the use of this index among the four.')
docsSubMgtFilterGroupEntry = MibTableRow((1, 3, 6, 1, 2, 1, 125, 1, 7, 1), ).setIndexNames((0, "DOCS-IETF-SUBMGT-MIB", "docsSubMgtFilterGroupIndex"))
if mibBuilder.loadTexts: docsSubMgtFilterGroupEntry.setDescription("An entry only exists if needed by the\n    diffServClfrElementEntry.  A packet matches this entry if the\n    packet's cable modem registered this index as one of its four\n    filter groups (see docsSubMgtCmFilterTable) and if the packet\n    direction and MAC address select the use of this index among\n    the four.")
docsSubMgtFilterGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 125, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsSubMgtFilterGroupIndex.setDescription("The filter group index, from the set signaled at DOCSIS\n\n\n\n    Registration.  Provides a referenceable entry to which\n    diffServClfrElementSpecific points.  A packet matches this\n    classifier entry if the packet's cable modem registered this\n    index value as one of its four filter groups, and if the packet\n    direction and MAC address select the use of this index among\n    the four.  Because this is the only field in this table, it is\n    read-only, contrary to the usual SMI custom of making indices\n    not-accessible.\n\n    Note that although zero may be signaled (or defaulted) at DOCSIS\n    Registration to indicate a default filtering group, no such entry\n    appears in this table, as diffServClfrElementSpecific will\n    use a zeroDotZero pointer for that classification.")
docsSubMgtConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 125, 2))
docsSubMgtCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 125, 2, 1))
docsSubMgtGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 125, 2, 2))
docsSubMgtBasicCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 125, 2, 1, 1)).setObjects(*(("DIFFSERV-MIB", "diffServMIBDataPathGroup"), ("DIFFSERV-MIB", "diffServMIBClfrGroup"), ("DIFFSERV-MIB", "diffServMIBClfrElementGroup"), ("DIFFSERV-MIB", "diffServMIBMultiFieldClfrGroup"), ("DIFFSERV-MIB", "diffServMIBActionGroup"), ("DIFFSERV-MIB", "diffServMIBAlgDropGroup"), ("DIFFSERV-MIB", "diffServMIBCounterGroup"), ("DOCS-IETF-SUBMGT-MIB", "docsSubMgtGroup"),))
if mibBuilder.loadTexts: docsSubMgtBasicCompliance.setDescription('The compliance statement for CMTS devices that implement\n    CMTS centric subscriber management.\n\n    This compliance statement applies to implementations that\n    support DOCSIS 1.0/1.1/2.0, which are not IPv6 capable.')
docsSubMgtGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 125, 2, 2, 1)).setObjects(*(("DOCS-IETF-SUBMGT-MIB", "docsSubMgtCpeControlMaxCpeIp"), ("DOCS-IETF-SUBMGT-MIB", "docsSubMgtCpeControlActive"), ("DOCS-IETF-SUBMGT-MIB", "docsSubMgtCpeControlLearnable"), ("DOCS-IETF-SUBMGT-MIB", "docsSubMgtCpeControlReset"), ("DOCS-IETF-SUBMGT-MIB", "docsSubMgtCpeControlLastReset"), ("DOCS-IETF-SUBMGT-MIB", "docsSubMgtCpeMaxIpDefault"), ("DOCS-IETF-SUBMGT-MIB", "docsSubMgtCpeActiveDefault"), ("DOCS-IETF-SUBMGT-MIB", "docsSubMgtCpeLearnableDefault"), ("DOCS-IETF-SUBMGT-MIB", "docsSubMgtCpeIpAddressType"), ("DOCS-IETF-SUBMGT-MIB", "docsSubMgtCpeIpAddr"), ("DOCS-IETF-SUBMGT-MIB", "docsSubMgtCpeIpLearned"), ("DOCS-IETF-SUBMGT-MIB", "docsSubMgtCmFilterSubDownstream"), ("DOCS-IETF-SUBMGT-MIB", "docsSubMgtCmFilterSubUpstream"), ("DOCS-IETF-SUBMGT-MIB", "docsSubMgtCmFilterCmDownstream"), ("DOCS-IETF-SUBMGT-MIB", "docsSubMgtCmFilterCmUpstream"), ("DOCS-IETF-SUBMGT-MIB", "docsSubMgtFilterGroupIndex"),))
if mibBuilder.loadTexts: docsSubMgtGroup.setDescription('The objects used to manage host-based cable modems\n            via a set of CMTS enforced controls.')
mibBuilder.exportSymbols("DOCS-IETF-SUBMGT-MIB", docsSubMgtCmFilterSubDownstream=docsSubMgtCmFilterSubDownstream, docsSubMgtCpeLearnableDefault=docsSubMgtCpeLearnableDefault, docsSubMgtCpeIpLearned=docsSubMgtCpeIpLearned, docsSubMgtCmFilterCmUpstream=docsSubMgtCmFilterCmUpstream, docsSubMgtCpeIpEntry=docsSubMgtCpeIpEntry, docsSubMgtCmFilterEntry=docsSubMgtCmFilterEntry, docsSubMgtCpeIpTable=docsSubMgtCpeIpTable, docsSubMgt=docsSubMgt, docsSubMgtCmFilterTable=docsSubMgtCmFilterTable, docsSubMgtCompliances=docsSubMgtCompliances, docsSubMgtCpeControlActive=docsSubMgtCpeControlActive, docsSubMgtGroups=docsSubMgtGroups, docsSubMgtCpeControlTable=docsSubMgtCpeControlTable, docsSubMgtFilterGroupTable=docsSubMgtFilterGroupTable, docsSubMgtFilterGroupEntry=docsSubMgtFilterGroupEntry, docsSubMgtConformance=docsSubMgtConformance, docsSubMgtCpeControlLastReset=docsSubMgtCpeControlLastReset, docsSubMgtCpeMaxIpDefault=docsSubMgtCpeMaxIpDefault, docsSubMgtCpeControlEntry=docsSubMgtCpeControlEntry, docsSubMgtCmFilterSubUpstream=docsSubMgtCmFilterSubUpstream, docsSubMgtFilterGroupIndex=docsSubMgtFilterGroupIndex, docsSubMgtGroup=docsSubMgtGroup, docsSubMgtCpeControlLearnable=docsSubMgtCpeControlLearnable, docsSubMgtCpeIpAddr=docsSubMgtCpeIpAddr, docsSubMgtCpeActiveDefault=docsSubMgtCpeActiveDefault, docsSubMgtCmFilterCmDownstream=docsSubMgtCmFilterCmDownstream, docsSubMgtCpeControlMaxCpeIp=docsSubMgtCpeControlMaxCpeIp, docsSubMgtObjects=docsSubMgtObjects, docsSubMgtBasicCompliance=docsSubMgtBasicCompliance, docsSubMgtCpeControlReset=docsSubMgtCpeControlReset, docsSubMgtCpeIpIndex=docsSubMgtCpeIpIndex, PYSNMP_MODULE_ID=docsSubMgt, docsSubMgtCpeIpAddressType=docsSubMgtCpeIpAddressType)
