#
# PySNMP MIB module TIME-AGGREGATE-MIB (http://pysnmp.sf.net)
# ASN.1 source http://mibs.snmplabs.com:80/asn1/TIME-AGGREGATE-MIB
# Produced by pysmi-0.0.7 at Sun Feb 14 00:31:27 2016
# On host bldfarm platform Linux version 4.1.13-100.fc21.x86_64 by user goose
# Using Python version 3.5.0 (default, Jan  5 2016, 17:11:52) 
#
( Integer, OctetString, ObjectIdentifier, ) = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint")
( OwnerString, ) = mibBuilder.importSymbols("RMON-MIB", "OwnerString")
( SnmpAdminString, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
( ModuleCompliance, ObjectGroup, NotificationGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
( MibIdentifier, TimeTicks, Gauge32, ObjectIdentity, ModuleIdentity, NotificationType, IpAddress, experimental, Opaque, Counter32, Integer32, Unsigned32, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, iso, ) = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "TimeTicks", "Gauge32", "ObjectIdentity", "ModuleIdentity", "NotificationType", "IpAddress", "experimental", "Opaque", "Counter32", "Integer32", "Unsigned32", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "iso")
( DisplayString, TextualConvention, StorageType, RowStatus, ) = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "StorageType", "RowStatus")
tAggrMIB = ModuleIdentity((1, 3, 6, 1, 3, 124)).setRevisions(("2006-04-27 00:00",))
if mibBuilder.loadTexts: tAggrMIB.setLastUpdated('200604270000Z')
if mibBuilder.loadTexts: tAggrMIB.setOrganization('Cyber Solutions Inc. NetMan Working Group')
if mibBuilder.loadTexts: tAggrMIB.setContactInfo('                      Glenn Mansfield Keeni\n                     Postal: Cyber Solutions Inc.\n                             6-6-3, Minami Yoshinari\n                             Aoba-ku, Sendai, Japan 989-3204.\n                        Tel: +81-22-303-4012\n                        Fax: +81-22-303-4015\n                     E-mail: glenn@cysols.com\n\n          Support Group E-mail: mibsupport@cysols.com')
if mibBuilder.loadTexts: tAggrMIB.setDescription('The MIB for servicing Time-Based aggregate\n                    objects.\n\n                    Copyright (C) The Internet Society (2006).  This\n                    version of this MIB module is part of RFC 4498;\n                    see the RFC itself for full legal notices.\n                  ')
class TAggrMOErrorStatus(Opaque, TextualConvention):
    subtypeSpec = Opaque.subtypeSpec+ValueSizeConstraint(0,1024)

class TimeAggrMOValue(Opaque, TextualConvention):
    subtypeSpec = Opaque.subtypeSpec+ValueSizeConstraint(0,1024)

class CompressedTimeAggrMOValue(Opaque, TextualConvention):
    subtypeSpec = Opaque.subtypeSpec+ValueSizeConstraint(0,1024)

tAggrCtlTable = MibTable((1, 3, 6, 1, 3, 124, 1), )
if mibBuilder.loadTexts: tAggrCtlTable.setDescription('The Time-Based aggregation control table.  It controls\n            the aggregation of the samples of MO instances.  There\n            will be a row for each TAgMO.\n           ')
tAggrCtlEntry = MibTableRow((1, 3, 6, 1, 3, 124, 1, 1), ).setIndexNames((0, "TIME-AGGREGATE-MIB", "tAggrCtlEntryID"))
if mibBuilder.loadTexts: tAggrCtlEntry.setDescription('A row of the control table that defines one Time-Based\n           aggregate MO (TAgMO).')
tAggrCtlEntryID = MibTableColumn((1, 3, 6, 1, 3, 124, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1,32)))
if mibBuilder.loadTexts: tAggrCtlEntryID.setDescription('A locally unique, administratively assigned name\n            for this aggregated MO.  It is used as an index to\n            uniquely identify this row in the table.')
tAggrCtlMOInstance = MibTableColumn((1, 3, 6, 1, 3, 124, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tAggrCtlMOInstance.setDescription('The sampled values of this MO instance will be\n            aggregated by the TAgMO.\n            ')
tAggrCtlAgMODescr = MibTableColumn((1, 3, 6, 1, 3, 124, 1, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0,64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tAggrCtlAgMODescr.setDescription('A textual description of the aggregate object.')
tAggrCtlInterval = MibTableColumn((1, 3, 6, 1, 3, 124, 1, 1, 4), Integer32()).setUnits('micro seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tAggrCtlInterval.setDescription('The interval, in microseconds, at which the MO instance\n            pointed at by tAggrInstance will be sampled for\n            Time-Based aggregation.\n          ')
tAggrCtlSamples = MibTableColumn((1, 3, 6, 1, 3, 124, 1, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tAggrCtlSamples.setDescription('The number of times at which the MO instance referred\n            to by tAggrInstance will be sampled for Time-Based\n            aggregation.')
tAggrCtlCompressionAlgorithm = MibTableColumn((1, 3, 6, 1, 3, 124, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("none", 1), ("deflate", 2),)).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tAggrCtlCompressionAlgorithm.setDescription('The compression algorithm that will be used by\n            the agent to compress the value of the TAgMO.\n            The deflate algorithm and corresponding data format\n            specification is described in RFC 1951.  It is\n            compatible with the widely used gzip utility.\n          ')
tAggrCtlEntryOwner = MibTableColumn((1, 3, 6, 1, 3, 124, 1, 1, 7), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tAggrCtlEntryOwner.setDescription('A textual description of the entity that created\n            this entry.\n          ')
tAggrCtlEntryStorageType = MibTableColumn((1, 3, 6, 1, 3, 124, 1, 1, 8), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tAggrCtlEntryStorageType.setDescription("This object defines whether the parameters defined in\n            this row are kept in volatile storage and lost upon\n            reboot or backed up by non-volatile (permanent)\n            storage.\n            Conceptual rows having the value 'permanent' need not\n            allow write-access to any columnar objects in the row.\n           ")
tAggrCtlEntryStatus = MibTableColumn((1, 3, 6, 1, 3, 124, 1, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tAggrCtlEntryStatus.setDescription("The row status variable, used according to row\n            installation and removal conventions.\n            Objects in a row can be modified only when the value of\n            this object in the corresponding conceptual row is not\n            'active'.\n            Thus, to modify one or more of the objects in this\n            conceptual row,\n              a. change the row status to 'notInService',\n              b. change the values of the row, and\n              c. change the row status to 'active'.\n            The tAggrCtlEntryStatus may be changed to 'active' iff\n            all the MOs in the conceptual row have been assigned\n            valid values.\n           ")
tAggrDataTable = MibTable((1, 3, 6, 1, 3, 124, 2), )
if mibBuilder.loadTexts: tAggrDataTable.setDescription('This is the data table.  Each row of this table contains\n            information about a TAgMO indexed by tAggrCtlEntryID.\n            tAggrCtlEntryID is the key to the table.  It is used to\n            identify instances of the TAgMO that are present in the\n            table.\n          ')
tAggrDataEntry = MibTableRow((1, 3, 6, 1, 3, 124, 2, 1), ).setIndexNames((0, "TIME-AGGREGATE-MIB", "tAggrCtlEntryID"))
if mibBuilder.loadTexts: tAggrDataEntry.setDescription('Entry containing information pertaining\n            to a TAgMO.')
tAggrDataRecord = MibTableColumn((1, 3, 6, 1, 3, 124, 2, 1, 1), TimeAggrMOValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tAggrDataRecord.setDescription('The snapshot value of the TAgMO.')
tAggrDataRecordCompressed = MibTableColumn((1, 3, 6, 1, 3, 124, 2, 1, 2), CompressedTimeAggrMOValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tAggrDataRecordCompressed.setDescription("The compressed value of the TAgMO.\n           The compression algorithm will depend on the\n           tAggrCtlCompressionAlgorithm given in the corresponding\n           tAggrCtlEntry.  If the value of the corresponding\n           tAggrCtlCompressionAlgorithm is (1) 'none', then the\n\n\n\n           value of all instances of this object will be a string\n           of zero length.\n           Note that the access privileges to this object will be\n           governed by the access privileges of the corresponding MO\n           instance.  Thus, an entity attempting to access an\n           instance of this MO MUST have access rights to the\n           instance object pointed at by tAggrCtlMOInstance and this\n           MO instance.\n          ")
tAggrDataErrorRecord = MibTableColumn((1, 3, 6, 1, 3, 124, 2, 1, 3), TAggrMOErrorStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tAggrDataErrorRecord.setDescription('The error status corresponding to the MO instance\n            samples aggregated in tAggrDataRecord (and\n            tAggrDataRecordCompressed).')
tAggrConformance = MibIdentifier((1, 3, 6, 1, 3, 124, 3))
tAggrGroups = MibIdentifier((1, 3, 6, 1, 3, 124, 3, 1))
tAggrCompliances = MibIdentifier((1, 3, 6, 1, 3, 124, 3, 2))
tAggrMibCompliance = ModuleCompliance((1, 3, 6, 1, 3, 124, 3, 2, 1)).setObjects(*(("TIME-AGGREGATE-MIB", "tAggrMibBasicGroup"),))
if mibBuilder.loadTexts: tAggrMibCompliance.setDescription('The compliance statement for SNMP entities\n                 that implement the TIME-AGGREGATE-MIB.')
tAggrMibBasicGroup = ObjectGroup((1, 3, 6, 1, 3, 124, 3, 1, 1)).setObjects(*(("TIME-AGGREGATE-MIB", "tAggrCtlMOInstance"), ("TIME-AGGREGATE-MIB", "tAggrCtlAgMODescr"), ("TIME-AGGREGATE-MIB", "tAggrCtlInterval"), ("TIME-AGGREGATE-MIB", "tAggrCtlSamples"), ("TIME-AGGREGATE-MIB", "tAggrCtlCompressionAlgorithm"), ("TIME-AGGREGATE-MIB", "tAggrCtlEntryOwner"), ("TIME-AGGREGATE-MIB", "tAggrCtlEntryStorageType"), ("TIME-AGGREGATE-MIB", "tAggrCtlEntryStatus"), ("TIME-AGGREGATE-MIB", "tAggrDataRecord"), ("TIME-AGGREGATE-MIB", "tAggrDataRecordCompressed"), ("TIME-AGGREGATE-MIB", "tAggrDataErrorRecord"),))
if mibBuilder.loadTexts: tAggrMibBasicGroup.setDescription('A collection of objects for Time-Based aggregation\n                  of MOs.')
mibBuilder.exportSymbols("TIME-AGGREGATE-MIB", tAggrDataRecordCompressed=tAggrDataRecordCompressed, tAggrCtlSamples=tAggrCtlSamples, tAggrCompliances=tAggrCompliances, tAggrMibCompliance=tAggrMibCompliance, tAggrDataRecord=tAggrDataRecord, tAggrGroups=tAggrGroups, tAggrCtlEntryOwner=tAggrCtlEntryOwner, TimeAggrMOValue=TimeAggrMOValue, tAggrDataErrorRecord=tAggrDataErrorRecord, tAggrDataEntry=tAggrDataEntry, tAggrConformance=tAggrConformance, tAggrCtlTable=tAggrCtlTable, tAggrCtlEntryStatus=tAggrCtlEntryStatus, tAggrDataTable=tAggrDataTable, tAggrCtlEntry=tAggrCtlEntry, CompressedTimeAggrMOValue=CompressedTimeAggrMOValue, TAggrMOErrorStatus=TAggrMOErrorStatus, tAggrMIB=tAggrMIB, tAggrMibBasicGroup=tAggrMibBasicGroup, tAggrCtlEntryID=tAggrCtlEntryID, tAggrCtlAgMODescr=tAggrCtlAgMODescr, tAggrCtlCompressionAlgorithm=tAggrCtlCompressionAlgorithm, tAggrCtlMOInstance=tAggrCtlMOInstance, tAggrCtlInterval=tAggrCtlInterval, tAggrCtlEntryStorageType=tAggrCtlEntryStorageType, PYSNMP_MODULE_ID=tAggrMIB)
