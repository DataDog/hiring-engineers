#
# PySNMP MIB module MAU-MIB (http://pysnmp.sf.net)
# ASN.1 source http://mibs.snmplabs.com:80/asn1/MAU-MIB
# Produced by pysmi-0.0.7 at Sun Feb 14 00:20:03 2016
# On host bldfarm platform Linux version 4.1.13-100.fc21.x86_64 by user goose
# Using Python version 3.5.0 (default, Jan  5 2016, 17:11:52) 
#
( OctetString, ObjectIdentifier, Integer, ) = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
( InterfaceIndex, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
( NotificationGroup, ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
( Integer32, Counter32, ObjectIdentity, mib_2, Bits, TimeTicks, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Gauge32, Counter64, ModuleIdentity, NotificationType, Unsigned32, MibIdentifier, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Counter32", "ObjectIdentity", "mib-2", "Bits", "TimeTicks", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Gauge32", "Counter64", "ModuleIdentity", "NotificationType", "Unsigned32", "MibIdentifier")
( TextualConvention, TruthValue, AutonomousType, DisplayString, ) = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TruthValue", "AutonomousType", "DisplayString")
mauMod = ModuleIdentity((1, 3, 6, 1, 2, 1, 26, 6)).setRevisions(("2003-09-19 00:00", "1999-08-24 04:00", "1997-10-31 00:00", "1993-09-30 00:00",))
if mibBuilder.loadTexts: mauMod.setLastUpdated('200309190000Z')
if mibBuilder.loadTexts: mauMod.setOrganization('IETF Ethernet Interfaces and Hub MIB\n                        Working Group')
if mibBuilder.loadTexts: mauMod.setContactInfo('WG E-mail: hubmib@ietf.org\n             To subscribe: hubmib-request@ietf.org\n                    Chair: Dan Romascanu\n                   Postal: Avaya Inc.\n                           Atidim Technology Park, Bldg. 3\n                           Tel Aviv 61131\n                           Israel\n                      Tel: +972 3 645 8414\n                   E-mail: dromasca@avaya.com\n                   Editor: John Flick\n                   Postal: Hewlett-Packard Company\n                           8000 Foothills Blvd. M/S 5557\n                           Roseville, CA 95747-5557\n                           USA\n                      Tel: +1 916 785 4018\n                      Fax: +1 916 785 1199\n                   E-mail: johnf@rose.hp.com')
if mibBuilder.loadTexts: mauMod.setDescription("Management information for 802.3 MAUs.\n\n                       The following reference is used throughout\n                       this MIB module:\n\n                       [IEEE 802.3 Std] refers to:\n                          IEEE Std 802.3, 2002 Edition: 'IEEE Standard\n                          for Information technology -\n                          Telecommunications and information exchange\n                          between systems - Local and metropolitan\n                          area networks - Specific requirements -\n                          Part 3: Carrier sense multiple access with\n                          collision detection (CSMA/CD) access method\n                          and physical layer specifications', as\n                          amended by IEEE Std 802.3ae-2002:\n                          'Amendment: Media Access Control (MAC)\n                          Parameters, Physical Layer, and Management\n                          Parameters for 10 Gb/s Operation', August,\n                          2002.\n\n                       Of particular interest is Clause 30, '10Mb/s,\n                       100Mb/s, 1000Mb/s and 10 Gb/s Management'.\n\n                       Copyright (C) The Internet Society (2003).  This\n                       version of this MIB module is part of RFC 3636;\n                       see the RFC itself for full legal notices.")
snmpDot3MauMgt = MibIdentifier((1, 3, 6, 1, 2, 1, 26))
class JackType(Integer32, TextualConvention):
    subtypeSpec = Integer32.subtypeSpec+ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,))
    namedValues = NamedValues(("other", 1), ("rj45", 2), ("rj45S", 3), ("db9", 4), ("bnc", 5), ("fAUI", 6), ("mAUI", 7), ("fiberSC", 8), ("fiberMIC", 9), ("fiberST", 10), ("telco", 11), ("mtrj", 12), ("hssdc", 13), ("fiberLC", 14),)

dot3RpMauBasicGroup = MibIdentifier((1, 3, 6, 1, 2, 1, 26, 1))
dot3IfMauBasicGroup = MibIdentifier((1, 3, 6, 1, 2, 1, 26, 2))
dot3BroadMauBasicGroup = MibIdentifier((1, 3, 6, 1, 2, 1, 26, 3))
dot3IfMauAutoNegGroup = MibIdentifier((1, 3, 6, 1, 2, 1, 26, 5))
dot3MauType = MibIdentifier((1, 3, 6, 1, 2, 1, 26, 4))
dot3MauTypeAUI = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 1))
if mibBuilder.loadTexts: dot3MauTypeAUI.setDescription('no internal MAU, view from AUI')
dot3MauType10Base5 = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 2))
if mibBuilder.loadTexts: dot3MauType10Base5.setDescription('thick coax MAU')
dot3MauTypeFoirl = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 3))
if mibBuilder.loadTexts: dot3MauTypeFoirl.setDescription('FOIRL MAU')
dot3MauType10Base2 = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 4))
if mibBuilder.loadTexts: dot3MauType10Base2.setDescription('thin coax MAU')
dot3MauType10BaseT = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 5))
if mibBuilder.loadTexts: dot3MauType10BaseT.setDescription('UTP MAU.\n                       Note that it is strongly recommended that\n                       agents return either dot3MauType10BaseTHD or\n                       dot3MauType10BaseTFD if the duplex mode is\n                       known.  However, management applications should\n                       be prepared to receive this MAU type value from\n                       older agent implementations.')
dot3MauType10BaseFP = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 6))
if mibBuilder.loadTexts: dot3MauType10BaseFP.setDescription('passive fiber MAU')
dot3MauType10BaseFB = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 7))
if mibBuilder.loadTexts: dot3MauType10BaseFB.setDescription('sync fiber MAU')
dot3MauType10BaseFL = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 8))
if mibBuilder.loadTexts: dot3MauType10BaseFL.setDescription('async fiber MAU.\n                       Note that it is strongly recommended that\n                       agents return either dot3MauType10BaseFLHD or\n                       dot3MauType10BaseFLFD if the duplex mode is\n                       known.  However, management applications should\n                       be prepared to receive this MAU type value from\n                       older agent implementations.')
dot3MauType10Broad36 = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 9))
if mibBuilder.loadTexts: dot3MauType10Broad36.setDescription('broadband DTE MAU.\n                       Note that 10BROAD36 MAUs can be attached to\n                       interfaces but not to repeaters.')
dot3MauType10BaseTHD = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 10))
if mibBuilder.loadTexts: dot3MauType10BaseTHD.setDescription('UTP MAU, half duplex mode')
dot3MauType10BaseTFD = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 11))
if mibBuilder.loadTexts: dot3MauType10BaseTFD.setDescription('UTP MAU, full duplex mode')
dot3MauType10BaseFLHD = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 12))
if mibBuilder.loadTexts: dot3MauType10BaseFLHD.setDescription('async fiber MAU, half duplex mode')
dot3MauType10BaseFLFD = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 13))
if mibBuilder.loadTexts: dot3MauType10BaseFLFD.setDescription('async fiber MAU, full duplex mode')
dot3MauType100BaseT4 = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 14))
if mibBuilder.loadTexts: dot3MauType100BaseT4.setDescription('4 pair category 3 UTP')
dot3MauType100BaseTXHD = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 15))
if mibBuilder.loadTexts: dot3MauType100BaseTXHD.setDescription('2 pair category 5 UTP, half duplex mode')
dot3MauType100BaseTXFD = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 16))
if mibBuilder.loadTexts: dot3MauType100BaseTXFD.setDescription('2 pair category 5 UTP, full duplex mode')
dot3MauType100BaseFXHD = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 17))
if mibBuilder.loadTexts: dot3MauType100BaseFXHD.setDescription('X fiber over PMT, half duplex mode')
dot3MauType100BaseFXFD = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 18))
if mibBuilder.loadTexts: dot3MauType100BaseFXFD.setDescription('X fiber over PMT, full duplex mode')
dot3MauType100BaseT2HD = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 19))
if mibBuilder.loadTexts: dot3MauType100BaseT2HD.setDescription('2 pair category 3 UTP, half duplex mode')
dot3MauType100BaseT2FD = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 20))
if mibBuilder.loadTexts: dot3MauType100BaseT2FD.setDescription('2 pair category 3 UTP, full duplex mode')
dot3MauType1000BaseXHD = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 21))
if mibBuilder.loadTexts: dot3MauType1000BaseXHD.setDescription('PCS/PMA, unknown PMD, half duplex mode')
dot3MauType1000BaseXFD = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 22))
if mibBuilder.loadTexts: dot3MauType1000BaseXFD.setDescription('PCS/PMA, unknown PMD, full duplex mode')
dot3MauType1000BaseLXHD = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 23))
if mibBuilder.loadTexts: dot3MauType1000BaseLXHD.setDescription('Fiber over long-wavelength laser, half duplex\n                       mode')
dot3MauType1000BaseLXFD = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 24))
if mibBuilder.loadTexts: dot3MauType1000BaseLXFD.setDescription('Fiber over long-wavelength laser, full duplex\n                       mode')
dot3MauType1000BaseSXHD = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 25))
if mibBuilder.loadTexts: dot3MauType1000BaseSXHD.setDescription('Fiber over short-wavelength laser, half\n                       duplex mode')
dot3MauType1000BaseSXFD = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 26))
if mibBuilder.loadTexts: dot3MauType1000BaseSXFD.setDescription('Fiber over short-wavelength laser, full\n                       duplex mode')
dot3MauType1000BaseCXHD = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 27))
if mibBuilder.loadTexts: dot3MauType1000BaseCXHD.setDescription('Copper over 150-Ohm balanced cable, half\n                       duplex mode')
dot3MauType1000BaseCXFD = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 28))
if mibBuilder.loadTexts: dot3MauType1000BaseCXFD.setDescription('Copper over 150-Ohm balanced cable, full\n                       duplex mode')
dot3MauType1000BaseTHD = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 29))
if mibBuilder.loadTexts: dot3MauType1000BaseTHD.setDescription('Four-pair Category 5 UTP, half duplex mode')
dot3MauType1000BaseTFD = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 30))
if mibBuilder.loadTexts: dot3MauType1000BaseTFD.setDescription('Four-pair Category 5 UTP, full duplex mode')
dot3MauType10GigBaseX = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 31))
if mibBuilder.loadTexts: dot3MauType10GigBaseX.setDescription('X PCS/PMA, unknown PMD.')
dot3MauType10GigBaseLX4 = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 32))
if mibBuilder.loadTexts: dot3MauType10GigBaseLX4.setDescription('X fiber over WWDM optics')
dot3MauType10GigBaseR = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 33))
if mibBuilder.loadTexts: dot3MauType10GigBaseR.setDescription('R PCS/PMA, unknown PMD.')
dot3MauType10GigBaseER = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 34))
if mibBuilder.loadTexts: dot3MauType10GigBaseER.setDescription('R fiber over 1550 nm optics')
dot3MauType10GigBaseLR = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 35))
if mibBuilder.loadTexts: dot3MauType10GigBaseLR.setDescription('R fiber over 1310 nm optics')
dot3MauType10GigBaseSR = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 36))
if mibBuilder.loadTexts: dot3MauType10GigBaseSR.setDescription('R fiber over 850 nm optics')
dot3MauType10GigBaseW = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 37))
if mibBuilder.loadTexts: dot3MauType10GigBaseW.setDescription('W PCS/PMA, unknown PMD.')
dot3MauType10GigBaseEW = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 38))
if mibBuilder.loadTexts: dot3MauType10GigBaseEW.setDescription('W fiber over 1550 nm optics')
dot3MauType10GigBaseLW = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 39))
if mibBuilder.loadTexts: dot3MauType10GigBaseLW.setDescription('W fiber over 1310 nm optics')
dot3MauType10GigBaseSW = ObjectIdentity((1, 3, 6, 1, 2, 1, 26, 4, 40))
if mibBuilder.loadTexts: dot3MauType10GigBaseSW.setDescription('W fiber over 850 nm optics')
rpMauTable = MibTable((1, 3, 6, 1, 2, 1, 26, 1, 1), )
if mibBuilder.loadTexts: rpMauTable.setDescription('Table of descriptive and status information\n                       about the MAU(s) attached to the ports of a\n                       repeater.')
rpMauEntry = MibTableRow((1, 3, 6, 1, 2, 1, 26, 1, 1, 1), ).setIndexNames((0, "MAU-MIB", "rpMauGroupIndex"), (0, "MAU-MIB", "rpMauPortIndex"), (0, "MAU-MIB", "rpMauIndex"))
if mibBuilder.loadTexts: rpMauEntry.setDescription('An entry in the table, containing information\n                       about a single MAU.')
rpMauGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauGroupIndex.setDescription('This variable uniquely identifies the group\n                       containing the port to which the MAU described\n                       by this entry is connected.\n\n                       Note:  In practice, a group will generally be\n                       a field-replaceable unit (i.e., module, card,\n                       or board) that can fit in the physical system\n                       enclosure, and the group number will correspond\n                       to a number marked on the physical enclosure.\n\n                       The group denoted by a particular value of this\n                       object is the same as the group denoted by the\n                       same value of rptrGroupIndex.')
rpMauPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauPortIndex.setDescription('This variable uniquely identifies the repeater\n                       port within group rpMauGroupIndex to which the\n                       MAU described by this entry is connected.')
rpMauIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauIndex.setDescription('This variable uniquely identifies the MAU\n                       described by this entry from among other\n                       MAUs connected to the same port\n                       (rpMauPortIndex).')
rpMauType = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 1, 1, 1, 4), AutonomousType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauType.setDescription('This object identifies the MAU type.  Values for\n                       standard IEEE 802.3 MAU types are defined above.\n                       If the MAU type is unknown, the object identifier\n\n                       unknownMauType OBJECT IDENTIFIER ::= { 0 0 }\n\n                       is returned.  Note that unknownMauType is a\n                       syntactically valid object identifier, and any\n                       conformant implementation of ASN.1 and the BER\n                       must be able to generate and recognize this\n                       value.')
rpMauStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6,))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("operational", 3), ("standby", 4), ("shutdown", 5), ("reset", 6),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rpMauStatus.setDescription("The current state of the MAU.  This object MAY\n                       be implemented as a read-only object by those\n                       agents and MAUs that do not implement software\n                       control of the MAU state.  Some agents may not\n                       support setting the value of this object to some\n                       of the enumerated values.\n\n                       The value other(1) is returned if the MAU is in\n                       a state other than one of the states 2 through\n                       6.\n\n                       The value unknown(2) is returned when the MAU's\n                       true state is unknown; for example, when it is\n                       being initialized.\n\n                       A MAU in the operational(3) state is fully\n                       functional, operates, and passes signals to its\n                       attached DTE or repeater port in accordance to\n                       its specification.\n\n                       A MAU in standby(4) state forces DI and CI to\n                       idle and the media transmitter to idle or fault,\n                       if supported.  Standby(4) mode only applies to\n                       link type MAUs.  The state of\n                       rpMauMediaAvailable is unaffected.\n\n                       A MAU in shutdown(5) state assumes the same\n                       condition on DI, CI, and the media transmitter\n                       as though it were powered down or not connected.\n                       The MAU MAY return other(1) value for the\n                       rpMauJabberState and rpMauMediaAvailable objects\n                       when it is in this state.  For an AUI, this\n                       state will remove power from the AUI.\n\n                       Setting this variable to the value reset(6)\n                       resets the MAU in the same manner as a\n                       power-off, power-on cycle of at least one-half\n                       second would.  The agent is not required to\n                       return the value reset (6).\n\n                       Setting this variable to the value\n                       operational(3), standby(4), or shutdown(5)\n                       causes the MAU to assume the respective state\n                       except that setting a mixing-type MAU or an AUI\n                       to standby(4) will cause the MAU to enter the\n                       shutdown state.")
rpMauMediaAvailable = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("available", 3), ("notAvailable", 4), ("remoteFault", 5), ("invalidSignal", 6), ("remoteJabber", 7), ("remoteLinkLoss", 8), ("remoteTest", 9), ("offline", 10), ("autoNegError", 11),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauMediaAvailable.setDescription("If the MAU is a link or fiber type (FOIRL,\n                       10BASE-T, 10BASE-F) then this is equivalent to\n                       the link test fail state/low light function.\n                       For an AUI or a coax (including broadband) MAU\n                       this indicates whether or not loopback is\n                       detected on the DI circuit.  The value of this\n                       attribute persists between packets for MAU types\n                       AUI, 10BASE5, 10BASE2, 10BROAD36, and 10BASE-FP.\n\n                       The value other(1) is returned if the\n                       mediaAvailable state is not one of 2 through 11.\n\n                       The value unknown(2) is returned when the MAU's\n                       true state is unknown; for example, when it is\n                       being initialized.  At power-up or following a\n                       reset, the value of this attribute will be\n                       unknown for AUI, coax, and 10BASE-FP MAUs.  For\n                       these MAUs loopback will be tested on each\n                       transmission during which no collision is\n                       detected.  If DI is receiving input when DO\n                       returns to IDL after a transmission and there\n                       has been no collision during the transmission\n                       then loopback will be detected.  The value of\n                       this attribute will only change during\n                       non-collided transmissions for AUI, coax, and\n                       10BASE-FP MAUs.\n\n                       For 100Mbps and 1000Mbps MAUs, the enumerations\n                       match the states within the respective link\n                       integrity state diagrams, fig 32-16, 23-12 and\n                       24-15 of sections 32, 23 and 24 of [IEEE802.3].\n                       Any MAU which implements management of\n                       auto-negotiation will map remote fault\n                       indication to remote fault.\n\n                       The value available(3) indicates that the link,\n                       light, or loopback is normal.  The value\n                       notAvailable(4) indicates link loss, low light,\n                       or no loopback.\n\n                       The value remoteFault(5) indicates that a fault\n                       has been detected at the remote end of the link.\n                       This value applies to 10BASE-FB, 100BASE-T4 Far\n                       End Fault Indication and non-specified remote\n                       faults from a system running auto-negotiation.\n                       The values remoteJabber(7), remoteLinkLoss(8),\n                       and remoteTest(9) SHOULD be used instead of\n                       remoteFault(5) where the reason for remote fault\n                       is identified in the remote signaling protocol.\n\n                       The value invalidSignal(6) indicates that an\n                       invalid signal has been received from the other\n                       end of the link.  invalidSignal(6) applies only\n                       to MAUs of type 10BASE-FB.\n\n                       Where an IEEE Std 802.3-2002 clause 22 MII\n                       is present, a logic one in the remote fault bit\n                       (reference section 22.2.4.2.8 of that document)\n                       maps to the value remoteFault(5), and a logic\n                       zero in the link status bit (reference section\n                       22.2.4.2.10 of that document) maps to the value\n                       notAvailable(4).  The value notAvailable(4)\n                       takes precedence over the value remoteFault(5).\n\n                       Any MAU that implements management of clause 37\n                       Auto-Negotiation will map the received Remote\n                       Fault (RF1 and RF2) bit values for Offline to\n                       offline(10), Link Failure to remoteFault(5) and\n                       Auto-Negotiation Error to autoNegError(11).")
rpMauMediaAvailableStateExits = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauMediaAvailableStateExits.setDescription('A count of the number of times that\n                       rpMauMediaAvailable for this MAU instance leaves\n                       the state available(3).\n\n                       Discontinuities in the value of this counter can\n                       occur at re-initialization of the management\n                       system, and at other times as indicated by the\n                       value of rptrMonitorPortLastChange.')
rpMauJabberState = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4,))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("noJabber", 3), ("jabbering", 4),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauJabberState.setDescription("The value other(1) is returned if the jabber\n                       state is not 2, 3, or 4.  The agent MUST always\n                       return other(1) for MAU type dot3MauTypeAUI.\n\n                       The value unknown(2) is returned when the MAU's\n                       true state is unknown; for example, when it is\n                       being initialized.\n\n                       If the MAU is not jabbering the agent returns\n                       noJabber(3).  This is the 'normal' state.\n\n                       If the MAU is in jabber state the agent returns\n                       the jabbering(4) value.")
rpMauJabberingStateEnters = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauJabberingStateEnters.setDescription('A count of the number of times that\n                       mauJabberState for this MAU instance enters the\n                       state jabbering(4).  For MAUs of type\n                       dot3MauTypeAUI, dot3MauType100BaseT4,\n                       dot3MauType100BaseTX, dot3MauType100BaseFX and\n                       all 1000Mbps types, this counter will always\n                       indicate zero.\n\n                       Discontinuities in the value of this counter can\n                       occur at re-initialization of the management\n                       system, and at other times as indicated by the\n                       value of rptrMonitorPortLastChange.')
rpMauFalseCarriers = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpMauFalseCarriers.setDescription('A count of the number of false carrier events\n                       during IDLE in 100BASE-X links.  This counter\n                       does not increment at the symbol rate.  It can\n                       increment after a valid carrier completion at a\n                       maximum rate of once per 100 ms until the next\n                       carrier event.\n\n                       This counter increments only for MAUs of type\n                       dot3MauType100BaseT4, dot3MauType100BaseTX, and\n                       dot3MauType100BaseFX and all 1000Mbps types.\n\n                       For all other MAU types, this counter will\n                       always indicate zero.\n\n                       The approximate minimum time for rollover of\n                       this counter is 7.4 hours.\n\n                       Discontinuities in the value of this counter can\n                       occur at re-initialization of the management\n                       system, and at other times as indicated by the\n                       value of rptrMonitorPortLastChange.')
rpJackTable = MibTable((1, 3, 6, 1, 2, 1, 26, 1, 2), )
if mibBuilder.loadTexts: rpJackTable.setDescription('Information about the external jacks attached\n                       to MAUs attached to the ports of a repeater.')
rpJackEntry = MibTableRow((1, 3, 6, 1, 2, 1, 26, 1, 2, 1), ).setIndexNames((0, "MAU-MIB", "rpMauGroupIndex"), (0, "MAU-MIB", "rpMauPortIndex"), (0, "MAU-MIB", "rpMauIndex"), (0, "MAU-MIB", "rpJackIndex"))
if mibBuilder.loadTexts: rpJackEntry.setDescription('An entry in the table, containing information\n                       about a particular jack.')
rpJackIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647)))
if mibBuilder.loadTexts: rpJackIndex.setDescription('This variable uniquely identifies the jack\n                       described by this entry from among other jacks\n                       attached to the same MAU (rpMauIndex).')
rpJackType = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 1, 2, 1, 2), JackType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpJackType.setDescription('The jack connector type, as it appears on the\n                       outside of the system.')
ifMauTable = MibTable((1, 3, 6, 1, 2, 1, 26, 2, 1), )
if mibBuilder.loadTexts: ifMauTable.setDescription('Table of descriptive and status information\n                       about MAU(s) attached to an interface.')
ifMauEntry = MibTableRow((1, 3, 6, 1, 2, 1, 26, 2, 1, 1), ).setIndexNames((0, "MAU-MIB", "ifMauIfIndex"), (0, "MAU-MIB", "ifMauIndex"))
if mibBuilder.loadTexts: ifMauEntry.setDescription('An entry in the table, containing information\n                       about a single MAU.')
ifMauIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 2, 1, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifMauIfIndex.setDescription('This variable uniquely identifies the interface\n                       to which the MAU described by this entry is\n                       connected.')
ifMauIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifMauIndex.setDescription('This variable uniquely identifies the MAU\n                       described by this entry from among other MAUs\n                       connected to the same interface (ifMauIfIndex).')
ifMauType = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 2, 1, 1, 3), AutonomousType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifMauType.setDescription('This object identifies the MAU type.  Values for\n                       standard IEEE 802.3 MAU types are defined above.\n                       If the MAU type is unknown, the object identifier\n\n                       unknownMauType OBJECT IDENTIFIER ::= { 0 0 }\n\n                       is returned.  Note that unknownMauType is a\n                       syntactically valid object identifier, and any\n                       conformant implementation of ASN.1 and the BER\n                       must be able to generate and recognize this\n                       value.\n\n                       This object represents the operational type of\n                       the MAU, as determined by either (1) the result\n                       of the auto-negotiation function or (2) if\n                       auto-negotiation is not enabled or is not\n                       implemented for this MAU, by the value of the\n                       object ifMauDefaultType.  In case (2), a set to\n                       the object ifMauDefaultType will force the MAU\n                       into the new operating mode.')
ifMauStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6,))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("operational", 3), ("standby", 4), ("shutdown", 5), ("reset", 6),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifMauStatus.setDescription("The current state of the MAU.  This object MAY\n                       be implemented as a read-only object by those\n                       agents and MAUs that do not implement software\n                       control of the MAU state.  Some agents may not\n                       support setting the value of this object to some\n                       of the enumerated values.\n\n                       The value other(1) is returned if the MAU is in\n                       a state other than one of the states 2 through\n                       6.\n\n                       The value unknown(2) is returned when the MAU's\n                       true state is unknown; for example, when it is\n                       being initialized.\n\n                       A MAU in the operational(3) state is fully\n                       functional, operates, and passes signals to its\n                       attached DTE or repeater port in accordance to\n                       its specification.\n\n                       A MAU in standby(4) state forces DI and CI to\n                       idle and the media transmitter to idle or fault,\n                       if supported.  Standby(4) mode only applies to\n                       link type MAUs.  The state of\n                       ifMauMediaAvailable is unaffected.\n\n                       A MAU in shutdown(5) state assumes the same\n                       condition on DI, CI, and the media transmitter\n                       as though it were powered down or not connected.\n                       The MAU MAY return other(1) value for the\n                       ifMauJabberState and ifMauMediaAvailable objects\n                       when it is in this state.  For an AUI, this\n                       state will remove power from the AUI.\n\n                       Setting this variable to the value reset(6)\n                       resets the MAU in the same manner as a\n                       power-off, power-on cycle of at least one-half\n                       second would.  The agent is not required to\n                       return the value reset (6).\n\n                       Setting this variable to the value\n                       operational(3), standby(4), or shutdown(5)\n                       causes the MAU to assume the respective state\n                       except that setting a mixing-type MAU or an AUI\n                       to standby(4) will cause the MAU to enter the\n                       shutdown state.")
ifMauMediaAvailable = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("available", 3), ("notAvailable", 4), ("remoteFault", 5), ("invalidSignal", 6), ("remoteJabber", 7), ("remoteLinkLoss", 8), ("remoteTest", 9), ("offline", 10), ("autoNegError", 11), ("pmdLinkFault", 12), ("wisFrameLoss", 13), ("wisSignalLoss", 14), ("pcsLinkFault", 15), ("excessiveBER", 16), ("dxsLinkFault", 17), ("pxsLinkFault", 18),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifMauMediaAvailable.setDescription("If the MAU is a link or fiber type (FOIRL,\n                       10BASE-T, 10BASE-F) then this is equivalent to\n                       the link test fail state/low light function.\n                       For an AUI or a coax (including broadband) MAU\n                       this indicates whether or not loopback is\n                       detected on the DI circuit.  The value of this\n                       attribute persists between packets for MAU types\n                       AUI, 10BASE5, 10BASE2, 10BROAD36, and 10BASE-FP.\n\n                       The value other(1) is returned if the\n                       mediaAvailable state is not one of 2 through 18.\n\n                       The value unknown(2) is returned when the MAU's\n                       true state is unknown; for example, when it is\n                       being initialized.  At power-up or following a\n                       reset, the value of this attribute will be\n                       unknown for AUI, coax, and 10BASE-FP MAUs.  For\n                       these MAUs loopback will be tested on each\n                       transmission during which no collision is\n                       detected.  If DI is receiving input when DO\n                       returns to IDL after a transmission and there\n                       has been no collision during the transmission\n                       then loopback will be detected.  The value of\n                       this attribute will only change during\n                       non-collided transmissions for AUI, coax, and\n                       10BASE-FP MAUs.\n\n                       For 100Mbps and 1000Mbps MAUs, the enumerations\n                       match the states within the respective link\n                       integrity state diagrams, fig 32-16, 23-12 and\n                       24-15 of sections 32, 23 and 24 of [IEEE802.3].\n                       Any MAU which implements management of\n                       auto-negotiation will map remote fault\n                       indication to remote fault.\n\n                       The value available(3) indicates that the link,\n                       light, or loopback is normal.  The value\n                       notAvailable(4) indicates link loss, low light,\n                       or no loopback.\n\n                       The value remoteFault(5) indicates that a fault\n                       has been detected at the remote end of the link.\n                       This value applies to 10BASE-FB, 100BASE-T4 Far\n                       End Fault Indication and non-specified remote\n                       faults from a system running auto-negotiation.\n                       The values remoteJabber(7), remoteLinkLoss(8),\n                       and remoteTest(9) SHOULD be used instead of\n                       remoteFault(5) where the reason for remote fault\n                       is identified in the remote signaling protocol.\n                       The value invalidSignal(6) indicates that an\n                       invalid signal has been received from the other\n                       end of the link.  invalidSignal(6) applies only\n                       to MAUs of type 10BASE-FB.\n\n                       Where an IEEE Std 802.3-2002 clause 22 MII\n                       is present, a logic one in the remote fault bit\n                       (reference section 22.2.4.2.8 of that document)\n                       maps to the value remoteFault(5), and a logic\n                       zero in the link status bit (reference section\n                       22.2.4.2.10 of that document) maps to the value\n                       notAvailable(4).  The value notAvailable(4)\n                       takes precedence over the value remoteFault(5).\n\n                       Any MAU that implements management of clause 37\n                       Auto-Negotiation will map the received RF1 and\n                       RF2 bit values for Offline to offline(10), Link\n                       Failure to remoteFault(5) and Auto-Negotiation\n                       Error to autoNegError(11).\n\n                       For 10 Gb/s, the enumerations map to the states\n                       within the Reconciliation Sublayer state diagram\n                       as follows:\n                         NoFault maps to the enumeration 'available(3)'\n                         LocalFault maps to the enumeration\n                           'notAvailable(4)'\n                         RemoteFault maps to the enumeration\n                           'remoteFault(5)'\n                       The enumerations 'pmdLinkFault(12)',\n                       'wisFrameLoss(13)', 'wisSignalLoss(14)',\n                       'pcsLinkFault(15)', 'excessiveBER(16)', and\n                       'dxsLinkFault(17)' and 'pxsLinkFault(18)' should\n                       be used instead of the enumeration\n                       'notAvailable(4)' where the reason for the local\n                       fault can be identified through the use of the\n                       MDIO Interface.  Where multiple reasons for the\n                       local fault state can be identified only the\n                       highest precedence error should be reported.\n                       The precedence in descending order is as\n                       follows:\n                           pxsLinkFault\n                           pmdLinkFault\n                           wisFrameLoss\n                           wisSignalLoss\n                           pcsLinkFault\n                           excessiveBER\n                           dxsLinkFault")
ifMauMediaAvailableStateExits = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifMauMediaAvailableStateExits.setDescription('A count of the number of times that\n                       ifMauMediaAvailable for this MAU instance leaves\n                       the state available(3).\n\n                       Discontinuities in the value of this counter can\n                       occur at re-initialization of the management\n                       system, and at other times as indicated by the\n                       value of ifCounterDiscontinuityTime.')
ifMauJabberState = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4,))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("noJabber", 3), ("jabbering", 4),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifMauJabberState.setDescription("The value other(1) is returned if the jabber\n                       state is not 2, 3, or 4.  The agent MUST always\n                       return other(1) for MAU type dot3MauTypeAUI.\n\n                       The value unknown(2) is returned when the MAU's\n                       true state is unknown; for example, when it is\n                       being initialized.\n\n                       If the MAU is not jabbering the agent returns\n                       noJabber(3).  This is the 'normal' state.\n\n                       If the MAU is in jabber state the agent returns\n                       the jabbering(4) value.")
ifMauJabberingStateEnters = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifMauJabberingStateEnters.setDescription('A count of the number of times that\n                       mauJabberState for this MAU instance enters the\n                       state jabbering(4). This counter will always\n                       indicate zero for MAUs of type dot3MauTypeAUI\n                       and those of speeds above 10Mbps.\n\n                       Discontinuities in the value of this counter can\n                       occur at re-initialization of the management\n                       system, and at other times as indicated by the\n                       value of ifCounterDiscontinuityTime.')
ifMauFalseCarriers = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifMauFalseCarriers.setDescription('A count of the number of false carrier events\n                       during IDLE in 100BASE-X and 1000BASE-X links.\n\n                       For all other MAU types, this counter will\n                       always indicate zero. This counter does not\n                       increment at the symbol rate.\n\n                       It can increment after a valid carrier\n                       completion at a maximum rate of once per 100 ms\n                       for 100BASE-X and once per 10us for 1000BASE-X\n                       until the next CarrierEvent.\n\n                       This counter can roll over very quickly.  A\n                       management station is advised to poll the\n                       ifMauHCFalseCarriers instead of this counter in\n                       order to avoid loss of information.\n\n                       Discontinuities in the value of this counter can\n                       occur at re-initialization of the management\n                       system, and at other times as indicated by the\n                       value of ifCounterDiscontinuityTime.')
ifMauTypeList = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 2, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifMauTypeList.setDescription('********* THIS OBJECT IS DEPRECATED **********\n\n                       This object has been deprecated in favour of\n                       ifMauTypeListBits.\n\n                       A value that uniquely identifies the set of\n                       possible IEEE 802.3 types that the MAU could be.\n                       The value is a sum which initially takes the\n                       value zero.  Then, for each type capability of\n                       this MAU, 2 raised to the power noted below is\n                       added to the sum. For example, a MAU which has\n                       the capability to be only 10BASE-T would have a\n                       value of 512 (2**9).  In contrast, a MAU which\n                       supports both 10Base-T (full duplex) and\n                       100BASE-TX (full duplex) would have a value of\n                       ((2**11) + (2**16)) or 67584.\n\n                       The powers of 2 assigned to the capabilities are\n                       these:\n                       Power  Capability\n                         0      other or unknown\n                         1      AUI\n                         2      10BASE-5\n                         3      FOIRL\n                         4      10BASE-2\n                         5      10BASE-T duplex mode unknown\n                         6      10BASE-FP\n                         7      10BASE-FB\n                         8      10BASE-FL duplex mode unknown\n                         9      10BROAD36\n                        10      10BASE-T  half duplex mode\n                        11      10BASE-T  full duplex mode\n                        12      10BASE-FL half duplex mode\n                        13      10BASE-FL full duplex mode\n                        14      100BASE-T4\n                        15      100BASE-TX half duplex mode\n                        16      100BASE-TX full duplex mode\n                        17      100BASE-FX half duplex mode\n                        18      100BASE-FX full duplex mode\n                        19      100BASE-T2 half duplex mode\n                        20      100BASE-T2 full duplex mode\n\n                       If auto-negotiation is present on this MAU, this\n                       object will map to ifMauAutoNegCapability.')
ifMauDefaultType = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 2, 1, 1, 11), AutonomousType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifMauDefaultType.setDescription('This object identifies the default\n                       administrative baseband MAU type, to be used in\n                       conjunction with the operational MAU type\n                       denoted by ifMauType.\n\n                       The set of possible values for this object is\n                       the same as the set defined for the ifMauType\n                       object.\n\n                       This object represents the\n                       administratively-configured type of the MAU.  If\n                       auto-negotiation is not enabled or is not\n                       implemented for this MAU, the value of this\n                       object determines the operational type of the\n                       MAU.  In this case, a set to this object will\n                       force the MAU into the specified operating mode.\n                       If auto-negotiation is implemented and enabled\n                       for this MAU, the operational type of the MAU\n                       is determined by auto-negotiation, and the value\n                       of this object denotes the type to which the MAU\n                       will automatically revert if/when\n                       auto-negotiation is later disabled.\n\n                       NOTE TO IMPLEMENTORS:  It may be necessary to\n                       provide for underlying hardware implementations\n                       which do not follow the exact behavior specified\n                       above.  In particular, when\n                       ifMauAutoNegAdminStatus transitions from enabled\n                       to disabled, the agent implementation MUST\n                       ensure that the operational type of the MAU (as\n                       reported by ifMauType) correctly transitions to\n                       the value specified by this object, rather than\n                       continuing to operate at the value earlier\n                       determined by the auto-negotiation function.')
ifMauAutoNegSupported = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 2, 1, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifMauAutoNegSupported.setDescription('This object indicates whether or not\n                       auto-negotiation is supported on this MAU.')
ifMauTypeListBits = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 2, 1, 1, 13), Bits().clone(namedValues=NamedValues(("bOther", 0), ("bAUI", 1), ("b10base5", 2), ("bFoirl", 3), ("b10base2", 4), ("b10baseT", 5), ("b10baseFP", 6), ("b10baseFB", 7), ("b10baseFL", 8), ("b10broad36", 9), ("b10baseTHD", 10), ("b10baseTFD", 11), ("b10baseFLHD", 12), ("b10baseFLFD", 13), ("b100baseT4", 14), ("b100baseTXHD", 15), ("b100baseTXFD", 16), ("b100baseFXHD", 17), ("b100baseFXFD", 18), ("b100baseT2HD", 19), ("b100baseT2FD", 20), ("b1000baseXHD", 21), ("b1000baseXFD", 22), ("b1000baseLXHD", 23), ("b1000baseLXFD", 24), ("b1000baseSXHD", 25), ("b1000baseSXFD", 26), ("b1000baseCXHD", 27), ("b1000baseCXFD", 28), ("b1000baseTHD", 29), ("b1000baseTFD", 30), ("b10GbaseX", 31), ("b10GbaseLX4", 32), ("b10GbaseR", 33), ("b10GbaseER", 34), ("b10GbaseLR", 35), ("b10GbaseSR", 36), ("b10GbaseW", 37), ("b10GbaseEW", 38), ("b10GbaseLW", 39), ("b10GbaseSW", 40),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifMauTypeListBits.setDescription('A value that uniquely identifies the set of\n                       possible IEEE 802.3 types that the MAU could be.\n                       If auto-negotiation is present on this MAU, this\n                       object will map to ifMauAutoNegCapabilityBits.\n\n                       Note that this MAU may be capable of operating\n                       as a MAU type that is beyond the scope of this\n                       MIB.  This is indicated by returning the\n                       bit value bOther in addition to any bit values\n                       for capabilities that are listed above.')
ifMauHCFalseCarriers = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 2, 1, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifMauHCFalseCarriers.setDescription('A count of the number of false carrier events\n                       during IDLE in 100BASE-X and 1000BASE-X links.\n\n                       For all other MAU types, this counter will\n                       always indicate zero. This counter does not\n                       increment at the symbol rate.\n\n                       This counter is a 64 bit version of\n                       ifMauFalseCarriers.  Since the 32 bit version of\n                       this counter can roll over very quickly,\n                       management stations are advised to poll the\n                       64 bit version instead in order to avoid loss\n                       of information.\n\n                       Discontinuities in the value of this counter can\n                       occur at re-initialization of the management\n                       system, and at other times as indicated by the\n                       value of ifCounterDiscontinuityTime.')
ifJackTable = MibTable((1, 3, 6, 1, 2, 1, 26, 2, 2), )
if mibBuilder.loadTexts: ifJackTable.setDescription('Information about the external jacks attached\n                       to MAUs attached to an interface.')
ifJackEntry = MibTableRow((1, 3, 6, 1, 2, 1, 26, 2, 2, 1), ).setIndexNames((0, "MAU-MIB", "ifMauIfIndex"), (0, "MAU-MIB", "ifMauIndex"), (0, "MAU-MIB", "ifJackIndex"))
if mibBuilder.loadTexts: ifJackEntry.setDescription('An entry in the table, containing information\n                       about a particular jack.')
ifJackIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647)))
if mibBuilder.loadTexts: ifJackIndex.setDescription('This variable uniquely identifies the jack\n                       described by this entry from among other jacks\n                       attached to the same MAU.')
ifJackType = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 2, 2, 1, 2), JackType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifJackType.setDescription('The jack connector type, as it appears on the\n                       outside of the system.')
ifMauAutoNegTable = MibTable((1, 3, 6, 1, 2, 1, 26, 5, 1), )
if mibBuilder.loadTexts: ifMauAutoNegTable.setDescription('Configuration and status objects for the\n                       auto-negotiation function of MAUs attached to\n                       interfaces.\n\n                       The ifMauAutoNegTable applies to systems in\n                       which auto-negotiation is supported on one or\n                       more MAUs attached to interfaces.  Note that if\n                       auto-negotiation is present and enabled, the\n                       ifMauType object reflects the result of the\n                       auto-negotiation function.')
ifMauAutoNegEntry = MibTableRow((1, 3, 6, 1, 2, 1, 26, 5, 1, 1), ).setIndexNames((0, "MAU-MIB", "ifMauIfIndex"), (0, "MAU-MIB", "ifMauIndex"))
if mibBuilder.loadTexts: ifMauAutoNegEntry.setDescription('An entry in the table, containing configuration\n                       and status information for the auto-negotiation\n                       function of a particular MAU.')
ifMauAutoNegAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifMauAutoNegAdminStatus.setDescription('Setting this object to enabled(1) will cause\n                       the interface which has the auto-negotiation\n                       signaling ability to be enabled.\n\n                       If the value of this object is disabled(2) then\n                       the interface will act as it would if it had no\n                       auto-negotiation signaling.  Under these\n                       conditions, an IEEE 802.3 MAU will immediately\n                       be forced to the state indicated by the value of\n                       the object ifMauDefaultType.\n\n                       NOTE TO IMPLEMENTORS:  When\n                       ifMauAutoNegAdminStatus transitions from enabled\n                       to disabled, the agent implementation MUST\n                       ensure that the operational type of the MAU (as\n                       reported by ifMauType) correctly transitions to\n                       the value specified by the ifMauDefaultType\n                       object, rather than continuing to operate at the\n                       value earlier determined by the auto-negotiation\n                       function.')
ifMauAutoNegRemoteSignaling = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("detected", 1), ("notdetected", 2),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifMauAutoNegRemoteSignaling.setDescription('A value indicating whether the remote end of\n                       the link is using auto-negotiation signaling. It\n                       takes the value detected(1) if and only if,\n                       during the previous link negotiation, FLP Bursts\n                       were received.')
ifMauAutoNegConfig = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("other", 1), ("configuring", 2), ("complete", 3), ("disabled", 4), ("parallelDetectFail", 5),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifMauAutoNegConfig.setDescription('A value indicating the current status of the\n                       auto-negotiation process.  The enumeration\n                       parallelDetectFail(5) maps to a failure in\n                       parallel detection as defined in 28.2.3.1 of\n                       [IEEE 802.3 Std].')
ifMauAutoNegCapability = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 5, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifMauAutoNegCapability.setDescription('********* THIS OBJECT IS DEPRECATED **********\n\n                       This object has been deprecated in favour of\n                       ifMauAutoNegCapabilityBits.\n                       A value that uniquely identifies the set of\n                       capabilities of the local auto-negotiation\n                       entity.  The value is a sum which initially\n                       takes the value zero.  Then, for each capability\n                       of this interface, 2 raised to the power noted\n                       below is added to the sum. For example, an\n                       interface which has the capability to support\n                       only 100Base-TX half duplex would have a value\n                       of 32768 (2**15).  In contrast, an interface\n                       which supports both 100Base-TX half duplex and\n                       and 100Base-TX full duplex would have a value of\n                       98304 ((2**15) + (2**16)).\n\n                       The powers of 2 assigned to the capabilities are\n                       these:\n\n                       Power   Capability\n                         0       other or unknown\n                        (1-9)    (reserved)\n                        10       10BASE-T  half duplex mode\n                        11       10BASE-T  full duplex mode\n                        12       (reserved)\n                        13       (reserved)\n                        14       100BASE-T4\n                        15       100BASE-TX half duplex mode\n                        16       100BASE-TX full duplex mode\n                        17       (reserved)\n                        18       (reserved)\n                        19      100BASE-T2 half duplex mode\n                        20      100BASE-T2 full duplex mode\n\n                       Note that interfaces that support this MIB may\n                       have capabilities that extend beyond the scope\n                       of this MIB.')
ifMauAutoNegCapAdvertised = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 5, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifMauAutoNegCapAdvertised.setDescription('********* THIS OBJECT IS DEPRECATED **********\n\n                       This object has been deprecated in favour of\n                       ifMauAutoNegCapAdvertisedBits.\n\n                       A value that uniquely identifies the set of\n                       capabilities advertised by the local\n                       auto-negotiation entity. Refer to\n                       ifMauAutoNegCapability for a description of the\n                       possible values of this object.\n\n                       Capabilities in this object that are not\n                       available in ifMauAutoNegCapability cannot be\n                       enabled.')
ifMauAutoNegCapReceived = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 5, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifMauAutoNegCapReceived.setDescription('********* THIS OBJECT IS DEPRECATED **********\n\n                       This object has been deprecated in favour of\n                       ifMauAutoNegCapReceivedBits.\n\n                       A value that uniquely identifies the set of\n                       capabilities received from the remote\n                       auto-negotiation entity. Refer to\n                       ifMauAutoNegCapability for a description of the\n                       possible values of this object.\n\n                       Note that interfaces that support this MIB may\n                       be attached to remote auto-negotiation entities\n                       which have capabilities beyond the scope of this\n                       MIB.')
ifMauAutoNegRestart = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("restart", 1), ("norestart", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifMauAutoNegRestart.setDescription('If the value of this object is set to\n                       restart(1) then this will force auto-negotiation\n                       to begin link renegotiation. If auto-negotiation\n                       signaling is disabled, a write to this object\n                       has no effect.\n                       Setting the value of this object to norestart(2)\n                       has no effect.')
ifMauAutoNegCapabilityBits = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 5, 1, 1, 9), Bits().clone(namedValues=NamedValues(("bOther", 0), ("b10baseT", 1), ("b10baseTFD", 2), ("b100baseT4", 3), ("b100baseTX", 4), ("b100baseTXFD", 5), ("b100baseT2", 6), ("b100baseT2FD", 7), ("bfdxPause", 8), ("bfdxAPause", 9), ("bfdxSPause", 10), ("bfdxBPause", 11), ("b1000baseX", 12), ("b1000baseXFD", 13), ("b1000baseT", 14), ("b1000baseTFD", 15),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifMauAutoNegCapabilityBits.setDescription('A value that uniquely identifies the set of\n                       capabilities of the local auto-negotiation\n                       entity.  Note that interfaces that support this\n                       MIB may have capabilities that extend beyond the\n                       scope of this MIB.\n\n                       Note that the local auto-negotiation entity may\n                       support some capabilities beyond the scope of\n                       this MIB.  This is indicated by returning the\n                       bit value bOther in addition to any bit values\n                       for capabilities that are listed above.')
ifMauAutoNegCapAdvertisedBits = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 5, 1, 1, 10), Bits().clone(namedValues=NamedValues(("bOther", 0), ("b10baseT", 1), ("b10baseTFD", 2), ("b100baseT4", 3), ("b100baseTX", 4), ("b100baseTXFD", 5), ("b100baseT2", 6), ("b100baseT2FD", 7), ("bFdxPause", 8), ("bFdxAPause", 9), ("bFdxSPause", 10), ("bFdxBPause", 11), ("b1000baseX", 12), ("b1000baseXFD", 13), ("b1000baseT", 14), ("b1000baseTFD", 15),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifMauAutoNegCapAdvertisedBits.setDescription('A value that uniquely identifies the set of\n                       capabilities advertised by the local\n                       auto-negotiation entity.\n\n                       Capabilities in this object that are not\n                       available in ifMauAutoNegCapabilityBits cannot\n                       be enabled.\n\n                       Note that the local auto-negotiation entity may\n                       advertise some capabilities beyond the scope of\n                       this MIB.  This is indicated by returning the\n                       bit value bOther in addition to any bit values\n                       for capabilities that are listed above.')
ifMauAutoNegCapReceivedBits = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 5, 1, 1, 11), Bits().clone(namedValues=NamedValues(("bOther", 0), ("b10baseT", 1), ("b10baseTFD", 2), ("b100baseT4", 3), ("b100baseTX", 4), ("b100baseTXFD", 5), ("b100baseT2", 6), ("b100baseT2FD", 7), ("bFdxPause", 8), ("bFdxAPause", 9), ("bFdxSPause", 10), ("bFdxBPause", 11), ("b1000baseX", 12), ("b1000baseXFD", 13), ("b1000baseT", 14), ("b1000baseTFD", 15),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifMauAutoNegCapReceivedBits.setDescription('A value that uniquely identifies the set of\n                       capabilities received from the remote\n                       auto-negotiation entity.\n                       Note that interfaces that support this MIB may\n                       be attached to remote auto-negotiation entities\n                       which have capabilities beyond the scope of this\n                       MIB.  This is indicated by returning the bit\n                       value bOther in addition to any bit values for\n                       capabilities that are listed above.')
ifMauAutoNegRemoteFaultAdvertised = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4,))).clone(namedValues=NamedValues(("noError", 1), ("offline", 2), ("linkFailure", 3), ("autoNegError", 4),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifMauAutoNegRemoteFaultAdvertised.setDescription('A value that identifies any local fault\n                       indications that this MAU has detected and will\n                       advertise at the next auto-negotiation\n                       interaction for 1000Mbps MAUs.')
ifMauAutoNegRemoteFaultReceived = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 5, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4,))).clone(namedValues=NamedValues(("noError", 1), ("offline", 2), ("linkFailure", 3), ("autoNegError", 4),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifMauAutoNegRemoteFaultReceived.setDescription('A value that identifies any fault indications\n                       received from the far end of a link by the\n                       local auto-negotiation entity for 1000Mbps\n                       MAUs.')
broadMauBasicTable = MibTable((1, 3, 6, 1, 2, 1, 26, 3, 1), )
if mibBuilder.loadTexts: broadMauBasicTable.setDescription('********* THIS OBJECT IS DEPRECATED **********\n\n                       This entire table has been deprecated.  There\n                       have been no reported implementations of this\n                       table, and it is unlikely that there ever will\n                       be.  IEEE recommends that broadband MAU types\n                       should not be used for new installations.\n\n                       Table of descriptive and status information\n                       about the broadband MAUs connected to\n                       interfaces.')
broadMauBasicEntry = MibTableRow((1, 3, 6, 1, 2, 1, 26, 3, 1, 1), ).setIndexNames((0, "MAU-MIB", "broadMauIfIndex"), (0, "MAU-MIB", "broadMauIndex"))
if mibBuilder.loadTexts: broadMauBasicEntry.setDescription('********* THIS OBJECT IS DEPRECATED **********\n\n                       An entry in the table, containing information\n                       about a single broadband MAU.')
broadMauIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 3, 1, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: broadMauIfIndex.setDescription('********* THIS OBJECT IS DEPRECATED **********\n\n                       This variable uniquely identifies the interface\n                       to which the MAU described by this entry is\n                       connected.')
broadMauIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: broadMauIndex.setDescription('********* THIS OBJECT IS DEPRECATED **********\n\n                       This variable uniquely identifies the MAU\n                       connected to interface broadMauIfIndex that is\n                       described by this entry.')
broadMauXmtRcvSplitType = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("other", 1), ("single", 2), ("dual", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: broadMauXmtRcvSplitType.setDescription('********* THIS OBJECT IS DEPRECATED **********\n\n                       This object indicates the type of frequency\n                       multiplexing/cabling system used to separate the\n                       transmit and receive paths for the 10BROAD36\n                       MAU.\n\n                       The value other(1) is returned if the split type\n                       is not either single or dual.\n\n                       The value single(2) indicates a single cable\n                       system.  The value dual(3) indicates a dual\n                       cable system, offset normally zero.')
broadMauXmtCarrierFreq = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: broadMauXmtCarrierFreq.setDescription('********* THIS OBJECT IS DEPRECATED **********\n\n                       This variable indicates the transmit carrier\n                       frequency of the 10BROAD36 MAU in MHz/4; that\n                       is, in units of 250 kHz.')
broadMauTranslationFreq = MibTableColumn((1, 3, 6, 1, 2, 1, 26, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: broadMauTranslationFreq.setDescription('********* THIS OBJECT IS DEPRECATED **********\n\n                       This variable indicates the translation offset\n                       frequency of the 10BROAD36 MAU in MHz/4; that\n                       is, in units of 250 kHz.')
snmpDot3MauTraps = MibIdentifier((1, 3, 6, 1, 2, 1, 26, 0))
rpMauJabberTrap = NotificationType((1, 3, 6, 1, 2, 1, 26, 0, 1)).setObjects(*(("MAU-MIB", "rpMauJabberState"),))
if mibBuilder.loadTexts: rpMauJabberTrap.setDescription('This trap is sent whenever a managed repeater\n                       MAU enters the jabber state.\n\n                       The agent MUST throttle the generation of\n                       consecutive rpMauJabberTraps so that there is at\n                       least a five-second gap between them.')
ifMauJabberTrap = NotificationType((1, 3, 6, 1, 2, 1, 26, 0, 2)).setObjects(*(("MAU-MIB", "ifMauJabberState"),))
if mibBuilder.loadTexts: ifMauJabberTrap.setDescription('This trap is sent whenever a managed interface\n                       MAU enters the jabber state.\n\n                       The agent MUST throttle the generation of\n                       consecutive ifMauJabberTraps so that there is at\n                       least a five-second gap between them.')
mauModConf = MibIdentifier((1, 3, 6, 1, 2, 1, 26, 6, 1))
mauModCompls = MibIdentifier((1, 3, 6, 1, 2, 1, 26, 6, 1, 1))
mauModObjGrps = MibIdentifier((1, 3, 6, 1, 2, 1, 26, 6, 1, 2))
mauModNotGrps = MibIdentifier((1, 3, 6, 1, 2, 1, 26, 6, 1, 3))
mauRpGrpBasic = ObjectGroup((1, 3, 6, 1, 2, 1, 26, 6, 1, 2, 1)).setObjects(*(("MAU-MIB", "rpMauGroupIndex"), ("MAU-MIB", "rpMauPortIndex"), ("MAU-MIB", "rpMauIndex"), ("MAU-MIB", "rpMauType"), ("MAU-MIB", "rpMauStatus"), ("MAU-MIB", "rpMauMediaAvailable"), ("MAU-MIB", "rpMauMediaAvailableStateExits"), ("MAU-MIB", "rpMauJabberState"), ("MAU-MIB", "rpMauJabberingStateEnters"),))
if mibBuilder.loadTexts: mauRpGrpBasic.setDescription('Basic conformance group for MAUs attached to\n                       repeater ports.  This group is also the\n                       conformance specification for RFC 1515\n                       implementations.')
mauRpGrp100Mbs = ObjectGroup((1, 3, 6, 1, 2, 1, 26, 6, 1, 2, 2)).setObjects(*(("MAU-MIB", "rpMauFalseCarriers"),))
if mibBuilder.loadTexts: mauRpGrp100Mbs.setDescription('Conformance group for MAUs attached to\n                       repeater ports with 100 Mb/s or greater\n                       capability.')
mauRpGrpJack = ObjectGroup((1, 3, 6, 1, 2, 1, 26, 6, 1, 2, 3)).setObjects(*(("MAU-MIB", "rpJackType"),))
if mibBuilder.loadTexts: mauRpGrpJack.setDescription('Conformance group for MAUs attached to\n                       repeater ports with managed jacks.')
mauIfGrpBasic = ObjectGroup((1, 3, 6, 1, 2, 1, 26, 6, 1, 2, 4)).setObjects(*(("MAU-MIB", "ifMauIfIndex"), ("MAU-MIB", "ifMauIndex"), ("MAU-MIB", "ifMauType"), ("MAU-MIB", "ifMauStatus"), ("MAU-MIB", "ifMauMediaAvailable"), ("MAU-MIB", "ifMauMediaAvailableStateExits"), ("MAU-MIB", "ifMauJabberState"), ("MAU-MIB", "ifMauJabberingStateEnters"),))
if mibBuilder.loadTexts: mauIfGrpBasic.setDescription('Basic conformance group for MAUs attached to\n                       interfaces.  This group also provides a\n                       conformance specification for RFC 1515\n                       implementations.')
mauIfGrp100Mbs = ObjectGroup((1, 3, 6, 1, 2, 1, 26, 6, 1, 2, 5)).setObjects(*(("MAU-MIB", "ifMauFalseCarriers"), ("MAU-MIB", "ifMauTypeList"), ("MAU-MIB", "ifMauDefaultType"), ("MAU-MIB", "ifMauAutoNegSupported"),))
if mibBuilder.loadTexts: mauIfGrp100Mbs.setDescription('********* THIS GROUP IS DEPRECATED **********\n\n                       Conformance group for MAUs attached to\n                       interfaces with 100 Mb/s capability.\n\n                       This object group has been deprecated in favor\n                       of mauIfGrpHighCapacity.')
mauIfGrpJack = ObjectGroup((1, 3, 6, 1, 2, 1, 26, 6, 1, 2, 6)).setObjects(*(("MAU-MIB", "ifJackType"),))
if mibBuilder.loadTexts: mauIfGrpJack.setDescription('Conformance group for MAUs attached to\n                       interfaces with managed jacks.')
mauIfGrpAutoNeg = ObjectGroup((1, 3, 6, 1, 2, 1, 26, 6, 1, 2, 7)).setObjects(*(("MAU-MIB", "ifMauAutoNegAdminStatus"), ("MAU-MIB", "ifMauAutoNegRemoteSignaling"), ("MAU-MIB", "ifMauAutoNegConfig"), ("MAU-MIB", "ifMauAutoNegCapability"), ("MAU-MIB", "ifMauAutoNegCapAdvertised"), ("MAU-MIB", "ifMauAutoNegCapReceived"), ("MAU-MIB", "ifMauAutoNegRestart"),))
if mibBuilder.loadTexts: mauIfGrpAutoNeg.setDescription('********* THIS GROUP IS DEPRECATED **********\n\n                       Conformance group for MAUs attached to\n                       interfaces with managed auto-negotiation.\n\n                       This object group has been deprecated in favor\n                       of mauIfGrpAutoNeg2.')
mauBroadBasic = ObjectGroup((1, 3, 6, 1, 2, 1, 26, 6, 1, 2, 8)).setObjects(*(("MAU-MIB", "broadMauIfIndex"), ("MAU-MIB", "broadMauIndex"), ("MAU-MIB", "broadMauXmtRcvSplitType"), ("MAU-MIB", "broadMauXmtCarrierFreq"), ("MAU-MIB", "broadMauTranslationFreq"),))
if mibBuilder.loadTexts: mauBroadBasic.setDescription('********* THIS GROUP IS DEPRECATED **********\n\n                       Conformance group for broadband MAUs attached\n                       to interfaces.\n                       This object group is deprecated.  There have\n                       been no reported implementations of this group,\n                       and it was felt to be unlikely that there will\n                       be any future implementations.')
mauIfGrpHighCapacity = ObjectGroup((1, 3, 6, 1, 2, 1, 26, 6, 1, 2, 9)).setObjects(*(("MAU-MIB", "ifMauFalseCarriers"), ("MAU-MIB", "ifMauTypeListBits"), ("MAU-MIB", "ifMauDefaultType"), ("MAU-MIB", "ifMauAutoNegSupported"),))
if mibBuilder.loadTexts: mauIfGrpHighCapacity.setDescription('Conformance group for MAUs attached to\n                       interfaces with 100 Mb/s or greater capability.')
mauIfGrpAutoNeg2 = ObjectGroup((1, 3, 6, 1, 2, 1, 26, 6, 1, 2, 10)).setObjects(*(("MAU-MIB", "ifMauAutoNegAdminStatus"), ("MAU-MIB", "ifMauAutoNegRemoteSignaling"), ("MAU-MIB", "ifMauAutoNegConfig"), ("MAU-MIB", "ifMauAutoNegCapabilityBits"), ("MAU-MIB", "ifMauAutoNegCapAdvertisedBits"), ("MAU-MIB", "ifMauAutoNegCapReceivedBits"), ("MAU-MIB", "ifMauAutoNegRestart"),))
if mibBuilder.loadTexts: mauIfGrpAutoNeg2.setDescription('Conformance group for MAUs attached to\n                       interfaces with managed auto-negotiation.')
mauIfGrpAutoNeg1000Mbps = ObjectGroup((1, 3, 6, 1, 2, 1, 26, 6, 1, 2, 11)).setObjects(*(("MAU-MIB", "ifMauAutoNegRemoteFaultAdvertised"), ("MAU-MIB", "ifMauAutoNegRemoteFaultReceived"),))
if mibBuilder.loadTexts: mauIfGrpAutoNeg1000Mbps.setDescription('Conformance group for 1000Mbps MAUs attached to\n                       interfaces with managed auto-negotiation.')
mauIfGrpHCStats = ObjectGroup((1, 3, 6, 1, 2, 1, 26, 6, 1, 2, 12)).setObjects(*(("MAU-MIB", "ifMauHCFalseCarriers"),))
if mibBuilder.loadTexts: mauIfGrpHCStats.setDescription('Conformance for high capacity statistics for\n                       MAUs attached to interfaces')
rpMauNotifications = NotificationGroup((1, 3, 6, 1, 2, 1, 26, 6, 1, 3, 1)).setObjects(*(("MAU-MIB", "rpMauJabberTrap"),))
if mibBuilder.loadTexts: rpMauNotifications.setDescription('Notifications for repeater MAUs.')
ifMauNotifications = NotificationGroup((1, 3, 6, 1, 2, 1, 26, 6, 1, 3, 2)).setObjects(*(("MAU-MIB", "ifMauJabberTrap"),))
if mibBuilder.loadTexts: ifMauNotifications.setDescription('Notifications for interface MAUs.')
mauModRpCompl = ModuleCompliance((1, 3, 6, 1, 2, 1, 26, 6, 1, 1, 1)).setObjects(*(("MAU-MIB", "mauRpGrpBasic"), ("MAU-MIB", "mauRpGrp100Mbs"), ("MAU-MIB", "mauRpGrpJack"), ("MAU-MIB", "rpMauNotifications"),))
if mibBuilder.loadTexts: mauModRpCompl.setDescription('******** THIS COMPLIANCE IS DEPRECATED ********\n                       Compliance for MAUs attached to repeater\n                       ports.\n\n                       This compliance is deprecated and replaced by\n                       mauModRpCompl2, which corrects an oversight by\n                       allowing rpMauStatus to be implemented\n                       read-only.')
mauModIfCompl = ModuleCompliance((1, 3, 6, 1, 2, 1, 26, 6, 1, 1, 2)).setObjects(*(("MAU-MIB", "mauIfGrpBasic"), ("MAU-MIB", "mauIfGrp100Mbs"), ("MAU-MIB", "mauIfGrpJack"), ("MAU-MIB", "mauIfGrpAutoNeg"), ("MAU-MIB", "mauBroadBasic"), ("MAU-MIB", "ifMauNotifications"),))
if mibBuilder.loadTexts: mauModIfCompl.setDescription('******** THIS COMPLIANCE IS DEPRECATED ********\n\n                       Compliance for MAUs attached to interfaces.\n                       This compliance is deprecated and replaced by\n                       mauModIfCompl2.')
mauModIfCompl2 = ModuleCompliance((1, 3, 6, 1, 2, 1, 26, 6, 1, 1, 3)).setObjects(*(("MAU-MIB", "mauIfGrpBasic"), ("MAU-MIB", "mauIfGrpHighCapacity"), ("MAU-MIB", "mauIfGrpJack"), ("MAU-MIB", "mauIfGrpAutoNeg2"), ("MAU-MIB", "mauIfGrpAutoNeg1000Mbps"), ("MAU-MIB", "ifMauNotifications"),))
if mibBuilder.loadTexts: mauModIfCompl2.setDescription('******** THIS COMPLIANCE IS DEPRECATED ********\n\n                       Compliance for MAUs attached to interfaces.\n\n                       This compliance is deprecated and replaced by\n                       mauModIfCompl3.')
mauModRpCompl2 = ModuleCompliance((1, 3, 6, 1, 2, 1, 26, 6, 1, 1, 4)).setObjects(*(("MAU-MIB", "mauRpGrpBasic"), ("MAU-MIB", "mauRpGrp100Mbs"), ("MAU-MIB", "mauRpGrpJack"), ("MAU-MIB", "rpMauNotifications"),))
if mibBuilder.loadTexts: mauModRpCompl2.setDescription('Compliance for MAUs attached to repeater\n                       ports.\n\n                       Note that compliance with this compliance\n                       statement requires compliance with the\n                       snmpRptrModCompl MODULE-COMPLIANCE statement of\n                       the SNMP-REPEATER-MIB (RFC 2108).')
mauModIfCompl3 = ModuleCompliance((1, 3, 6, 1, 2, 1, 26, 6, 1, 1, 5)).setObjects(*(("MAU-MIB", "mauIfGrpBasic"), ("MAU-MIB", "mauIfGrpHighCapacity"), ("MAU-MIB", "mauIfGrpHCStats"), ("MAU-MIB", "mauIfGrpJack"), ("MAU-MIB", "mauIfGrpAutoNeg2"), ("MAU-MIB", "mauIfGrpAutoNeg1000Mbps"), ("MAU-MIB", "ifMauNotifications"),))
if mibBuilder.loadTexts: mauModIfCompl3.setDescription('Compliance for MAUs attached to interfaces.\n\n                       Note that compliance with this compliance\n                       statement requires compliance with the\n                       ifCompliance3 MODULE-COMPLIANCE statement of the\n                       IF-MIB (RFC 2863) and the dot3Compliance2\n                       MODULE-COMPLIANCE statement of the\n                       EtherLike-MIB (RFC3635).')
mibBuilder.exportSymbols("MAU-MIB", ifJackIndex=ifJackIndex, rpMauJabberTrap=rpMauJabberTrap, rpMauTable=rpMauTable, ifJackType=ifJackType, mauModObjGrps=mauModObjGrps, broadMauBasicTable=broadMauBasicTable, ifMauAutoNegCapabilityBits=ifMauAutoNegCapabilityBits, JackType=JackType, dot3MauType10BaseFL=dot3MauType10BaseFL, ifMauAutoNegRemoteSignaling=ifMauAutoNegRemoteSignaling, dot3MauType1000BaseCXHD=dot3MauType1000BaseCXHD, dot3MauType1000BaseTFD=dot3MauType1000BaseTFD, mauIfGrpAutoNeg1000Mbps=mauIfGrpAutoNeg1000Mbps, PYSNMP_MODULE_ID=mauMod, rpMauFalseCarriers=rpMauFalseCarriers, ifMauStatus=ifMauStatus, dot3MauType10BaseFLHD=dot3MauType10BaseFLHD, rpMauJabberState=rpMauJabberState, ifMauAutoNegAdminStatus=ifMauAutoNegAdminStatus, dot3MauType10GigBaseEW=dot3MauType10GigBaseEW, dot3MauType100BaseT4=dot3MauType100BaseT4, dot3MauType10GigBaseW=dot3MauType10GigBaseW, dot3MauType10Base5=dot3MauType10Base5, ifMauTypeListBits=ifMauTypeListBits, ifMauMediaAvailableStateExits=ifMauMediaAvailableStateExits, ifMauAutoNegEntry=ifMauAutoNegEntry, mauRpGrp100Mbs=mauRpGrp100Mbs, dot3MauType100BaseFXHD=dot3MauType100BaseFXHD, ifMauJabberState=ifMauJabberState, dot3MauType100BaseTXFD=dot3MauType100BaseTXFD, dot3MauType10GigBaseX=dot3MauType10GigBaseX, broadMauIfIndex=broadMauIfIndex, rpMauJabberingStateEnters=rpMauJabberingStateEnters, mauRpGrpJack=mauRpGrpJack, dot3MauTypeFoirl=dot3MauTypeFoirl, dot3MauType100BaseTXHD=dot3MauType100BaseTXHD, dot3MauType100BaseT2FD=dot3MauType100BaseT2FD, rpJackType=rpJackType, dot3MauTypeAUI=dot3MauTypeAUI, ifMauAutoNegCapReceivedBits=ifMauAutoNegCapReceivedBits, snmpDot3MauMgt=snmpDot3MauMgt, dot3MauType100BaseT2HD=dot3MauType100BaseT2HD, dot3MauType1000BaseSXFD=dot3MauType1000BaseSXFD, dot3MauType10GigBaseLX4=dot3MauType10GigBaseLX4, ifMauIfIndex=ifMauIfIndex, ifMauAutoNegTable=ifMauAutoNegTable, mauIfGrpAutoNeg=mauIfGrpAutoNeg, mauModRpCompl=mauModRpCompl, dot3MauType1000BaseTHD=dot3MauType1000BaseTHD, dot3MauType100BaseFXFD=dot3MauType100BaseFXFD, ifMauIndex=ifMauIndex, snmpDot3MauTraps=snmpDot3MauTraps, dot3IfMauAutoNegGroup=dot3IfMauAutoNegGroup, rpMauMediaAvailableStateExits=rpMauMediaAvailableStateExits, mauIfGrpHCStats=mauIfGrpHCStats, ifMauTypeList=ifMauTypeList, dot3MauType10GigBaseR=dot3MauType10GigBaseR, rpJackEntry=rpJackEntry, dot3MauType10BaseT=dot3MauType10BaseT, dot3MauType10Base2=dot3MauType10Base2, mauRpGrpBasic=mauRpGrpBasic, ifMauAutoNegCapAdvertisedBits=ifMauAutoNegCapAdvertisedBits, rpMauEntry=rpMauEntry, rpJackTable=rpJackTable, ifMauMediaAvailable=ifMauMediaAvailable, ifMauAutoNegCapability=ifMauAutoNegCapability, dot3MauType1000BaseXFD=dot3MauType1000BaseXFD, dot3MauType1000BaseCXFD=dot3MauType1000BaseCXFD, mauIfGrp100Mbs=mauIfGrp100Mbs, broadMauBasicEntry=broadMauBasicEntry, dot3MauType1000BaseSXHD=dot3MauType1000BaseSXHD, mauModRpCompl2=mauModRpCompl2, mauIfGrpAutoNeg2=mauIfGrpAutoNeg2, ifMauAutoNegConfig=ifMauAutoNegConfig, rpJackIndex=rpJackIndex, ifMauAutoNegCapReceived=ifMauAutoNegCapReceived, mauIfGrpBasic=mauIfGrpBasic, ifMauJabberingStateEnters=ifMauJabberingStateEnters, ifJackEntry=ifJackEntry, ifMauAutoNegRestart=ifMauAutoNegRestart, dot3MauType10BaseFB=dot3MauType10BaseFB, ifMauNotifications=ifMauNotifications, ifMauAutoNegCapAdvertised=ifMauAutoNegCapAdvertised, ifMauEntry=ifMauEntry, mauIfGrpHighCapacity=mauIfGrpHighCapacity, dot3MauType1000BaseLXFD=dot3MauType1000BaseLXFD, ifMauJabberTrap=ifMauJabberTrap, dot3MauType10Broad36=dot3MauType10Broad36, mauBroadBasic=mauBroadBasic, dot3IfMauBasicGroup=dot3IfMauBasicGroup, dot3MauType10GigBaseLR=dot3MauType10GigBaseLR, dot3MauType10GigBaseSW=dot3MauType10GigBaseSW, dot3RpMauBasicGroup=dot3RpMauBasicGroup, rpMauGroupIndex=rpMauGroupIndex, ifMauFalseCarriers=ifMauFalseCarriers, dot3MauType10GigBaseLW=dot3MauType10GigBaseLW, dot3MauType1000BaseLXHD=dot3MauType1000BaseLXHD, mauModIfCompl=mauModIfCompl, mauModIfCompl3=mauModIfCompl3, ifMauType=ifMauType, dot3MauType10GigBaseSR=dot3MauType10GigBaseSR, ifMauTable=ifMauTable, rpMauNotifications=rpMauNotifications, dot3MauType=dot3MauType, dot3MauType1000BaseXHD=dot3MauType1000BaseXHD, mauModNotGrps=mauModNotGrps, dot3MauType10BaseFLFD=dot3MauType10BaseFLFD, ifMauAutoNegRemoteFaultAdvertised=ifMauAutoNegRemoteFaultAdvertised, broadMauXmtRcvSplitType=broadMauXmtRcvSplitType, dot3MauType10BaseTHD=dot3MauType10BaseTHD, dot3MauType10BaseTFD=dot3MauType10BaseTFD, mauIfGrpJack=mauIfGrpJack, dot3MauType10GigBaseER=dot3MauType10GigBaseER, rpMauType=rpMauType, rpMauPortIndex=rpMauPortIndex, mauMod=mauMod, rpMauIndex=rpMauIndex, ifMauDefaultType=ifMauDefaultType, broadMauTranslationFreq=broadMauTranslationFreq, mauModCompls=mauModCompls, ifJackTable=ifJackTable, broadMauXmtCarrierFreq=broadMauXmtCarrierFreq, dot3BroadMauBasicGroup=dot3BroadMauBasicGroup, broadMauIndex=broadMauIndex, ifMauHCFalseCarriers=ifMauHCFalseCarriers, dot3MauType10BaseFP=dot3MauType10BaseFP, mauModIfCompl2=mauModIfCompl2, rpMauStatus=rpMauStatus, ifMauAutoNegSupported=ifMauAutoNegSupported, rpMauMediaAvailable=rpMauMediaAvailable, mauModConf=mauModConf, ifMauAutoNegRemoteFaultReceived=ifMauAutoNegRemoteFaultReceived)
