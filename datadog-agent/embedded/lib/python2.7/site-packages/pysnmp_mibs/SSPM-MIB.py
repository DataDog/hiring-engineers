#
# PySNMP MIB module SSPM-MIB (http://pysnmp.sf.net)
# ASN.1 source http://mibs.snmplabs.com:80/asn1/SSPM-MIB
# Produced by pysmi-0.0.7 at Sun Feb 14 00:29:28 2016
# On host bldfarm platform Linux version 4.1.13-100.fc21.x86_64 by user goose
# Using Python version 3.5.0 (default, Jan  5 2016, 17:11:52) 
#
( AppLocalIndex, ) = mibBuilder.importSymbols("APM-MIB", "AppLocalIndex")
( ObjectIdentifier, OctetString, Integer, ) = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion")
( InterfaceIndexOrZero, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
( InetAddress, InetAddressType, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
( OwnerString, rmon, ) = mibBuilder.importSymbols("RMON-MIB", "OwnerString", "rmon")
( ObjectGroup, NotificationGroup, ModuleCompliance, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
( Counter32, ModuleIdentity, Counter64, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, IpAddress, Integer32, NotificationType, iso, Gauge32, Bits, ObjectIdentity, MibIdentifier, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "ModuleIdentity", "Counter64", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "IpAddress", "Integer32", "NotificationType", "iso", "Gauge32", "Bits", "ObjectIdentity", "MibIdentifier")
( StorageType, TextualConvention, RowStatus, DisplayString, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "StorageType", "TextualConvention", "RowStatus", "DisplayString", "TruthValue")
( Utf8String, ) = mibBuilder.importSymbols("SYSAPPL-MIB", "Utf8String")
sspmMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 16, 28)).setRevisions(("2005-07-28 00:00",))
if mibBuilder.loadTexts: sspmMIB.setLastUpdated('200507280000Z')
if mibBuilder.loadTexts: sspmMIB.setOrganization('IETF RMON MIB working group')
if mibBuilder.loadTexts: sspmMIB.setContactInfo('        Carl W. Kalbfleisch\n                    Consultant\n\n            E-mail: ietf@kalbfleisch.us\n\n            Working group mailing list: rmonmib@ietf.org\n            To subscribe send email to rmonmib-request@ietf.org')
if mibBuilder.loadTexts: sspmMIB.setDescription('This SSPM MIB module is applicable to probes\n            implementing Synthetic Source for Performance\n            Monitoring functions.\n\n            Copyright (C) The Internet Society (2005).  This version\n            of this MIB module is part of RFC 4149; see the RFC\n            itself for full legal notices.')
sspmMIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 1))
sspmMIBNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 2))
sspmMIBConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 3))
class SspmMicroSeconds(Unsigned32, TextualConvention):
    displayHint = 'd'

class SspmClockSource(Integer32, TextualConvention):
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec+ValueRangeConstraint(0,255)

class SspmClockMaxSkew(Integer32, TextualConvention):
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec+ValueRangeConstraint(1,65535)

sspmGeneral = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 1, 1))
sspmGeneralClockResolution = MibScalar((1, 3, 6, 1, 2, 1, 16, 28, 1, 1, 1), SspmMicroSeconds()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmGeneralClockResolution.setDescription('A read-only variable indicating the resolution\n      of the measurements possible by this device.')
sspmGeneralClockMaxSkew = MibScalar((1, 3, 6, 1, 2, 1, 16, 28, 1, 1, 2), SspmClockMaxSkew()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmGeneralClockMaxSkew.setDescription('A read-only variable indicating the maximum offset\n         error due to skew of the local clock over the\n         time interval 86400 seconds, in seconds.')
sspmGeneralClockSource = MibScalar((1, 3, 6, 1, 2, 1, 16, 28, 1, 1, 3), SspmClockSource()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmGeneralClockSource.setDescription('A read-only variable indicating the source of the clock.\n         This is provided to allow a user to determine how accurate\n         the timing mechanism is compared with other devices.  This\n         is needed for the coordination of time values\n         between probes for one-way measurements.')
sspmGeneralMinFrequency = MibScalar((1, 3, 6, 1, 2, 1, 16, 28, 1, 1, 4), SspmMicroSeconds()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmGeneralMinFrequency.setDescription("A read-only variable that indicates the devices'\n          capability for the minimum supported\n          sspmSourceFrequency.  If sspmSourceFrequency is\n          set to a value lower than the value reported\n          by this attribute, then the set of sspmSourceFrequency\n          will fail with an inconsistent value error.")
sspmCapabilitiesTable = MibTable((1, 3, 6, 1, 2, 1, 16, 28, 1, 1, 5), )
if mibBuilder.loadTexts: sspmCapabilitiesTable.setDescription('The table of SSPM capabilities.')
sspmCapabilitiesEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 28, 1, 1, 5, 1), ).setIndexNames((0, "SSPM-MIB", "sspmCapabilitiesInstance"))
if mibBuilder.loadTexts: sspmCapabilitiesEntry.setDescription('Details about a particular SSPM capability.')
sspmCapabilitiesInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 1, 5, 1, 1), AppLocalIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmCapabilitiesInstance.setDescription('Indicates whether SSPM configuration of the corresponding\n         AppLocalIndex is supported by this device.  Generally,\n         entries in this table are only made by the device when the\n         configuration of the measurement is available.')
sspmSource = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 1, 2))
sspmSourceProfileTable = MibTable((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1), )
if mibBuilder.loadTexts: sspmSourceProfileTable.setDescription('The table of SSPM Source Profiles configured.')
sspmSourceProfileEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1), ).setIndexNames((0, "SSPM-MIB", "sspmSourceProfileInstance"))
if mibBuilder.loadTexts: sspmSourceProfileEntry.setDescription('Details about a particular SSPM Source Profile\n         configuration.  Entries must exist in this table\n         in order to be referenced by rows in the\n         sspmSourceControlTable.')
sspmSourceProfileInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1,65535)))
if mibBuilder.loadTexts: sspmSourceProfileInstance.setDescription('An arbitrary index.')
sspmSourceProfileType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 2), AppLocalIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileType.setDescription("The AppLocalIndex value that uniquely identifies the\n         measurement per the APM-MIB.  In order to create a row\n         in this table, there must be a corresponding row in the\n         sspmCapabilitiesTable.\n\n         When attempting to set this object, if no\n         corresponding row exists in the sspmCapabilitiesTable,\n         then the agent should return a 'badValue' error.")
sspmSourceProfilePacketSize = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 3), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfilePacketSize.setDescription("The size of packet to be transmitted in bytes.  The\n         size accounts for all data within the IPv4 or IPv6\n         payloads, excluding the IP headers, IP header options\n         and link-level protocol headers.\n\n         If the size is set smaller than the minimum allowed\n         packet size or greater than the maximum allowed\n         packet size, then the set should fail, and the agent\n         should return a 'badValue' error.")
sspmSourceProfilePacketFillType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("random", 1), ("pattern", 2), ("url", 3),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfilePacketFillType.setDescription("Indicates how the packet is filled.\n\n         'random' indicates that the packet contains random\n         data patterns.  This is probe and implementation\n         dependent.\n\n         'pattern' indicates that the pattern defined in the\n         sspmSourceProfilePacketFillValue attribute is used to\n         fill the packet.\n\n         'url' indicates that the value of\n         sspmSourceProfilePacketFillValue should\n         contain a URL.  The contents of the document\n         at that URL are retrieved when sspmSourceStatus becomes\n         active and utilized in the packet.  If the attempt to\n         access that URL fails, then the row status is set to\n         'notReady', and the set should fail with\n         'inconsistentValue'.  This value must contain a\n         dereferencable URL of the type 'http:', 'https:', or\n         'ftp:' only.")
sspmSourceProfilePacketFillValue = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0,255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfilePacketFillValue.setDescription("The string value with which to fill the packet.  If\n         sspmSourceProfilePacketFillType is set to 'pattern',\n         then this pattern is repeated until the packet is\n         sspmSourcePacketSize in bytes.  Note that if the\n         length of the octet string specified for this\n         value does not divide evenly into the packet\n         size, then an incomplete last copy of this data\n         may be copied into the packet.  If the value of\n         sspmSourceProfilePacketFillType is set to 'random', then\n         this attribute is unused.  If the value of the\n         sspmSourceProfilePacketFillType is set to 'url', then\n         the URL specified in this attribute is retrieved\n         and used by the probe.  In the case of a URL, this value\n         must contain a dereferencable URL of the type\n         'http:', 'https:', or 'ftp:' only.")
sspmSourceProfileTOS = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileTOS.setDescription('Represents the TOS field in the IP packet header.  The\n        value of this object defaults to zero if not set.')
sspmSourceProfileFlowLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,1048575))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileFlowLabel.setDescription('This object is used to specify the Flow Label in a IPv6\n         packet (RFC 2460) to force special handling by the IPv6\n         routers; e.g., non-default quality-of-service handling.\n\n         This object is meaningful only when the object\n         sspmSourceDestAddressType is IPv6(2).\n         The value of this object defaults to zero if not set.')
sspmSourceProfileLooseSrcRteFill = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0,240))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileLooseSrcRteFill.setDescription('In the event that the test should run over a\n         specific route, the intent is to force the route using the\n         Loose Source Route option in IPv4 [RFC791] and\n         IPv6 [RFC2460].  This object contains a\n         series of IP addresses along the path that would be\n         put into the loose source route option in the IP header.\n\n         The IPv4 addresses are to be listed as 32-bit\n         address values, and the IPv6 addresses are to be\n         listed as a string of 128-bit addresses.  The\n         maximum length allowed within the IPv4 source route\n         option is 63 addresses.  To simply account for\n         IPv6 addresses as well, the maximum length of the\n         octet string is 240.  This allows up to 60\n         IPv4 addresses or up to 15 IPv6 addresses in the\n         string.')
sspmSourceProfileLooseSrcRteLen = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,240))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileLooseSrcRteLen.setDescription('In the event that the test should run over a\n         specific route, the intent is to force the route.\n         This attribute specifies the length of data to\n         be copied from the sspmSourceProfileLooseSrcRteFill\n         into the route data fields of the loose source route\n\n         options in the IPv4 or IPv6 headers.')
sspmSourceProfileTTL = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileTTL.setDescription('If non-zero, this specifies the value to place into\n         the TTL field on transmission.')
sspmSourceProfileNoFrag = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 11), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileNoFrag.setDescription("When true, the 'Don't Fragment Bit' should be set\n         on the packet header.")
sspmSourceProfile8021Tagging = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1,65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfile8021Tagging.setDescription("IEEE 802.1Q tagging used in IEEE 802.1D bridged\n        environments.\n\n        A value of -1 indicates that the packets are untagged.\n\n        A value of 0 to 65535 is the value of the tag to be\n        inserted in the tagged packets.\n\n        Note that according to IEEE 802.1Q, VLAN-ID tags with\n        a value of 4095 shall not be transmitted on the wire.\n        As the VLAN-ID is encoded in the 12 least significant\n        bits on the tag, values that translate in a binary\n        representation of all 1's in the last 12 bits\n        SHALL NOT be configured.  In this case, the set should\n        fail, and return an error-status of 'inconsistentValue'.")
sspmSourceProfileUsername = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 13), Utf8String()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileUsername.setDescription('An optional username used by the application protocol.')
sspmSourceProfilePassword = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 14), Utf8String()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfilePassword.setDescription('An optional password used by the application protocol.')
sspmSourceProfileParameter = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0,65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileParameter.setDescription('An optional parameter used by the application protocol.\n         For DNS, this would be the hostname or IP.  For HTTP,\n         this would be the URL.  For nntp, this would be the\n         news group.  For TCP, this would be the port number.\n         For SMTP, this would be the recipient (and could\n         assume the message is predefined).')
sspmSourceProfileOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 16), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileOwner.setDescription('Name of the management station/application that\n        set up the profile.')
sspmSourceProfileStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 17), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileStorageType.setDescription("The storage type of this sspmSourceProfileEntry.  If the\n        value of this object is 'permanent', no objects in this row\n        need to be writable.")
sspmSourceProfileStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 18), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileStatus.setDescription('Status of this profile.\n\n        An entry may not exist in the active state unless all\n        objects in the entry have an appropriate value.\n\n        Once this object is set to active(1), no objects in the\n        sspmSourceProfileTable can be changed.')
sspmSourceControlTable = MibTable((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2), )
if mibBuilder.loadTexts: sspmSourceControlTable.setDescription('The table of SSPM measurements configured.')
sspmSourceControlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1), ).setIndexNames((0, "SSPM-MIB", "sspmSourceControlInstance"))
if mibBuilder.loadTexts: sspmSourceControlEntry.setDescription('Details about a particular SSPM configuration.')
sspmSourceControlInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1,65535)))
if mibBuilder.loadTexts: sspmSourceControlInstance.setDescription('An arbitrary index.')
sspmSourceControlProfile = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlProfile.setDescription('A pointer to the profile (sspmSourceProfileEntry) that\n         this control entry uses to define the test being\n         performed.')
sspmSourceControlSrc = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 3), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlSrc.setDescription('The ifIndex where the packet should originate from the\n         probe (if it matters).  A value of zero indicates that\n         it does not matter and that the device decides.')
sspmSourceControlDestAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 4), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlDestAddrType.setDescription('The type of Internet address by which the destination\n         is accessed.')
sspmSourceControlDestAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 5), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlDestAddr.setDescription('The Internet address for the destination.  The formatting\n        of this object is controlled by the\n        sspmSourceControlDestAddrType object above.\n\n        When this object contains a DNS name, then the name is\n        resolved to an address each time measurement is to be made.\n        Further, the agent should not cache this address,\n        but instead should perform the resolution prior to each\n        measurement.')
sspmSourceControlEnabled = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 6), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlEnabled.setDescription("When set to 'true', this test is enabled.  When set to\n         'false', it is disabled.")
sspmSourceControlTimeOut = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 7), SspmMicroSeconds()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlTimeOut.setDescription('Timeout value for the measurement response.  If no\n         response is received in the time specified, then\n         the test fails.')
sspmSourceControlSamplingDist = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("deterministic", 1), ("poisson", 2),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlSamplingDist.setDescription("When this attribute is set to 'deterministic', then\n         packets are generated at with a fixed inter-packet\n         injection time specified by sspmSourceFrequency.\n\n         When this attribute is set to 'Poisson', then packets\n         are generated with inter-packet injection times sampled\n         from an exponential distribution with the single\n         distributional parameter determined by the inverse\n         frequency).")
sspmSourceControlFrequency = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 9), SspmMicroSeconds()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlFrequency.setDescription("The inverse of this value is the rate at which packets\n         are generated.  Refer to sspmSourceSamplingDistribution.\n         If the value set is less than the value of\n         sspmGeneralMinFrequency, then the set will fail with an\n         error-status of 'inconsistentValue'.")
sspmSourceControlFirstSeqNum = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 10), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlFirstSeqNum.setDescription('The first sequence number of packets to be transmitted.')
sspmSourceControlLastSeqNum = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmSourceControlLastSeqNum.setDescription('The last sequence number transmitted.  This value is updated\n         by the agent after packet generation.')
sspmSourceControlOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 12), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlOwner.setDescription('Name of the management station/application that set\n        up the test.')
sspmSourceControlStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 13), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlStorageType.setDescription("The storage type of this sspmSourceControlEntry.  If the\n        value of this object is 'permanent', no objects in this row\n        need to be writable.")
sspmSourceControlStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 14), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlStatus.setDescription("Status of this source control entry.\n\n        An entry may not exist in the active state unless all\n        objects in the entry have an appropriate value.\n\n        When this attribute has the value of\n        'active', none of the read-write or read-create attributes\n        in this table may be modified, with the exception of\n        sspmSourceControlEnabled.")
sspmSink = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 1, 5))
sspmSinkTable = MibTable((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1), )
if mibBuilder.loadTexts: sspmSinkTable.setDescription('A table configuring the sink for measurements.')
sspmSinkEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1), ).setIndexNames((0, "SSPM-MIB", "sspmSinkInstance"))
if mibBuilder.loadTexts: sspmSinkEntry.setDescription('The details of a particular sink entry.  If the measurement\n         is a round-trip type, then the sink entry will be on the\n         same probe as the corresponding sspmSourceEntry.  If the\n         measurement is a one-way, type then the sink entry will be\n         on a different probe.')
sspmSinkInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1,65535)))
if mibBuilder.loadTexts: sspmSinkInstance.setDescription('An index.  When the measurement is for a round-trip\n         measurement, then this table entry is on the same probe as\n         the corresponding sspmSourceEntry, and the value of this\n         attribute should correspond to the value of\n         sspmSourceInstance.  Management applications configuring\n         sinks for one-way measurements could define some\n         scheme whereby the sspmSinkInstance is unique across\n         all probes.  Note that the unique key to this entry is\n         also constructed with sspmSinkType,\n         sspmSinkSourceAddressType, and sspmSinkSourceAddress.\n         To make the implementation simpler, those other\n         attributes are not included in the index but uniqueness\n         is still needed to receive all the packets.')
sspmSinkType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 2), AppLocalIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkType.setDescription("The AppLocalIndex value that uniquely identifies the\n         measurement per the APM-MIB.  In order to create a row\n         in this table, there must be a corresponding row in the\n         sspmCapabilitiesTable.  If there is no corresponding\n         row in the sspmCapabilitiestable, then the agent will\n         return an error-status of 'inconsistentValue'.")
sspmSinkSourceAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 3), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkSourceAddressType.setDescription('The type of Internet address of the source.')
sspmSinkSourceAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 4), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkSourceAddress.setDescription("The Internet address of the source.  The formatting\n        of this object is controlled by the sspmSinkSourceAddressType\n        object above.\n\n        This object should be set only to a valid device address\n        that has been administratively configured into the\n        device.  If a set attempts to set this object to an\n        address that does not belong (i.e., is not administratively\n        configured into the device), the set should fail, and the\n        agent should return a error-status of 'inconsistentValue'.")
sspmSinkExpectedRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 5), SspmMicroSeconds()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkExpectedRate.setDescription('The expected rate at which packets will arrive.')
sspmSinkEnable = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 6), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkEnable.setDescription('Indicates if the sink is enabled or not.')
sspmSinkExpectedFirstSequenceNum = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 7), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkExpectedFirstSequenceNum.setDescription('The expected first sequence number of packets.\n         This is used by the sink to determine if packets\n         were lost at the initiation of the test.')
sspmSinkLastSequenceNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmSinkLastSequenceNumber.setDescription('The last sequence number received.')
sspmSinkLastSequenceInvalid = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmSinkLastSequenceInvalid.setDescription('The number of packets that arrived whose\n         sequence number was not one plus the value of\n         sspmSinkLastSequenceNumber.')
sspmSinkStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 10), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkStorageType.setDescription("The storage type of this sspmSinkEntry.  If the value\n        of this object is 'permanent', no objects in this row\n        need to be writable.")
sspmSinkStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkStatus.setDescription('Status of this conceptual row.\n         An entry may not exist in the active state unless all\n         objects in the entry have an appropriate value.\n\n         Once this object is set to active(1), no objects with\n         MAX-ACCESS of read-create in the sspmSinkTable can\n         be changed.')
sspmCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 3, 1))
sspmGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 3, 2))
sspmGeneralCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 28, 3, 1, 1)).setObjects(*(("SSPM-MIB", "sspmGeneralGroup"), ("SSPM-MIB", "sspmSourceGroup"), ("SSPM-MIB", "sspmSinkGroup"), ("SSPM-MIB", "sspmUserPassGroup"),))
if mibBuilder.loadTexts: sspmGeneralCompliance.setDescription('A general compliance that allows all things to be optional.')
sspmSourceFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 28, 3, 1, 2)).setObjects(*(("SSPM-MIB", "sspmGeneralGroup"), ("SSPM-MIB", "sspmSourceGroup"), ("SSPM-MIB", "sspmUserPassGroup"),))
if mibBuilder.loadTexts: sspmSourceFullCompliance.setDescription('A source compliance.  Use this compliance when implementing\n     a traffic-source-only device.  This is useful for implementing\n     devices that probe other devices for intrusive application\n     monitoring.  It is also useful for implementing the source\n     of one-way tests used with a sink-only device.')
sspmSinkFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 28, 3, 1, 3)).setObjects(*(("SSPM-MIB", "sspmGeneralGroup"), ("SSPM-MIB", "sspmSinkGroup"),))
if mibBuilder.loadTexts: sspmSinkFullCompliance.setDescription('A sink-only compliance.  Use this compliance when implementing a\n     sink-only device.  This is useful for devices to receive one-way\n     measurements.')
sspmGeneralGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 28, 3, 2, 1)).setObjects(*(("SSPM-MIB", "sspmGeneralClockResolution"), ("SSPM-MIB", "sspmGeneralClockMaxSkew"), ("SSPM-MIB", "sspmGeneralClockSource"), ("SSPM-MIB", "sspmGeneralMinFrequency"), ("SSPM-MIB", "sspmCapabilitiesInstance"),))
if mibBuilder.loadTexts: sspmGeneralGroup.setDescription('The objects in the SSPM General Group.')
sspmSourceGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 28, 3, 2, 2)).setObjects(*(("SSPM-MIB", "sspmSourceProfileType"), ("SSPM-MIB", "sspmSourceProfilePacketSize"), ("SSPM-MIB", "sspmSourceProfilePacketFillType"), ("SSPM-MIB", "sspmSourceProfilePacketFillValue"), ("SSPM-MIB", "sspmSourceProfileTOS"), ("SSPM-MIB", "sspmSourceProfileFlowLabel"), ("SSPM-MIB", "sspmSourceProfileLooseSrcRteFill"), ("SSPM-MIB", "sspmSourceProfileLooseSrcRteLen"), ("SSPM-MIB", "sspmSourceProfileTTL"), ("SSPM-MIB", "sspmSourceProfileNoFrag"), ("SSPM-MIB", "sspmSourceProfile8021Tagging"), ("SSPM-MIB", "sspmSourceProfileUsername"), ("SSPM-MIB", "sspmSourceProfilePassword"), ("SSPM-MIB", "sspmSourceProfileParameter"), ("SSPM-MIB", "sspmSourceProfileOwner"), ("SSPM-MIB", "sspmSourceProfileStorageType"), ("SSPM-MIB", "sspmSourceProfileStatus"), ("SSPM-MIB", "sspmSourceControlProfile"), ("SSPM-MIB", "sspmSourceControlSrc"), ("SSPM-MIB", "sspmSourceControlDestAddrType"), ("SSPM-MIB", "sspmSourceControlDestAddr"), ("SSPM-MIB", "sspmSourceControlEnabled"), ("SSPM-MIB", "sspmSourceControlTimeOut"), ("SSPM-MIB", "sspmSourceControlSamplingDist"), ("SSPM-MIB", "sspmSourceControlFrequency"), ("SSPM-MIB", "sspmSourceControlFirstSeqNum"), ("SSPM-MIB", "sspmSourceControlLastSeqNum"), ("SSPM-MIB", "sspmSourceControlOwner"), ("SSPM-MIB", "sspmSourceControlStorageType"), ("SSPM-MIB", "sspmSourceControlStatus"),))
if mibBuilder.loadTexts: sspmSourceGroup.setDescription('The objects in the SSPM Source Group.')
sspmUserPassGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 28, 3, 2, 3)).setObjects(*(("SSPM-MIB", "sspmSourceProfileUsername"), ("SSPM-MIB", "sspmSourceProfilePassword"),))
if mibBuilder.loadTexts: sspmUserPassGroup.setDescription('The objects in the SSPM Username and password group.')
sspmSinkGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 28, 3, 2, 4)).setObjects(*(("SSPM-MIB", "sspmSinkType"), ("SSPM-MIB", "sspmSinkSourceAddressType"), ("SSPM-MIB", "sspmSinkSourceAddress"), ("SSPM-MIB", "sspmSinkExpectedRate"), ("SSPM-MIB", "sspmSinkEnable"), ("SSPM-MIB", "sspmSinkExpectedFirstSequenceNum"), ("SSPM-MIB", "sspmSinkLastSequenceNumber"), ("SSPM-MIB", "sspmSinkLastSequenceInvalid"), ("SSPM-MIB", "sspmSinkStorageType"), ("SSPM-MIB", "sspmSinkStatus"),))
if mibBuilder.loadTexts: sspmSinkGroup.setDescription('The objects in the SSPM Sink Group.')
mibBuilder.exportSymbols("SSPM-MIB", sspmSinkSourceAddress=sspmSinkSourceAddress, sspmSourceProfilePacketFillType=sspmSourceProfilePacketFillType, sspmGeneralClockSource=sspmGeneralClockSource, SspmClockSource=SspmClockSource, sspmSourceProfileParameter=sspmSourceProfileParameter, sspmSinkSourceAddressType=sspmSinkSourceAddressType, sspmSourceFullCompliance=sspmSourceFullCompliance, sspmSource=sspmSource, sspmSourceProfilePacketSize=sspmSourceProfilePacketSize, sspmSourceControlDestAddr=sspmSourceControlDestAddr, SspmClockMaxSkew=SspmClockMaxSkew, sspmSourceProfileTTL=sspmSourceProfileTTL, sspmSourceProfileOwner=sspmSourceProfileOwner, sspmGeneralMinFrequency=sspmGeneralMinFrequency, sspmSourceProfileEntry=sspmSourceProfileEntry, sspmMIB=sspmMIB, sspmSink=sspmSink, sspmSourceControlLastSeqNum=sspmSourceControlLastSeqNum, sspmCapabilitiesTable=sspmCapabilitiesTable, sspmMIBConformance=sspmMIBConformance, sspmSourceControlSamplingDist=sspmSourceControlSamplingDist, sspmSourceControlStatus=sspmSourceControlStatus, sspmMIBNotifications=sspmMIBNotifications, sspmSinkEnable=sspmSinkEnable, sspmCapabilitiesInstance=sspmCapabilitiesInstance, SspmMicroSeconds=SspmMicroSeconds, sspmSourceProfileFlowLabel=sspmSourceProfileFlowLabel, sspmSourceControlProfile=sspmSourceControlProfile, sspmSourceControlOwner=sspmSourceControlOwner, sspmGeneral=sspmGeneral, sspmSourceProfilePacketFillValue=sspmSourceProfilePacketFillValue, sspmSourceProfileStorageType=sspmSourceProfileStorageType, sspmSinkType=sspmSinkType, sspmSinkInstance=sspmSinkInstance, sspmGeneralCompliance=sspmGeneralCompliance, sspmSourceControlEnabled=sspmSourceControlEnabled, sspmSinkExpectedFirstSequenceNum=sspmSinkExpectedFirstSequenceNum, sspmSourceProfileInstance=sspmSourceProfileInstance, sspmCompliances=sspmCompliances, sspmSinkEntry=sspmSinkEntry, sspmSourceProfileType=sspmSourceProfileType, sspmSourceControlStorageType=sspmSourceControlStorageType, sspmSinkFullCompliance=sspmSinkFullCompliance, sspmSourceControlInstance=sspmSourceControlInstance, sspmSourceProfileLooseSrcRteLen=sspmSourceProfileLooseSrcRteLen, sspmSourceProfileTable=sspmSourceProfileTable, sspmGeneralClockMaxSkew=sspmGeneralClockMaxSkew, sspmSourceControlTable=sspmSourceControlTable, sspmMIBObjects=sspmMIBObjects, sspmGeneralGroup=sspmGeneralGroup, sspmCapabilitiesEntry=sspmCapabilitiesEntry, sspmGroups=sspmGroups, sspmUserPassGroup=sspmUserPassGroup, sspmSourceControlDestAddrType=sspmSourceControlDestAddrType, sspmSourceControlEntry=sspmSourceControlEntry, sspmSourceProfileTOS=sspmSourceProfileTOS, sspmSinkTable=sspmSinkTable, sspmSinkStatus=sspmSinkStatus, sspmSinkLastSequenceNumber=sspmSinkLastSequenceNumber, PYSNMP_MODULE_ID=sspmMIB, sspmSourceProfilePassword=sspmSourceProfilePassword, sspmSinkLastSequenceInvalid=sspmSinkLastSequenceInvalid, sspmGeneralClockResolution=sspmGeneralClockResolution, sspmSourceProfileUsername=sspmSourceProfileUsername, sspmSourceControlTimeOut=sspmSourceControlTimeOut, sspmSourceControlFirstSeqNum=sspmSourceControlFirstSeqNum, sspmSourceProfile8021Tagging=sspmSourceProfile8021Tagging, sspmSinkExpectedRate=sspmSinkExpectedRate, sspmSourceControlFrequency=sspmSourceControlFrequency, sspmSinkGroup=sspmSinkGroup, sspmSourceGroup=sspmSourceGroup, sspmSourceControlSrc=sspmSourceControlSrc, sspmSourceProfileLooseSrcRteFill=sspmSourceProfileLooseSrcRteFill, sspmSourceProfileStatus=sspmSourceProfileStatus, sspmSourceProfileNoFrag=sspmSourceProfileNoFrag, sspmSinkStorageType=sspmSinkStorageType)
