#
# PySNMP MIB module DOT12-IF-MIB (http://pysnmp.sf.net)
# ASN.1 source http://mibs.snmplabs.com:80/asn1/DOT12-IF-MIB
# Produced by pysmi-0.0.7 at Sun Feb 14 00:10:24 2016
# On host bldfarm platform Linux version 4.1.13-100.fc21.x86_64 by user goose
# Using Python version 3.5.0 (default, Jan  5 2016, 17:11:52) 
#
( ObjectIdentifier, Integer, OctetString, ) = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection")
( ifIndex, ) = mibBuilder.importSymbols("IF-MIB", "ifIndex")
( NotificationGroup, ModuleCompliance, ) = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
( ObjectIdentity, Integer32, Bits, Counter64, TimeTicks, experimental, iso, IpAddress, ModuleIdentity, Counter32, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, MibIdentifier, Unsigned32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "Integer32", "Bits", "Counter64", "TimeTicks", "experimental", "iso", "IpAddress", "ModuleIdentity", "Counter32", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "MibIdentifier", "Unsigned32")
( TextualConvention, DisplayString, ) = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
dot12MIB = MibIdentifier((1, 3, 6, 1, 3, 63))
dot12MIBObjects = MibIdentifier((1, 3, 6, 1, 3, 63, 1))
dot12ConfigTable = MibTable((1, 3, 6, 1, 3, 63, 1, 1), )
if mibBuilder.loadTexts: dot12ConfigTable.setDescription('Configuration information for a collection of\n                   802.12 interfaces attached to a particular\n                   system.')
dot12ConfigEntry = MibTableRow((1, 3, 6, 1, 3, 63, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dot12ConfigEntry.setDescription('Configuration for a particular interface to an\n                   802.12 medium.')
dot12DesiredFramingType = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("frameType88023", 1), ("frameType88025", 2), ("frameTypeEither", 3),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot12DesiredFramingType.setDescription("The type of framing which will be requested by\n                   the interface during the next interface MAC\n                   initialization or open action.\n\n                   In master mode, this is the framing mode which\n                   will be granted by the interface.  Note that\n                   for a master mode interface, this object must be\n                   equal to 'frameType88023' or 'frameType88025',\n                   since a master mode interface cannot grant\n                   'frameTypeEither'.")
dot12FramingCapability = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("frameType88023", 1), ("frameType88025", 2), ("frameTypeEither", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12FramingCapability.setDescription('The type of framing this interface is capable of\n                   supporting.')
dot12DesiredPromiscStatus = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("singleAddressMode", 1), ("promiscuousMode", 2),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot12DesiredPromiscStatus.setDescription('This object is used to select the promiscuous\n                   mode that this interface will request in the next\n                   training packet issued on this interface.\n                   Whether the repeater grants the requested mode\n                   must be verified by examining the state of the PP\n                   bits in the corresponding instance of\n                   dot12LastTrainingConfig.\n\n                   In master mode, this object controls whether or\n                   not promiscuous mode will be granted by the\n                   interface when requested by the lower level\n                   device.\n\n                   Note that this object indicates the desired mode\n                   for the next time the interface trains.  The\n                   currently active mode will be reflected in\n                   dot12LastTrainingConfig and in ifPromiscuousMode.')
dot12TrainingVersion = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12TrainingVersion.setDescription('The value that will be used in the version bits\n                   (vvv bits) in training frames on this interface.\n                   This is the highest version number supported by\n                   this MAC.')
dot12LastTrainingConfig = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2,2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12LastTrainingConfig.setDescription('This 16 bit field contains the configuration\n                   bits from the most recent error-free training\n                   frame received during training on this interface.\n                   Training request frames are received when in\n                   master mode, while training response frames are\n                   received in slave mode.  On master mode interfaces,\n                   this object contains the contents of the\n                   requested configuration field of the most recent\n                   traing request frame.  On slave mode interfaces,\n                   this object contains the contents of the allowed\n                   configuration field of the most recent training\n                   response frame.  The format of the current version\n                   of this field is described in section 3.7.  Please\n                   refer to the most recent version of the IEEE\n                   802.12 standard for the most up-to-date definition\n                   of the format of this object.')
dot12Commands = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4,))).clone(namedValues=NamedValues(("noOp", 1), ("open", 2), ("reset", 3), ("close", 4),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot12Commands.setDescription("If the current value of dot12Status is 'closed',\n                   setting the value of this object to 'open' will\n                   change the corresponding instance of MIB-II's\n                   ifAdminStatus to 'up', cause this interface to\n                   enter the 'opening' state, and will cause training\n                   to be initiated on this interface.  The progress\n                   and success of the open is given by the values of\n                   the dot12Status object.  Setting this object to\n                   'open' when dot12Status has a value other than\n                   'closed' has no effect.\n\n                   Setting the corresponding instance of ifAdminStatus\n                   to 'up' when the current value of dot12Status is\n                   'closed' will have the same effect as setting this\n                   object to 'open'.  Setting ifAdminStatus to 'up'\n                   when dot12Status has a value other than 'closed'\n                   has no effect.\n\n                   Setting the value of this object to 'close' will\n                   move this interface into the 'closed' state and\n                   cause all transmit and receive actions to stop.\n                   This object will then have to be set to 'open' in\n                   order to reinitiate training.\n\n                   Setting the corresponding instance of ifAdminStatus\n                   to 'down' will have the same effect as setting this\n                   object to 'close'.\n\n                   Setting the value of this object to 'reset' when\n                   the current value of dot12Status has a value other\n                   than 'closed' will reset the interface.  On a\n                   reset, all MIB counters should retain their values.\n                   This will cause the MAC to initiate an\n                   acInitializeMAC action as specified in IEEE 802.12.\n                   This will cause training to be reinitiated on this\n                   interface.  Setting this object to 'reset' when\n                   dot12Status has a value of 'closed' has no effect.\n                   Setting this object to 'reset' has no effect on the\n                   corresponding instance of ifAdminStatus.\n\n                   Setting the value of this object to 'noOp' has no\n                   effect.\n\n                   When read, this object will always have a value\n                   of 'noOp'.")
dot12Status = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5, 6,))).clone(namedValues=NamedValues(("opened", 1), ("closed", 2), ("opening", 3), ("openFailure", 5), ("linkFailure", 6),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12Status.setDescription("The current interface status with respect to\n                   training.  One of the following values:\n\n                       opened      - Training has completed \n                                     successfully.\n                       closed      - MAC has been disabled by\n                                     setting dot12Commands to\n                                     'close'.\n                       opening     - MAC is in training.  Training\n                                     signals have been received.\n                       openFailure - Passed 24 error-free packets,\n                                     but there is a problem, noted\n                                     in the training configuration\n                                     bits (dot12LastTrainingConfig).\n                       linkFailure - Training signals not received,\n                                     or could not pass 24 error-free\n                                     packets.\n\n                   Whenever the dot12Commands object is set to\n                   'close' or ifAdminStatus is set to 'down', the MAC\n                   will go silent, dot12Status will be 'closed', and\n                   ifOperStatus will be 'down'.\n\n                   When the value of this object is equal to 'closed'\n                   and the dot12Commands object is set to 'open' or\n                   the ifAdminStatus object is set to 'up', training\n                   will be initiated on this interface.  When the\n                   value of this object is not equal to 'closed' and\n                   the dot12Commands object is set to 'reset',\n                   training will be reinitiated on this interface.\n                   Note that sets of some other objects (e.g.\n                   dot12ControlMode) or external events (e.g. MAC\n                   protocol violations) may also cause training to be\n                   reinitiated on this interface.\n\n                   When training is initiated or reinitiated on an\n                   interface, the end node will send Training_Up to\n                   the master and initially go to the 'linkFailure'\n                   state and ifOperStatus will go to 'down'.\n                   When the master sends back Training_Down,\n                   dot12Status will change to the 'opening' state,\n                   and training packets will be transferred.\n\n                   After all of the training packets have been\n                   passed, dot12Status will change to 'linkFailure'\n                   if 24 consecutive error-free packets were not\n                   passed, 'opened' if 24 consecutive error-free\n                   packets were passed and the training\n                   configuration bits were OK, or 'openFailure' if\n                   there were 24 consecutive error-free packets, but\n                   there was a problem with the training\n                   configuration bits.\n\n                   When in the 'openFailure' state, the\n                   dot12LastTrainingConfig object will contain the\n                   configuration bits from the last training\n                   packet which can be examined to determine the\n                   exact reason for the training configuration\n                   failure.\n\n                   If training did not succeed (dot12Status is\n                   'linkFailure' or 'openFailure), the entire\n                   process will be restarted after\n                   MAC_Retraining_Delay_Timer seconds.\n\n                   If training does succeed (dot12Status changes to\n                   'opened'), ifOperStatus will change to 'up'.  If\n                   training does not succeed (dot12Status changes to\n                   'linkFailure' or 'openFailure'), ifOperStatus will\n                   remain 'down'.")
dot12CurrentFramingType = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("frameType88023", 1), ("frameType88025", 2), ("frameTypeUnknown", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12CurrentFramingType.setDescription("When dot12DesiredFramingType is one of\n                   'frameType88023' or 'frameType88025', this is the\n                   type of framing asserted by the interface.\n\n                   When dot12DesiredFramingType is 'frameTypeEither',\n                   dot12CurrentFramingType shall be one of\n                   'frameType88023' or 'frameType88025' when the\n                   dot12Status is 'opened'.   When the dot12Status is\n                   anything other than 'opened',\n                   dot12CurrentFramingType shall take the value of\n                   'frameTypeUnknown'.")
dot12ControlMode = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("masterMode", 1), ("slaveMode", 2), ("learn", 3),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot12ControlMode.setDescription("This object is used to configure and report\n                   whether or not this interface is operating in\n                   master mode.  In a Demand Priority network, end\n                   node interfaces typically operate in slave mode,\n                   while switch interfaces may control the Demand\n                   Priority protocol and operate in master mode.\n\n                   This object may be implemented as a read-only\n                   object by those agents and interfaces that do not\n                   implement software control of master mode.  In\n                   particular, interfaces that cannot operate in\n                   master mode, and interfaces on which master mode\n                   is controlled by a pushbutton on the device,\n                   should implement this object read-only.\n\n                   Some interfaces do not require network management\n                   configuration of this feature and can autosense\n                   whether to use master mode or slave mode.  The\n                   value 'learn' is used for that purpose.  While\n                   autosense is taking place, the value 'learn' is\n                   returned.\n\n                   A network management operation which modifies the\n                   value of dot12ControlMode causes the interface\n                   to retrain.")
dot12StatTable = MibTable((1, 3, 6, 1, 3, 63, 1, 2), )
if mibBuilder.loadTexts: dot12StatTable.setDescription('Statistics for a collection of 802.12 interfaces\n                   attached to a particular system.')
dot12StatEntry = MibTableRow((1, 3, 6, 1, 3, 63, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dot12StatEntry.setDescription('Statistics for a particular interface to an\n                   802.12 medium.  The receive statistics in this\n                   table apply only to packets received by this\n                   station (i.e., packets whose destination address\n                   is either the local station address, the\n                   broadcast address, or a multicast address that\n                   this station is receiving, unless the station is\n                   in promiscuous mode).')
dot12InHighPriorityFrames = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InHighPriorityFrames.setDescription('This object is a count of high priority frames\n                   that have been received on this interface.\n                   Includes both good and bad high priority frames,\n                   as well as high priority training frames.  Does\n                   not include normal priority frames which were\n                   priority promoted.')
dot12InHighPriorityOctets = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InHighPriorityOctets.setDescription('This object is a count of the number of octets\n                   contained in high priority frames that have been\n                   received on this interface. This counter is\n                   incremented by OctetCount for each frame received\n                   on this interface which is counted by \n                   dot12InHighPriorityFrames.\n\n                   Note that this counter will roll over very\n                   quickly.  It is provided for backward\n                   compatibility for Network Management protocols\n                   that do not support 64 bit counters (e.g. SNMP\n                   version 1).')
dot12InNormPriorityFrames = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InNormPriorityFrames.setDescription('This object is a count of normal priority frames\n                   that have been received on this interface.\n                   Includes both good and bad normal priority\n                   frames, as well as normal priority training\n                   frames and normal priority frames which were\n                   priority promoted.')
dot12InNormPriorityOctets = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InNormPriorityOctets.setDescription('This object is a count of the number of octets\n                   contained in normal priority frames that have\n                   been received on this interface. This counter is\n                   incremented by OctetCount for each frame received\n                   on this interface which is counted by \n                   dot12InNormPriorityFrames.\n\n                   Note that this counter will roll over very\n                   quickly.  It is provided for backward\n                   compatibility for Network Management protocols\n                   that do not support 64 bit counters (e.g. SNMP\n                   version 1).')
dot12InIPMErrors = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InIPMErrors.setDescription('This object is a count of the number of frames\n                   that have been received on this interface with an\n                   invalid packet marker and no PMI errors.  A\n                   repeater will write an invalid packet marker to\n                   the end of a frame containing errors as it is\n                   forwarded through the repeater to the other\n                   ports.  This counter is incremented by one for\n                   each frame received on this interface which has\n                   had an invalid packet marker added to the end of\n                   the frame.')
dot12InOversizeFrameErrors = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InOversizeFrameErrors.setDescription('This object is a count of oversize frames\n                   received on this interface.  This counter is\n                   incremented by one for each frame received on\n                   this interface whose OctetCount is larger than\n                   the maximum legal frame size.  The frame size\n                   which causes this counter to increment is\n                   dependent on the current framing type.')
dot12InDataErrors = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InDataErrors.setDescription('This object is a count of errored frames\n                   received on this interface.  This counter is\n                   incremented by one for each frame received on\n                   this interface with any of the following errors:\n                   bad FCS (with no IPM), PMI errors (excluding\n                   frames with an IPM as the only PMI error),\n                   undersize, bad start of frame delimiter, or bad\n                   end of packet marker.  Does not include frames\n                   counted by dot12InIPMErrors,\n                   dot12InNullAddressedFrames, or\n                   dot12InOversizeFrameErrors.\n\n                   This counter indicates problems with the cable\n                   directly attached to this interface, while\n                   dot12InIPMErrors indicates problems with remote\n                   cables.')
dot12InNullAddressedFrames = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12InNullAddressedFrames.setDescription('This object is a count of null addressed frames\n                   received on this interface.  This counter is\n                   incremented by one for each frame received on\n                   this interface with a destination MAC address\n                   consisting of all zero bits.  Both void and\n                   training frames are included in this counter.\n                   \n                   Note that since this station would normally not\n                   receive null addressed frames, this counter is\n                   only incremented when this station is operating\n                   in promiscuous mode or in training.')
dot12OutHighPriorityFrames = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12OutHighPriorityFrames.setDescription('This counter is incremented by one for each high\n                   priority frame successfully transmitted out this\n                   interface.')
dot12OutHighPriorityOctets = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12OutHighPriorityOctets.setDescription('This counter is incremented by OctetCount for\n                   each frame counted by dot12OutHighPriorityFrames.\n\n                   Note that this counter will roll over very\n                   quickly.  It is provided for backward\n                   compatibility for Network Management protocols\n                   that do not support 64 bit counters (e.g. SNMP\n                   version 1).')
dot12TransitionIntoTrainings = MibTableColumn((1, 3, 6, 1, 3, 63, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot12TransitionIntoTrainings.setDescription("This object is a count of the number of times\n                   this interface has entered the training state.\n                   This counter is incremented by one each time\n                   dot12Status transitions to 'linkFailure' from any\n                   state other than 'opening' or 'openFailure'.")
dot12Conformance = MibIdentifier((1, 3, 6, 1, 3, 63, 2))
dot12Compliances = MibIdentifier((1, 3, 6, 1, 3, 63, 2, 1))
dot12Groups = MibIdentifier((1, 3, 6, 1, 3, 63, 2, 2))
dot12Compliance = MibIdentifier((1, 3, 6, 1, 3, 63, 2, 1, 1))
dot12ConfigGroup = MibIdentifier((1, 3, 6, 1, 3, 63, 2, 2, 1))
dot12StatsGroup = MibIdentifier((1, 3, 6, 1, 3, 63, 2, 2, 2))
mibBuilder.exportSymbols("DOT12-IF-MIB", dot12InOversizeFrameErrors=dot12InOversizeFrameErrors, dot12InIPMErrors=dot12InIPMErrors, dot12Conformance=dot12Conformance, dot12FramingCapability=dot12FramingCapability, dot12ControlMode=dot12ControlMode, dot12DesiredFramingType=dot12DesiredFramingType, dot12StatTable=dot12StatTable, dot12Commands=dot12Commands, dot12StatEntry=dot12StatEntry, dot12LastTrainingConfig=dot12LastTrainingConfig, dot12Status=dot12Status, dot12InHighPriorityOctets=dot12InHighPriorityOctets, dot12InDataErrors=dot12InDataErrors, dot12InNullAddressedFrames=dot12InNullAddressedFrames, dot12Compliances=dot12Compliances, dot12Compliance=dot12Compliance, dot12OutHighPriorityFrames=dot12OutHighPriorityFrames, dot12InNormPriorityOctets=dot12InNormPriorityOctets, dot12CurrentFramingType=dot12CurrentFramingType, dot12MIBObjects=dot12MIBObjects, dot12TrainingVersion=dot12TrainingVersion, dot12Groups=dot12Groups, dot12ConfigEntry=dot12ConfigEntry, dot12TransitionIntoTrainings=dot12TransitionIntoTrainings, dot12InHighPriorityFrames=dot12InHighPriorityFrames, dot12ConfigGroup=dot12ConfigGroup, dot12StatsGroup=dot12StatsGroup, dot12InNormPriorityFrames=dot12InNormPriorityFrames, dot12DesiredPromiscStatus=dot12DesiredPromiscStatus, dot12OutHighPriorityOctets=dot12OutHighPriorityOctets, dot12ConfigTable=dot12ConfigTable, dot12MIB=dot12MIB)
