#
# PySNMP MIB module IPATM-IPMC-MIB (http://pysnmp.sf.net)
# ASN.1 source http://mibs.snmplabs.com:80/asn1/IPATM-IPMC-MIB
# Produced by pysmi-0.0.7 at Sun Feb 14 00:17:37 2016
# On host bldfarm platform Linux version 4.1.13-100.fc21.x86_64 by user goose
# Using Python version 3.5.0 (default, Jan  5 2016, 17:11:52) 
#
( OctetString, Integer, ObjectIdentifier, ) = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion")
( AtmAddr, ) = mibBuilder.importSymbols("ATM-TC-MIB", "AtmAddr")
( InterfaceIndex, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
( ipAdEntAddr, ) = mibBuilder.importSymbols("IP-MIB", "ipAdEntAddr")
( NotificationGroup, ObjectGroup, ModuleCompliance, ) = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
( MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, snmpModules, ModuleIdentity, TimeTicks, NotificationType, Counter64, Integer32, Unsigned32, ObjectIdentity, Gauge32, iso, MibIdentifier, Bits, mib_2, Counter32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "snmpModules", "ModuleIdentity", "TimeTicks", "NotificationType", "Counter64", "Integer32", "Unsigned32", "ObjectIdentity", "Gauge32", "iso", "MibIdentifier", "Bits", "mib-2", "Counter32")
( DisplayString, TextualConvention, TruthValue, RowStatus, ) = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "TruthValue", "RowStatus")
marsMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 57)).setRevisions(("1998-09-01 00:00", "1998-04-15 01:45",))
if mibBuilder.loadTexts: marsMIB.setLastUpdated('9809010000Z')
if mibBuilder.loadTexts: marsMIB.setOrganization('Internetworking Over NBMA (ion) Working Group')
if mibBuilder.loadTexts: marsMIB.setContactInfo('        Chris Chung (chihschung@aol.com)\n                       Independent Consultant\n\n               Editor: Maria Greene\n               Postal: Independent Contractor\n               E-mail: maria@xedia.com\n              ')
if mibBuilder.loadTexts: marsMIB.setDescription('This module defines a portion of the managed information\n               base (MIB) for managing classical IP multicast address\n               resolution server (MARS) and related entities as\n               described in the RFC2022.  This MIB is meant to be\n               used in conjunction with the ATM-MIB (RFC1695),\n               MIB-II (RFC1213), and optionally the IF-MIB (RFC1573).\n              ')
marsClientObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 1))
marsClientTable = MibTable((1, 3, 6, 1, 2, 1, 57, 1, 1), )
if mibBuilder.loadTexts: marsClientTable.setDescription('The objects defined in this table are used for\n            the management of MARS clients, ATM attached\n            endpoints.')
marsClientEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 1, 1, 1), ).setIndexNames((0, "IP-MIB", "ipAdEntAddr"), (0, "IPATM-IPMC-MIB", "marsClientIndex"))
if mibBuilder.loadTexts: marsClientEntry.setDescription('Each entry contains a MARS client and its associated\n            attributes.  An entry in the marsClientTable has\n            a corresponding entry in the ipAddrTable defined in\n            RFC1213. Association between the ipAddrTable and\n            the marsClientTable is made through the index,\n            ipAdEntAddr.')
marsClientIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535)))
if mibBuilder.loadTexts: marsClientIndex.setDescription('The auxiliary variable used to identify instances of\n            the columnar objects in the MARS MarsClientTable.')
marsClientAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 2), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientAddr.setDescription('The ATM address associated with the ATM Client.')
marsClientDefaultMarsAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 3), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientDefaultMarsAddr.setDescription('The default MARS ATM address which is needed to\n               setup the initial signalling path between a MARS\n               client and its associated MARS.')
marsClientHsn = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientHsn.setDescription('The cluster membership own 32 bit Host Sequence\n               Number.  When a new cluster member starts up, it is\n               initialized to zero.  When the cluster member sends\n               the MARS_JOIN to register, the HSN will be correctly\n               set to the current cluster sequence number (CSN) when\n               the Client receives the copy of its MARS_JOIN from\n               the MARS.  It is is used to track the MARS sequence\n               number.')
marsClientRegistration = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("notRegistered", 1), ("registering", 2), ("registered", 3), ("reRegisteringFault", 4), ("reRegisteringRedirMap", 5),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientRegistration.setDescription("An indication with regards to the registration\n            status of this client. The registration codes\n            of 'notRegistered (1)', 'registered (2)', and\n            registered (3) are self-explanatory. The\n            'reRegisteringFault (4)' indicates the client is\n            in the process of re-registering with a MARS due\n            to some fault conditions.  The 'reRegisteringRedMap\n            (5)' status code shows that client is re-registering\n            because it has received a MARS_REDIRECT_MAP message\n            and was told to register with a different MARS from\n            the current MARS.")
marsClientCmi = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientCmi.setDescription("16 bit Cluster member identifier (CMI) assigned by the\n            MARS which uniquely identifies each endpoint attached\n            to the cluster.  The value becomes valid after the\n            'marsClientRegistration' is set to the value\n            of 'registered (1)'.")
marsClientDefaultMtu = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535)).clone(9180)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientDefaultMtu.setDescription('The default maximum transmission unit (MTU) used for\n            this cluster.  Note that the actual size used for a\n            VC between two members of the cluster may be negotiated\n            during connection setup and may be different than this\n            value.  Default value = 9180 bytes.')
marsClientFailureTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientFailureTimer.setDescription('A timer used to flag the failure of last MARS_MULTI\n            to arrive.  Default value = 10 seconds (recommended).')
marsClientRetranDelayTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5,10))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientRetranDelayTimer.setDescription('The delay timer for sending out new MARS_REQUEST\n            for the group after the client learned that there\n            is no other group in the cluster.  The timer must\n            be set between 5 and 10 seconds inclusive.')
marsClientRdmMulReqAddRetrTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5,10))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientRdmMulReqAddRetrTimer.setDescription('The initial random L_MULTI_RQ/ADD retransmit timer\n            which can be set between 5 and 10 seconds inclusive.')
marsClientRdmVcRevalidateTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,10))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientRdmVcRevalidateTimer.setDescription('The random time to set VC_revalidate flag.  The\n            timer value ranges between 1 and 10 seconds\n            inclusive.')
marsClientJoinLeaveRetrInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5,2147483647)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientJoinLeaveRetrInterval.setDescription('MARS_JOIN/LEAVE retransmit interval. The minimum\n            and recommended values are 5 and 10 seconds,\n            respectively.')
marsClientJoinLeaveRetrLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,5))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientJoinLeaveRetrLimit.setDescription('MARS_JOIN/LEAVE retransmit limit. The maximum\n            value is 5.')
marsClientRegWithMarsRdmTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,10))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientRegWithMarsRdmTimer.setDescription('Random time to register with MARS.')
marsClientForceWaitTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientForceWaitTimer.setDescription('Force wait if MARS re-registration is looping.\n            The minimum value is 1 minute.')
marsClientLmtToMissRedirMapTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,4))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientLmtToMissRedirMapTimer.setDescription('Timer limit for client to miss MARS_REDIRECT_MAPS.')
marsClientIdleTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647)).clone(20)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientIdleTimer.setDescription('The configurable inactivity timer associated with a\n            client. When a VC is created at this client, it gets\n            the idle timer value from this configurable timer.\n            The minimum suggested value is 1 minute and the\n            recommended default value is 20 minutes.')
marsClientRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 18), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientRowStatus.setDescription("The object is used to create, delete or modify a\n            row in this table.\n\n            A row cannot be made 'active' until instances of\n            all corresponding columns in the row of this table\n            are appropriately configured and until the agent\n            has also created a corresponding row in the\n            marsClientStatTable.\n\n            When this object has a value of 'active', the\n            following columnar objects can not be modified:\n\n              marsClientDefaultMarsAddr,\n              marsClientHsn,\n              marsClientRegstration,\n              marsClientCmi,\n              marsClientDefaultMtu\n\n            while other objects in this conceptual row can be\n            modified irrespective of the value of this object.\n\n            Deletion of this row is allowed regardless of\n            whether or not a row in any associated tables\n            (i.e., marsClientVcTable) still exists or is in\n            use. Once this row is deleted, it is recommended\n            that the agent or the SNMP management station\n            (if possible) through the set command deletes\n            any stale rows that are associated with this\n            row.")
marsClientMcGrpTable = MibTable((1, 3, 6, 1, 2, 1, 57, 1, 2), )
if mibBuilder.loadTexts: marsClientMcGrpTable.setDescription('This table contains a list of IP multicast group address\n            blocks associated with a MARS client.  Entries in this\n            table are used by the client that needs to receive or\n            transmit packets from/to the specified range of\n            multicast addresses.\n            Each row can be created or deleted via configuration.')
marsClientMcGrpEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 1, 2, 1), ).setIndexNames((0, "IP-MIB", "ipAdEntAddr"), (0, "IPATM-IPMC-MIB", "marsClientIndex"), (0, "IPATM-IPMC-MIB", "marsClientMcMinGrpAddr"), (0, "IPATM-IPMC-MIB", "marsClientMcMaxGrpAddr"))
if mibBuilder.loadTexts: marsClientMcGrpEntry.setDescription('Each entry represents a consecutive block of multicast\n            group addresses.')
marsClientMcMinGrpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 2, 1, 1), IpAddress())
if mibBuilder.loadTexts: marsClientMcMinGrpAddr.setDescription('Minimum multicast group address - the min and max\n            multicast forms multi-group block.  If the MinGrpAddr\n            and MaxGrpAddr are the same, it indicates that this\n            block contains a single group address.')
marsClientMcMaxGrpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 2, 1, 2), IpAddress())
if mibBuilder.loadTexts: marsClientMcMaxGrpAddr.setDescription('Maximum multicast group address - the min and max\n            multicast forms a multi-group block.  If the MinGrpAddr\n            and MaxGrpAddr are the same, it indicates that this\n            block contains a single group address.')
marsClientMcGrpRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 2, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientMcGrpRowStatus.setDescription("The object is used to create or delete a row in this\n            table.\n\n            Since other objects in this row are not-accessible\n            'index-objects', the value of this object has no\n            effect on whether those objects in this conceptual\n            row can be modified.")
marsClientBackupMarsTable = MibTable((1, 3, 6, 1, 2, 1, 57, 1, 3), )
if mibBuilder.loadTexts: marsClientBackupMarsTable.setDescription('This table contains a list of backup MARS addresses that\n            a client can connect to in case of failure for connecting\n            to the primary server. The list of addresses is in\n            descending order of preference. It should be noted that\n            the backup list provided by the MARS to the client via\n            the MARS_REDIRECT_MAP message has a higher preference than\n            addresses that are manually configured into the client.\n            When such a list is received from the MARS, this information\n            should be inserted at the top of the list.\n            Each row can be created or deleted via configuration.')
marsClientBackupMarsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 1, 3, 1), ).setIndexNames((0, "IP-MIB", "ipAdEntAddr"), (0, "IPATM-IPMC-MIB", "marsClientIndex"), (0, "IPATM-IPMC-MIB", "marsClientBackupMarsPriority"), (0, "IPATM-IPMC-MIB", "marsClientBackupMarsAddr"))
if mibBuilder.loadTexts: marsClientBackupMarsEntry.setDescription('Each entry represents an ATM address of a backup MARS.')
marsClientBackupMarsPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0,65535)))
if mibBuilder.loadTexts: marsClientBackupMarsPriority.setDescription('The priority associated with a backup MARS. A lower\n            priority value inidcates a higher preference.')
marsClientBackupMarsAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 3, 1, 2), AtmAddr())
if mibBuilder.loadTexts: marsClientBackupMarsAddr.setDescription('The ATM address associated with a backup MARS.')
marsClientBackupMarsRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 3, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientBackupMarsRowStatus.setDescription("The object is used to create or delete a row in this\n            table.\n\n            Since other objects in this row are not-accessible\n            'index-objects', the value of this object has no effect\n            on whether those objects in this conceptual row can be\n            modified.")
marsClientVcTable = MibTable((1, 3, 6, 1, 2, 1, 57, 1, 4), )
if mibBuilder.loadTexts: marsClientVcTable.setDescription('This table contains information about open virtual\n            circuits (VCs) that a client has.  For point to point\n            circuit, each entry represents a single VC connection\n            between this client ATM address to another party ATM\n            address.  In the case of point to multipoint connection\n            where a single source address is associated with\n            multiple destinations, several entries are used to\n            represent the relationship.  An example of point to\n            multi-point VC represented in a table is shown below.\n\n                   Client    VPI/VCI    Grp Addr1/Addr2    Part Addr\n                     1         0,1          g1,g2             p1\n                     1         0,1          g1,g2             p2\n                     1         0,1          g1,g2             p3\n\n            Note:  This table assumes the IP multicast address\n                   groups (min, max) defined in each entry are\n                   always consecutive.  In the case of that a\n                   client receives a JOIN/LEAVE with\n                   mars$flag.punched set, each pair of the IP\n                   groups will first be broken into several\n                   pairs of consecutive IP groups before each\n                   entry row corresponding to a pair of IP group\n                   is created.')
marsClientVcEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 1, 4, 1), ).setIndexNames((0, "IP-MIB", "ipAdEntAddr"), (0, "IPATM-IPMC-MIB", "marsClientIndex"), (0, "IPATM-IPMC-MIB", "marsClientVcVpi"), (0, "IPATM-IPMC-MIB", "marsClientVcVci"), (0, "IPATM-IPMC-MIB", "marsClientVcMinGrpAddr"), (0, "IPATM-IPMC-MIB", "marsClientVcMaxGrpAddr"), (0, "IPATM-IPMC-MIB", "marsClientVcPartyAddr"))
if mibBuilder.loadTexts: marsClientVcEntry.setDescription('The objects contained in the entry are VC related\n            attributes such as VC signalling type, control VC\n            type, idle timer, negotiated MTU size, etc.')
marsClientVcVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,4095)))
if mibBuilder.loadTexts: marsClientVcVpi.setDescription('The value of virtual path identifier (VPI). Since\n            a VPI can be numbered 0, this sub-index can take\n            a value of 0.')
marsClientVcVci = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,65535)))
if mibBuilder.loadTexts: marsClientVcVci.setDescription('The value of virtual circuit identifier (VCI). Since\n            a VCI can be numbered 0, this sub-index can take\n            a value of 0.')
marsClientVcMinGrpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 3), IpAddress())
if mibBuilder.loadTexts: marsClientVcMinGrpAddr.setDescription('Minimum IP multicast group address - the min and\n            max multicast forms a multi-group consecutive\n            block which is associated with a table entry.\n            if the MinGrpAddr and MaxGrpAddr are the same, it\n            indicates that the size of multi-group block is 1,\n            a single IP group.')
marsClientVcMaxGrpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 4), IpAddress())
if mibBuilder.loadTexts: marsClientVcMaxGrpAddr.setDescription('Maximum IP multicast group address - the min and\n            max multicast forms a multi-group consecutive\n            block which is associated with a table entry.\n            if the MinGrpAddr and MaxGrpAddr are the same, it\n            indicates that the size of multi-group block is 1,\n            a single IP group.')
marsClientVcPartyAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 5), AtmAddr())
if mibBuilder.loadTexts: marsClientVcPartyAddr.setDescription('An ATM party address in which this VC is linked.\n            The party type is identified by the\n            marsClientVcPartyAddrType.')
marsClientVcPartyAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("called", 1), ("calling", 2),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientVcPartyAddrType.setDescription("The party type is associated with the party address.\n            The 'called (1)' indicates that the party address is\n            a destination address which implies that VC is\n            originated from this client.  The 'calling (2)'\n            indicates the VC was initiated externally to this\n            client. In this case, the party address is the\n            source address.")
marsClientVcType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("pvc", 1), ("svc", 2),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientVcType.setDescription('Circuit Connection type: permanent virtual circuit or\n            switched virtual circuit.')
marsClientVcCtrlType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("pointToPointVC", 1), ("clusterControlVC", 2), ("pointToMultiPointVC", 3),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientVcCtrlType.setDescription('Control VC type used to specify a particular connection.\n              pointToPointVC (1):\n                used by the ATM Clients for the registration and\n                queries.  This VC or the initial signalling path\n                is set up from the source Client to a MARS. It is\n                bi-directional.\n              clusterControlVC (2):\n                used by a MARS to issue asynchronous updates to an\n                ATM Client.  This VC is established from the MARS\n                to the ATM Client.\n              pointToMultiPointVC (3):\n                used by the client to transfer multicast data\n                packets from layer 3.  This VC is established\n                from the source ATM Client to a destination ATM\n                endpoint which can be a multicast group member\n                or an MCS.  The destination endpoint was obtained\n                from the MARS.')
marsClientVcIdleTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647)).clone(20)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientVcIdleTimer.setDescription('The idle timer associated with this VC.  The minimum\n            suggested value is 1 minute and the recommended\n            default value is 20 minutes.')
marsClientVcRevalidate = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 10), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientVcRevalidate.setDescription('A flag associated with an open and active multipoint\n            VC.  It is checked every time a packet is queued for\n            transmission on that VC. The object has the value of\n            true (1) if revalidate is required and the value\n            false (2) otherwise.')
marsClientVcEncapsType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("other", 1), ("llcSnap", 2),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientVcEncapsType.setDescription('The encapsulation type used when communicating over\n            this VC.')
marsClientVcNegotiatedMtu = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientVcNegotiatedMtu.setDescription('The negotiated MTU when communicating over this VC.')
marsClientVcRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientVcRowStatus.setDescription("The object is used to create, delete or modify a\n            row in this table.\n\n            A row cannot be made 'active' until instances of\n            all corresponding columns in the row of this table\n            are appropriately configured.\n\n            While objects: marsClientVcIdleTimer and\n            marsClientVcRevalidate in this conceptual\n            row can be modified irrespective of the value\n            of this object, all other objects in the row can\n            not be modified when this object has a value\n            of 'active'.\n\n            It is possible for an SNMP management station\n            to set the row to 'notInService' and modify\n            the entry and then set it back to 'active'\n\n            with the following exception. That is, rows\n            for which the corresponding instance of\n            marsClientVcType has a value of 'svc' can not\n            be modified or deleted.")
marsClientStatTable = MibTable((1, 3, 6, 1, 2, 1, 57, 1, 5), )
if mibBuilder.loadTexts: marsClientStatTable.setDescription('The table contains statistics collected at MARS\n            clients.')
marsClientStatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 1, 5, 1), ).setIndexNames((0, "IP-MIB", "ipAdEntAddr"), (0, "IPATM-IPMC-MIB", "marsClientIndex"))
if mibBuilder.loadTexts: marsClientStatEntry.setDescription('Each entry contains statistics collected at one MARS\n            client.')
marsClientStatTxReqMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsClientStatTxReqMsgs.setDescription('Total number of MARS_REQUEST messages transmitted\n            from a client.')
marsClientStatTxJoinMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsClientStatTxJoinMsgs.setDescription('Total number of MARS_JOIN messages transmitted from\n            a client.')
marsClientStatTxLeaveMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsClientStatTxLeaveMsgs.setDescription('Total number of MARS_LEAVE messages transmitted from\n            a client.')
marsClientStatTxGrpLstReqMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsClientStatTxGrpLstReqMsgs.setDescription('Total number of MARS_GROUPLIST_REQUEST messages\n            transmitted from a client.')
marsClientStatRxJoinMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsClientStatRxJoinMsgs.setDescription('Total number of MARS_JOIN messages received by\n            a client.')
marsClientStatRxLeaveMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsClientStatRxLeaveMsgs.setDescription('Total number of MARS_LEAVE messages received by\n            a client.')
marsClientStatRxMultiMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsClientStatRxMultiMsgs.setDescription('Total number of MARS_MULTI messages received by\n            a client.')
marsClientStatRxNakMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsClientStatRxNakMsgs.setDescription('Total number of MARS_NAK messages received by\n            a client.')
marsClientStatRxMigrateMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsClientStatRxMigrateMsgs.setDescription('Total number of MARS_MIGRATE messages received by\n            a client.')
marsClientStatRxGrpLstRplyMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsClientStatRxGrpLstRplyMsgs.setDescription('Total number of MARS_GROUPLIST_REPLY messages\n            received by a client.')
marsClientStatFailMultiMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 5, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsClientStatFailMultiMsgs.setDescription('Total number of timeouts occurred indicating\n            failure of the last MARS_MULTI to arrive.')
marsObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 2))
marsTable = MibTable((1, 3, 6, 1, 2, 1, 57, 2, 1), )
if mibBuilder.loadTexts: marsTable.setDescription('The objects defined in this table are used for the\n            management of MARS servers.')
marsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 2, 1, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsIndex"), (0, "IPATM-IPMC-MIB", "marsIfIndex"))
if mibBuilder.loadTexts: marsEntry.setDescription('Each entry contains a MARS and its associated\n            attributes.')
marsIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535)))
if mibBuilder.loadTexts: marsIndex.setDescription('The auxiliary variable used to identify instances of\n            the columnar objects in the MARS table.')
marsIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 1, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: marsIfIndex.setDescription('The ifIndex of the interface that the MARS is\n            associated with.')
marsAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 1, 1, 3), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsAddr.setDescription('The ATM address associated with the MARS.')
marsLocal = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 1, 1, 4), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsLocal.setDescription('A flag associated with a MARS entry.  The object has\n            the value of true (1) if the MARS whose interface\n            is local to the machine that implements this MIB;\n            otherwise the object has the value of false (2).')
marsServStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2), ("faulted", 3),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsServStatus.setDescription('The current status of MARS.')
marsServType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("primary", 1), ("backup", 2),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsServType.setDescription('Types of MARS servers: primary or backup.')
marsServPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0,65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsServPriority.setDescription('Priority associated with a backup MARS server.\n            A backup MARS server with lower priority value\n            indicates a higher preference than other backup\n            MARS servers to be used as the MARS server when\n            the primary server fails.')
marsRedirMapMsgTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2)).clone(1)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsRedirMapMsgTimer.setDescription('Periodic interval on which a multi-part\n            MARS_REDIRECT_MAP is sent from this MARS.')
marsCsn = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 1, 1, 9), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsCsn.setDescription('Current cluster sequence number (CSN) which is global\n            within the context of a given protocol.  The CSN is\n            incremented by the MARS on every transmission of a\n            message on ClusterControlVC.  A cluster member uses\n            the CSN to track the message loss on ClusterControlVC\n            or to monitor a membership change.')
marsSsn = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 1, 1, 10), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsSsn.setDescription('Current server sequence number (SSN) which is global\n            within the context of a given protocol.  The SSN is\n            incremented by the MARS on every transmission of a\n            message on ServerControlVC.  A MCS uses the SSN to\n            track the message loss on ServerControlVC or to\n            monitor a membership change.')
marsRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 1, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsRowStatus.setDescription("The object is used to create, delete or modify a\n            row in this table.\n\n            A row cannot be made 'active' until instances of\n            all corresponding columns in the row of this table\n            are appropriately configured and until the agent\n            has also created a corresponding row in the\n            marsStatTable.\n\n            When this object has a value of 'active', the\n            following columnar objects can not be modified:\n\n              marsAddr,\n              marsAddrLocal,\n              marsServStatus,\n              marsServType,\n              marsCsn,\n              marsSsn\n\n            while other objects in this conceptual row can be\n            modified irrespective of the value of this object.\n\n            Deletion of this row is allowed regardless of\n            whether or not a row in any associated tables\n            (i.e., marsVcTable) still exists or is in use.\n            Once this row is deleted, it is recommended that\n            the agent or the SNMP management station (if\n            possible) through the set command deletes any\n            stale rows that are associated with this row.")
marsMcGrpTable = MibTable((1, 3, 6, 1, 2, 1, 57, 2, 2), )
if mibBuilder.loadTexts: marsMcGrpTable.setDescription('This table contains a list of IP multicast address\n            blocks associated with a MARS.  Entries in this table\n            are used by the MARS host map table and the server map\n            table.  They should be created prior to being referenced\n            as indices by those tables.\n            Each row can be created or deleted via configuration.')
marsMcGrpEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 2, 2, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsIndex"), (0, "IPATM-IPMC-MIB", "marsIfIndex"), (0, "IPATM-IPMC-MIB", "marsMcMinGrpAddr"), (0, "IPATM-IPMC-MIB", "marsMcMaxGrpAddr"))
if mibBuilder.loadTexts: marsMcGrpEntry.setDescription('Each entry represents a consecutive block of multicast\n            group addresses.')
marsMcMinGrpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 2, 1, 1), IpAddress())
if mibBuilder.loadTexts: marsMcMinGrpAddr.setDescription('Minimum multicast group address - the min and max\n            multicast forms multi-group block.  If the MinGrpAddr\n            and MaxGrpAddr are the same, it indicates that this\n            block contains a single group address.')
marsMcMaxGrpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 2, 1, 2), IpAddress())
if mibBuilder.loadTexts: marsMcMaxGrpAddr.setDescription('Maximum multicast group address - the min and max\n            multicast forms a multi-group block.  If The\n            MinGrpAddr and MaxGrpAddr are the same, it indicates\n            that this block contains a single group address.')
marsMcGrpAddrUsage = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("hostMap", 1), ("serverMap", 2), ("hostServerMap", 3),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcGrpAddrUsage.setDescription('Usage of the multicast address block.  The hostMap (1)\n            indicates that the address block is only used in the\n            MARS host map table. The serverMap (2) indicates\n            that the address block is only used in the MARS\n            server map table.  The hostServerMap (3) indicates\n            that the address block is used in both the host map\n            and the server map tables.')
marsMcGrpRxLayer3GrpSets = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsMcGrpRxLayer3GrpSets.setDescription('Number of MARS_JOIN messages received with\n            mars$flags.layer3grp flag set.')
marsMcGrpRxLayer3GrpResets = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsMcGrpRxLayer3GrpResets.setDescription('Number of MARS_JOIN messages received with\n            mars$flags.layer3grp flag reset.')
marsMcGrpRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcGrpRowStatus.setDescription('The object is used to create, delete or modify a\n            row in this table.\n\n            The value of this object has no effect on whether\n            other objects in this conceptual row can be modified.')
marsHostMapTable = MibTable((1, 3, 6, 1, 2, 1, 57, 2, 3), )
if mibBuilder.loadTexts: marsHostMapTable.setDescription('This table caches mappings between IP multicast\n            address to a list of ATM addresses that are\n            configured or dynamically learned from the MARS.\n            This address resolution is used for the host map.\n            It supports the mapping of a block of multicast\n            group addresses to a cluster member address.  In\n            the case where a group block is associated with\n            multiple cluster members, several entries are\n            used to representing the relationship.')
marsHostMapEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 2, 3, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsIndex"), (0, "IPATM-IPMC-MIB", "marsIfIndex"), (0, "IPATM-IPMC-MIB", "marsMcMinGrpAddr"), (0, "IPATM-IPMC-MIB", "marsMcMaxGrpAddr"), (0, "IPATM-IPMC-MIB", "marsHostMapAtmAddr"))
if mibBuilder.loadTexts: marsHostMapEntry.setDescription('Each entry row contains attributes associated with\n            the mapping between a multicast group block and an\n            ATM address.')
marsHostMapAtmAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 3, 1, 1), AtmAddr())
if mibBuilder.loadTexts: marsHostMapAtmAddr.setDescription('The mapped cluster member ATM address.')
marsHostMapRowType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsHostMapRowType.setDescription('Method in which this entry row is created. The\n            static (1) indicates that this row is created\n            through configuration.  The dynamic (2) indicates\n            that the row is created as the result of group\n            address updates received at this MARS.')
marsHostMapRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 3, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsHostMapRowStatus.setDescription("The object is used to create, delete or modify a\n            row in this table.\n\n            This object must not be set to 'active' until\n            instances of all corresponding columns in the\n            row of this table are appropriately configured.\n\n            It is possible for an SNMP management station\n            to set the row to 'notInService' and modify\n            the entry and then set it back to 'active'\n            with the following exception. That is, rows\n            for which the corresponding instance of\n            marsHostMapRowType has a value of 'dynamic'\n            can not be modified or deleted.")
marsServerMapTable = MibTable((1, 3, 6, 1, 2, 1, 57, 2, 4), )
if mibBuilder.loadTexts: marsServerMapTable.setDescription('This table caches mappings between IP multicast\n            address to a list of MCS ATM addresses that are\n            configured or dynamically learned from the MARS.\n            This address resolution is used for the server map.\n            It supports the mapping of a block of multicast\n            group addresses to a MCS address.  In the case\n            where a group block is associated with multiple\n            MCSs, several entries are used to representing the\n            relationship.')
marsServerMapEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 2, 4, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsIndex"), (0, "IPATM-IPMC-MIB", "marsIfIndex"), (0, "IPATM-IPMC-MIB", "marsMcMinGrpAddr"), (0, "IPATM-IPMC-MIB", "marsMcMaxGrpAddr"), (0, "IPATM-IPMC-MIB", "marsServerMapAtmAddr"))
if mibBuilder.loadTexts: marsServerMapEntry.setDescription('Each entry row contains attributes associated with\n            the mapping between a multicast group block and an\n            MCS address.')
marsServerMapAtmAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 4, 1, 1), AtmAddr())
if mibBuilder.loadTexts: marsServerMapAtmAddr.setDescription('The mapped MCS ATM address.')
marsServerMapRowType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsServerMapRowType.setDescription("Method in which this entry row is created. The\n            'static (1)' indicates that this row is created\n            through configuration.  The 'dynamic (2)' indicates\n            that the row is created as the result of group\n            address updates received at this MARS.")
marsServerMapRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 4, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsServerMapRowStatus.setDescription("The object is used to create, delete or modify a\n            row in this table.\n\n            This object must not be set to 'active' until\n            instances of all corresponding columns in the\n            row of this table are appropriately configured.\n\n            It is possible for an SNMP management station\n            to set the row to 'notInService' and modify\n            the entry and then set it back to 'active'\n            with the following exception. That is, rows\n            for which the corresponding instance of\n            marsServerMapRowType has a value of 'dynamic'\n            can not be modified or deleted.")
marsVcTable = MibTable((1, 3, 6, 1, 2, 1, 57, 2, 5), )
if mibBuilder.loadTexts: marsVcTable.setDescription("This table contains information about open virtual circuits\n            (VCs) that a MARS has.  For point to point circuit, each\n            entry represents a single VC connection between this MARS\n            ATM address to another party's ATM address.  In the case of\n            point to multipoint connection where a ControlVc is attached\n            with multiple leaf nodes, several entries are used  to\n            represent the relationship.  An example of point to\n            multi-point VC represented in a table is shown below.\n\n                 MARS     VPI/VCI    MARS Addr     Party Addr\n                   1         0,1         m1            p1\n                   1         0,1         m1            p2\n                   1         0,1         m1            p3")
marsVcEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 2, 5, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsIndex"), (0, "IPATM-IPMC-MIB", "marsIfIndex"), (0, "IPATM-IPMC-MIB", "marsVcVpi"), (0, "IPATM-IPMC-MIB", "marsVcVci"), (0, "IPATM-IPMC-MIB", "marsVcPartyAddr"))
if mibBuilder.loadTexts: marsVcEntry.setDescription('The objects contained in the entry are VC related attributes\n            such as VC signalling type, control VC type, idle timer,\n            negotiated MTU size, etc.')
marsVcVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,4095)))
if mibBuilder.loadTexts: marsVcVpi.setDescription('The value of virtual path identifier (VPI). Since\n            a VPI can be numbered 0, this sub-index can take\n            a value of 0.')
marsVcVci = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,65535)))
if mibBuilder.loadTexts: marsVcVci.setDescription('The value of virtual circuit identifier (VCI).\n             Since a VCI can be numbered 0, this sub-index\n             can take a value of 0.')
marsVcPartyAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 5, 1, 5), AtmAddr())
if mibBuilder.loadTexts: marsVcPartyAddr.setDescription('An ATM party address in which this VC is linked. The\n            party type is identified by the marsVcPartyAddrType.')
marsVcPartyAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("called", 1), ("calling", 2),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsVcPartyAddrType.setDescription("The party type is associated with the party address.  The\n            'called (1)' indicates that the party address is a\n            destination address which implies that VC is originated\n            from this MARS. The 'calling (2)' indicates the VC was\n            initiated externally to this MARS.  The party address is\n            the source address.")
marsVcType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("pvc", 1), ("svc", 2),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsVcType.setDescription('Circuit Connection type: permanent virtual circuit or\n            switched virtual circuit.')
marsVcCtrlType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("pointToPointVC", 1), ("clusterControlVC", 2), ("serverControlVC", 3),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsVcCtrlType.setDescription('Control VC type used to specify a particular connection.\n              pointToPointVC (1):\n                used by the ATM endpoints (clients) or the MCS for\n                registration and queries.  This VC is set up from\n                a MARS client and MCS to this MARS.  It is a\n                bi-directional VC.\n              clusterControlVC (2):\n                used by MARS to issue asynchronous updates to ATM\n                an ATM client.  This VC is established from the\n                MARs to the ATM client.\n              serverControlVC (3):\n                used by MARS to issue asynchronous update to ATM\n                multicast servers.  This type of VC exists when at\n                least a MCS is being used.')
marsVcIdleTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 5, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647)).clone(20)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsVcIdleTimer.setDescription('The idle timer associated with this VC.  The minimum\n            suggested value is 1 minute and the recommended default\n            value is 20 minutes.')
marsVcCmi = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 5, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsVcCmi.setDescription("Cluster member identifier (CMI) which uniquely identifies\n            each endpoint attached to the cluster.  This variable\n            applies to each 'leaf node' of an outgoing control VC.")
marsVcEncapsType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("other", 1), ("llcSnap", 2),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsVcEncapsType.setDescription('The encapsulation type used when communicating over\n            this VC.')
marsVcNegotiatedMtu = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 5, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsVcNegotiatedMtu.setDescription('The negotiated MTU when communicating over this VC.')
marsVcRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 5, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsVcRowStatus.setDescription("The object is used to create, delete or modify a\n            row in this table.\n\n            A row cannot be made 'active' until instances of\n            all corresponding columns in the row of this table\n            are appropriately configured.\n\n            While the marsVcIdleTimer in this conceptual\n            row can be modified irrespective of the value\n            of this object, all other objects in the row can\n            not be modified when this object has a value\n            of 'active'.\n\n            It is possible for an SNMP management station\n            to set the row to 'notInService' and modify\n            the entry and then set it back to 'active'\n            with the following exception. That is, rows\n            for which the corresponding instance of\n            marsVcType has a value of 'svc' can not be\n            modified or deleted.")
marsRegClientTable = MibTable((1, 3, 6, 1, 2, 1, 57, 2, 6), )
if mibBuilder.loadTexts: marsRegClientTable.setDescription('This table contains ATM identities of all the currently\n            registered cluster members at a MARS.  Each entry represents\n            one set of ATM identities associated with one cluster member\n            or the MARS client.')
marsRegClientEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 2, 6, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsIndex"), (0, "IPATM-IPMC-MIB", "marsIfIndex"), (0, "IPATM-IPMC-MIB", "marsRegClientCmi"))
if mibBuilder.loadTexts: marsRegClientEntry.setDescription('Each entry row contains attributes associated with one\n            register cluster member.')
marsRegClientCmi = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,65535)))
if mibBuilder.loadTexts: marsRegClientCmi.setDescription('This cluster member identifier is used as an auxiliary index\n            for the entry in this table.')
marsRegClientAtmAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 6, 1, 2), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsRegClientAtmAddr.setDescription("The registered client's ATM address.")
marsRegMcsTable = MibTable((1, 3, 6, 1, 2, 1, 57, 2, 7), )
if mibBuilder.loadTexts: marsRegMcsTable.setDescription('This table contains ATM identities of all the currently\n            registered MCSs at a MARS. Each entry represents one set\n            of ATM identities associated with one MCS.')
marsRegMcsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 2, 7, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsIndex"), (0, "IPATM-IPMC-MIB", "marsIfIndex"), (0, "IPATM-IPMC-MIB", "marsRegMcsAtmAddr"))
if mibBuilder.loadTexts: marsRegMcsEntry.setDescription('Each entry row contains attributes associated with one\n            registered MCS.')
marsRegMcsAtmAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 7, 1, 1), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsRegMcsAtmAddr.setDescription("The registered MCS's ATM address.")
marsStatTable = MibTable((1, 3, 6, 1, 2, 1, 57, 2, 8), )
if mibBuilder.loadTexts: marsStatTable.setDescription('The table contains statistics collected at MARS.')
marsStatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 2, 8, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsIndex"), (0, "IPATM-IPMC-MIB", "marsIfIndex"))
if mibBuilder.loadTexts: marsStatEntry.setDescription('Each entry contains statistics collected at one MARS.')
marsStatTxMultiMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatTxMultiMsgs.setDescription('Total number of MARS_MULTI transmitted by this MARS.')
marsStatTxGrpLstRplyMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatTxGrpLstRplyMsgs.setDescription('Total number of MARS_GROUPLIST_REPLY messages transmitted\n            by this MARS.')
marsStatTxRedirectMapMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatTxRedirectMapMsgs.setDescription('Total number of MARS_REDIRECT_MAP messages transmitted by\n            this MARS.')
marsStatTxMigrateMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatTxMigrateMsgs.setDescription('Total number of MARS_MIGRATE messages transmitted by\n            this MARS.')
marsStatTxNakMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatTxNakMsgs.setDescription('Total number of MARS_NAK messages transmitted by this MARS.')
marsStatTxJoinMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatTxJoinMsgs.setDescription('Total number of MARS_JOIN messages transmitted by this\n            MARS.')
marsStatTxLeaveMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatTxLeaveMsgs.setDescription('Total number of MARS_LEAVE messages transmitted by this\n            MARS.')
marsStatTxSjoinMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatTxSjoinMsgs.setDescription('Total number of MARS_SJOIN messages transmitted by this\n            MARS.')
marsStatTxSleaveMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatTxSleaveMsgs.setDescription('Total number of MARS_SLEAVE messages transmitted by this\n            MARS.')
marsStatTxMservMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatTxMservMsgs.setDescription('Total number of MARS_MSERV messages transmitted by this\n            MARS.')
marsStatTxUnservMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatTxUnservMsgs.setDescription('Total number of MARS_UNSERV messages transmitted by this\n            MARS.')
marsStatRxReqMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatRxReqMsgs.setDescription('Total number of MARS_REQUEST messages received by this\n            MARS.')
marsStatRxGrpLstReqMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatRxGrpLstReqMsgs.setDescription('Total number of MARS_GROUPLIST_REQUEST messages received\n            by this MARS.')
marsStatRxJoinMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatRxJoinMsgs.setDescription('Total number of MARS_JOINS messages received by this MARS.')
marsStatRxLeaveMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatRxLeaveMsgs.setDescription('Total number of MARS_LEAVES messages received by this MARS.')
marsStatRxMservMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatRxMservMsgs.setDescription('Total number of MARS_MSERV messages received by this MARS.')
marsStatRxUnservMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatRxUnservMsgs.setDescription('Total number of MARS_UNSERV messages received by this MARS.')
marsStatRxBlkJoinMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatRxBlkJoinMsgs.setDescription('Total number of block joins messages received by this MARS.')
marsStatRegMemGroups = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatRegMemGroups.setDescription('Total number of IP multicast groups with 1 or more joined\n            cluster members.')
marsStatRegMcsGroups = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatRegMcsGroups.setDescription('Total number of IP multicast groups with 1 or more joined\n            MCSs.')
marsMcsObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 3))
marsMcsTable = MibTable((1, 3, 6, 1, 2, 1, 57, 3, 1), )
if mibBuilder.loadTexts: marsMcsTable.setDescription('The objects defined in this table are used for\n            the management of a multicast server (MCS).')
marsMcsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 3, 1, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsMcsIndex"), (0, "IPATM-IPMC-MIB", "marsMcsIfIndex"))
if mibBuilder.loadTexts: marsMcsEntry.setDescription('Each entry contains a MCS and its associated\n            attributes.')
marsMcsIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535)))
if mibBuilder.loadTexts: marsMcsIndex.setDescription('The auxiliary variable used to identify instances\n            of the columnar objects in the MCS table.')
marsMcsIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: marsMcsIfIndex.setDescription('The ifIndex of the interface that the MCS is\n            associated with.')
marsMcsAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 3), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsAddr.setDescription('The ATM address associated with the MCS.')
marsMcsDefaultMarsAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 4), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsDefaultMarsAddr.setDescription('The default MARS ATM address which is needed to\n            setup the initial signalling path between a MCS\n            and its associated MARS.')
marsMcsRegistration = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("notRegistered", 1), ("registering", 2), ("registered", 3), ("reRegisteringFault", 4), ("reRegisteringRedirMap", 5),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsRegistration.setDescription("An indication with regards to the registration\n            STATUS of this MCS. The registration codes of\n            'notRegistered (1)', 'registered (2)', and\n            registered (3) are self-explanatory. The\n            'reRegisteringFault (4)' indicates the MCS is\n            in the process of re-registering with a MARS due\n            to some fault conditions.  The 'reRegisteringRedMap\n            (5)' status code shows that MCS is re-registering\n            because it has received a MARS_REDIRECT_MAP message\n            and was told to register with a shift MARS.")
marsMcsSsn = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsSsn.setDescription('The MCS own 32 bit Server Sequence Number.  It\n            is used to track the Mars sequence number.')
marsMcsDefaultMtu = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535)).clone(9180)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsDefaultMtu.setDescription('The default maximum transmission unit (MTU) used\n            for this cluster.  Note that the actual size used\n            for a VC between two members of the cluster may be\n            negotiated during connection setup and may be\n            different than this value.\n            Default value = 9180 bytes.')
marsMcsFailureTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsFailureTimer.setDescription('A timer used to flag the failure of last MARS_MULTI\n            to arrive.  Default value = 10 seconds (recommended).')
marsMcsRetranDelayTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5,10))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsRetranDelayTimer.setDescription('The delay timer for sending out new MARS_REQUEST\n            for the group after the MCS learned that there\n            is no other group in the cluster.  The timer must\n            be set between 5 and 10 seconds inclusive.')
marsMcsRdmMulReqAddRetrTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5,10))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsRdmMulReqAddRetrTimer.setDescription('The initial random L_MULTI_RQ/ADD retransmit timer\n            which can be set between 5 and 10 seconds inclusive.')
marsMcsRdmVcRevalidateTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,10))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsRdmVcRevalidateTimer.setDescription('The random time to set VC_revalidate flag.  The\n            timer value ranges between 1 and 10 seconds\n               inclusive.')
marsMcsRegisterRetrInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5,2147483647)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsRegisterRetrInterval.setDescription('MARS_MSERV/UNSERV retransmit interval. The minimum\n            and recommended values are 5 and 10 seconds,\n            respectively.')
marsMcsRegisterRetrLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,5))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsRegisterRetrLimit.setDescription('MARS_MSERV/UNSERV retransmit limit. The maximum value\n            is 5.')
marsMcsRegWithMarsRdmTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,10))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsRegWithMarsRdmTimer.setDescription('Random time for a MCS to register with a MARS.')
marsMcsForceWaitTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647))).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsForceWaitTimer.setDescription('Force wait if MARS re-registration is looping.\n            The minimum value is 1 minute.')
marsMcsLmtToMissRedirMapTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,4))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsLmtToMissRedirMapTimer.setDescription('Timer limit for MCS to miss MARS_REDIRECT_MAPS.')
marsMcsIdleTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647)).clone(20)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsIdleTimer.setDescription('The configurable inactivity timer associated with a\n            MCS. When a VC is created at this MCS, it gets\n            the idle timer value from this configurable timer.\n            The minimum suggested value is 1 minute and the\n            recommended default value is 20 minutes.')
marsMcsRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 18), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsRowStatus.setDescription("The object is used to create, delete or modify a\n            row in this table.\n\n            A row cannot be made 'active' until instances of\n            all corresponding columns in the row of this table\n            are appropriately configured and until the agent\n            has also created a corresponding row in the\n            marsMcsStatTable.\n\n            When this object has a value of 'active', the\n            following columnar objects can not be modified:\n\n              marsMcsDefaultMarsAddr,\n              marsMcsSsn,\n              marsMcsRegstration,\n              marsMcsDefaultMtu\n\n            while other objects in this conceptual row can be\n            modified irrespective of the value of this object.\n            Deletion of this row is allowed regardless of\n            whether or not a row in any associated tables\n            (i.e., marsMcsVcTable) still exists or is in\n            use. Once this row is deleted, it is recommended\n            that the agent or the SNMP management station\n            (if possible) through the set command deletes\n            any stale rows that are associated with this\n            row.")
marsMcsMcGrpTable = MibTable((1, 3, 6, 1, 2, 1, 57, 3, 2), )
if mibBuilder.loadTexts: marsMcsMcGrpTable.setDescription('This table contains a list of IP multicast group address\n            blocks associated by a MARS MCS.  The MCS uses the\n            information contained in list to advertise its multicast\n            group service to the MARS.\n            Each row can be created or deleted via configuration.')
marsMcsMcGrpEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 3, 2, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsMcsIndex"), (0, "IPATM-IPMC-MIB", "marsMcsIfIndex"), (0, "IPATM-IPMC-MIB", "marsMcsMcMinGrpAddr"), (0, "IPATM-IPMC-MIB", "marsMcsMcMaxGrpAddr"))
if mibBuilder.loadTexts: marsMcsMcGrpEntry.setDescription('Each entry represents a consecutive block of multicast\n            group addresses.')
marsMcsMcMinGrpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 2, 1, 1), IpAddress())
if mibBuilder.loadTexts: marsMcsMcMinGrpAddr.setDescription('Minimum multicast group address - the min and max\n            multicast forms multi-group block.  If the MinGrpAddr\n            and MaxGrpAddr are the same, it indicates that this\n            block contains a single group address.   Since the\n            block joins are no allowed by a MCS as implied in\n            the RFC2022, the MinGrpAddr and MaxGrpAddress should\n            be set to the same value at this time when an entry\n            row is created.')
marsMcsMcMaxGrpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 2, 1, 2), IpAddress())
if mibBuilder.loadTexts: marsMcsMcMaxGrpAddr.setDescription('Maximum multicast group address - the min and max\n            multicast forms a multi-group block.  If the\n            MinGrpAddr and MaxGrpAddr are the same, it indicates\n            that this block contains a single group address.\n            Since the block joins are no allowed by a MCS as\n            implied in the RFC2022, the MinGrpAddr and\n            MaxGrpAddress should be set to the same value at\n            this time when an entry row is created.')
marsMcsMcGrpRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 2, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsMcGrpRowStatus.setDescription("The object is used to create or delete a row in this\n            table.\n\n            Since other objects in this row are not-accessible\n            'index-objects', the value of this object has no\n            effect on whether those objects in this conceptual\n            row can be modified.")
marsMcsBackupMarsTable = MibTable((1, 3, 6, 1, 2, 1, 57, 3, 3), )
if mibBuilder.loadTexts: marsMcsBackupMarsTable.setDescription('This table contains a list of backup MARS addresses that\n            a MCS can make contact to in case of failure for\n            connecting to the primary server. The list of addresses\n            is in descending order of preference. It should be noted\n            that the backup list provided by the MARS to the MCS\n            via the MARS_REDIRECT_MAP message has a higher preference\n            than addresses that are manually configured into the MCS.\n            When such a list is received from the MARS, this information\n            should be inserted at the top of the list.\n            Each row can be created or deleted via configuration.')
marsMcsBackupMarsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 3, 3, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsMcsIndex"), (0, "IPATM-IPMC-MIB", "marsMcsIfIndex"), (0, "IPATM-IPMC-MIB", "marsMcsBackupMarsPriority"), (0, "IPATM-IPMC-MIB", "marsMcsBackupMarsAddr"))
if mibBuilder.loadTexts: marsMcsBackupMarsEntry.setDescription('Each entry represents an ATM address of a backup MARS.')
marsMcsBackupMarsPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0,65535)))
if mibBuilder.loadTexts: marsMcsBackupMarsPriority.setDescription('The priority associated with a backup MARS. A lower\n            priority value inidcates a higher preference.')
marsMcsBackupMarsAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 3, 1, 2), AtmAddr())
if mibBuilder.loadTexts: marsMcsBackupMarsAddr.setDescription('The ATM address associated with a backup MARS.')
marsMcsBackupMarsRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 3, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsBackupMarsRowStatus.setDescription("The object is used to create or delete a row in this\n            table.\n\n            Since other objects in this row are not-accessible\n            'index-objects', the value of this object has no\n            effect on whether those objects in this conceptual\n            row can be modified.")
marsMcsVcTable = MibTable((1, 3, 6, 1, 2, 1, 57, 3, 4), )
if mibBuilder.loadTexts: marsMcsVcTable.setDescription('This table contains information about open virtual\n            circuits (VCs) that a MCS has.  For point to\n            point circuit, each entry represents a single VC\n            connection between this MCS ATM address to another\n            party ATM address.  In the case of point to\n            multipoint connection where a single source address\n            is associated with multiple destinations, several\n            entries are used to represent the relationship.  An\n            example of point to multi-point VC represented in a\n            table is shown below.\n\n               MCS      VPI/VCI    Grp Addr1/Addr2    Part Addr\n                1         0,1          g1,g2             p1\n                1         0,1          g1,g2             p2\n                1         0,1          g1,g2             p3')
marsMcsVcEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 3, 4, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsMcsIndex"), (0, "IPATM-IPMC-MIB", "marsMcsIfIndex"), (0, "IPATM-IPMC-MIB", "marsMcsVcVpi"), (0, "IPATM-IPMC-MIB", "marsMcsVcVci"), (0, "IPATM-IPMC-MIB", "marsMcsVcMinGrpAddr"), (0, "IPATM-IPMC-MIB", "marsMcsVcMaxGrpAddr"), (0, "IPATM-IPMC-MIB", "marsMcsVcPartyAddr"))
if mibBuilder.loadTexts: marsMcsVcEntry.setDescription('The objects contained in the entry are VC related\n            attributes such as VC signalling type, control VC\n            type, idle timer, negotiated MTU size, etc.')
marsMcsVcVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,4095)))
if mibBuilder.loadTexts: marsMcsVcVpi.setDescription('The value of virtual path identifier (VPI). Since\n            a VPI can be numbered 0, this sub-index can take\n            a value of 0.')
marsMcsVcVci = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,65535)))
if mibBuilder.loadTexts: marsMcsVcVci.setDescription('The value of virtual circuit identifier (VCI). Since\n            a VCI can be numbered 0, this sub-index can take\n            a value of 0.')
marsMcsVcMinGrpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 3), IpAddress())
if mibBuilder.loadTexts: marsMcsVcMinGrpAddr.setDescription('Minimum IP multicast group address - the min and\n            max multicast forms a multi-group block which is\n            associated with a VC.  If the MinGrpAddr and\n            MaxGrpAddr are the same, it indicates that the\n            size of multi-group block is 1, a single IP group.')
marsMcsVcMaxGrpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 4), IpAddress())
if mibBuilder.loadTexts: marsMcsVcMaxGrpAddr.setDescription('Maximum IP multicast group address - the min\n            and max multicast forms a multi-group block\n            which is associated with a VC. If the MinGrpAddr\n            and MaxGrpAddr are the same, it indicates that the\n            size of multi-group block is 1, a single IP group.')
marsMcsVcPartyAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 5), AtmAddr())
if mibBuilder.loadTexts: marsMcsVcPartyAddr.setDescription('An ATM party address in which this VC is linked.\n            The party type is identified by the\n            marsMcsVcPartyAddrType.')
marsMcsVcPartyAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("called", 1), ("calling", 2),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsVcPartyAddrType.setDescription('The party type is associated with the party address.\n            The called (1) indicates that the party address is\n            a destination address which implies that VC is\n            originated from this MCS.  The calling (2) indicates\n            the VC was initiated externally to this MCS.  In this\n            case, the party address is the source address.')
marsMcsVcType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("pvc", 1), ("svc", 2),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsVcType.setDescription('Circuit Connection type: permanent virtual circuit or\n            switched virtual circuit.')
marsMcsVcCtrlType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("pointToPointVC", 1), ("serverControlVC", 2), ("pointToMultiPointVC", 3),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsVcCtrlType.setDescription('Control VC type used to specify a particular connection.\n              pointToPointVC (1):\n                used by the ATM Clients for the registration and\n                queries.  This VC or the initial signalling path is\n                set up from the source MCS to a MARS. It is\n                bi-directional.\n              serverControlVC (2):\n                used by a MARS to issue asynchronous updates to an\n                ATM Client.  This VC is established from the MARS\n                to the MCS.\n              pointToMultiPointVC (3):\n                used by the client to transfer multicast data\n                packets from layer 3.  This VC is established from\n                this VC to a cluster member.')
marsMcsVcIdleTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,2147483647)).clone(20)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsVcIdleTimer.setDescription('The idle timer associated with this VC. The minimum\n            suggested value is 1 minute and the recommended\n            default value is 20 minutes.')
marsMcsVcRevalidate = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 10), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsVcRevalidate.setDescription('A flag associated with an open and active multipoint\n            VC. It is checked every time a packet is queued for\n            transmission on that VC. The object has the value of\n            true (1) if revalidate is required and the value\n            false (2) otherwise.')
marsMcsVcEncapsType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2,))).clone(namedValues=NamedValues(("other", 1), ("llcSnap", 2),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsVcEncapsType.setDescription('The encapsulation type used when communicating over\n            this VC.')
marsMcsVcNegotiatedMtu = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1,65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsVcNegotiatedMtu.setDescription('The negotiated MTU when communicating over this VC.')
marsMcsVcRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsVcRowStatus.setDescription("The object is used to create, delete or modify a\n            row in this table.\n            A row cannot be made 'active' until instances of\n            all corresponding columns in the row of this table\n            are appropriately configured.\n\n            While objects: marsMcsVcIdleTimer and\n            marsMcsVcRevalidate in this conceptual row can\n            be modified irrespective of the value of this\n            object, all other objects in the row can not be\n            modified when this object has a value of 'active'.\n\n            It is possible for an SNMP management station\n            to set the row to 'notInService' and modify\n            the entry and then set it back to 'active'\n            with the following exception. That is, rows\n            for which the corresponding instance of\n            marsMcsVcType has a value of 'svc' can not\n            be modified or deleted.")
marsMcsStatTable = MibTable((1, 3, 6, 1, 2, 1, 57, 3, 5), )
if mibBuilder.loadTexts: marsMcsStatTable.setDescription('The table contains statistics collected at MARS MCSs.')
marsMcsStatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 3, 5, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsMcsIndex"), (0, "IPATM-IPMC-MIB", "marsMcsIfIndex"))
if mibBuilder.loadTexts: marsMcsStatEntry.setDescription('Each entry contains statistics collected at one\n            MARS MCS.')
marsMcsStatTxReqMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsMcsStatTxReqMsgs.setDescription('Total number of MARS_REQUEST messages transmitted\n            from this MCS.')
marsMcsStatTxMservMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsMcsStatTxMservMsgs.setDescription('Total number of MARS_MSERV messages transmitted from\n            this MCS.')
marsMcsStatTxUnservMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsMcsStatTxUnservMsgs.setDescription('Total number of MARS_UNSERV messages transmitted from\n            this MCS.')
marsMcsStatRxMultiMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsMcsStatRxMultiMsgs.setDescription('Total number of MARS_MULTI messages received by\n            this MCS.')
marsMcsStatRxSjoinMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsMcsStatRxSjoinMsgs.setDescription('Total number of MARS_SJOIN messages received by\n            this MCS.')
marsMcsStatRxSleaveMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsMcsStatRxSleaveMsgs.setDescription('Total number of MARS_SLEAVE messages received\n            by this MCS.')
marsMcsStatRxNakMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsMcsStatRxNakMsgs.setDescription('Total number of MARS_NAK messages received\n            by this MCS.')
marsMcsStatRxMigrateMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsMcsStatRxMigrateMsgs.setDescription('Total number of MARS_MIGRATE messages received\n            by this MCS.')
marsMcsStatFailMultiMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsMcsStatFailMultiMsgs.setDescription('Total number of timeouts occurred indicating\n            failure of the last MARS_MULTI to arrive.')
marsTrapInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 0))
marsFaultTrap = NotificationType((1, 3, 6, 1, 2, 1, 57, 0, 1)).setObjects(*(("IPATM-IPMC-MIB", "marsAddr"), ("IPATM-IPMC-MIB", "marsServStatus"),))
if mibBuilder.loadTexts: marsFaultTrap.setDescription('This trap/inform is sent to the manager whenever\n            there is a fault condition occurred on a MARS.')
marsConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 4))
marsClientConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 4, 1))
marsServerConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 4, 2))
marsMcsConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 4, 3))
marsClientCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 4, 1, 1))
marsClientGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 4, 1, 2))
marsServerCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 4, 2, 1))
marsServerGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 4, 2, 2))
marsMcsCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 4, 3, 1))
marsMcsGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 4, 3, 2))
marsClientCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 57, 4, 1, 1, 1)).setObjects(*(("IPATM-IPMC-MIB", "marsClientGroup"),))
if mibBuilder.loadTexts: marsClientCompliance.setDescription('The compliance statement for entities that are required\n            for the management of MARS clients.')
marsClientGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 57, 4, 1, 2, 1)).setObjects(*(("IPATM-IPMC-MIB", "marsClientAddr"), ("IPATM-IPMC-MIB", "marsClientDefaultMarsAddr"), ("IPATM-IPMC-MIB", "marsClientHsn"), ("IPATM-IPMC-MIB", "marsClientRegistration"), ("IPATM-IPMC-MIB", "marsClientCmi"), ("IPATM-IPMC-MIB", "marsClientDefaultMtu"), ("IPATM-IPMC-MIB", "marsClientFailureTimer"), ("IPATM-IPMC-MIB", "marsClientRetranDelayTimer"), ("IPATM-IPMC-MIB", "marsClientRdmMulReqAddRetrTimer"), ("IPATM-IPMC-MIB", "marsClientRdmVcRevalidateTimer"), ("IPATM-IPMC-MIB", "marsClientJoinLeaveRetrInterval"), ("IPATM-IPMC-MIB", "marsClientJoinLeaveRetrLimit"), ("IPATM-IPMC-MIB", "marsClientRegWithMarsRdmTimer"), ("IPATM-IPMC-MIB", "marsClientForceWaitTimer"), ("IPATM-IPMC-MIB", "marsClientIdleTimer"), ("IPATM-IPMC-MIB", "marsClientLmtToMissRedirMapTimer"), ("IPATM-IPMC-MIB", "marsClientRowStatus"), ("IPATM-IPMC-MIB", "marsClientMcGrpRowStatus"), ("IPATM-IPMC-MIB", "marsClientBackupMarsRowStatus"), ("IPATM-IPMC-MIB", "marsClientVcPartyAddrType"), ("IPATM-IPMC-MIB", "marsClientVcType"), ("IPATM-IPMC-MIB", "marsClientVcCtrlType"), ("IPATM-IPMC-MIB", "marsClientVcIdleTimer"), ("IPATM-IPMC-MIB", "marsClientVcRevalidate"), ("IPATM-IPMC-MIB", "marsClientVcEncapsType"), ("IPATM-IPMC-MIB", "marsClientVcNegotiatedMtu"), ("IPATM-IPMC-MIB", "marsClientVcRowStatus"), ("IPATM-IPMC-MIB", "marsClientStatTxReqMsgs"), ("IPATM-IPMC-MIB", "marsClientStatTxJoinMsgs"), ("IPATM-IPMC-MIB", "marsClientStatTxLeaveMsgs"), ("IPATM-IPMC-MIB", "marsClientStatTxGrpLstReqMsgs"), ("IPATM-IPMC-MIB", "marsClientStatRxJoinMsgs"), ("IPATM-IPMC-MIB", "marsClientStatRxLeaveMsgs"), ("IPATM-IPMC-MIB", "marsClientStatRxMultiMsgs"), ("IPATM-IPMC-MIB", "marsClientStatRxNakMsgs"), ("IPATM-IPMC-MIB", "marsClientStatRxGrpLstRplyMsgs"), ("IPATM-IPMC-MIB", "marsClientStatRxMigrateMsgs"), ("IPATM-IPMC-MIB", "marsClientStatFailMultiMsgs"),))
if mibBuilder.loadTexts: marsClientGroup.setDescription('A collection of objects to be implemented in a MIB\n            for the management of MARS clients.')
marsServerCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 57, 4, 2, 1, 1)).setObjects(*(("IPATM-IPMC-MIB", "marsServerGroup"), ("IPATM-IPMC-MIB", "marsServerEventGroup"),))
if mibBuilder.loadTexts: marsServerCompliance.setDescription('The compliance statement for entities that are required\n            for the management of MARS servers.')
marsServerGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 57, 4, 2, 2, 1)).setObjects(*(("IPATM-IPMC-MIB", "marsAddr"), ("IPATM-IPMC-MIB", "marsLocal"), ("IPATM-IPMC-MIB", "marsServStatus"), ("IPATM-IPMC-MIB", "marsServType"), ("IPATM-IPMC-MIB", "marsServPriority"), ("IPATM-IPMC-MIB", "marsRedirMapMsgTimer"), ("IPATM-IPMC-MIB", "marsCsn"), ("IPATM-IPMC-MIB", "marsSsn"), ("IPATM-IPMC-MIB", "marsRowStatus"), ("IPATM-IPMC-MIB", "marsMcGrpAddrUsage"), ("IPATM-IPMC-MIB", "marsMcGrpRxLayer3GrpSets"), ("IPATM-IPMC-MIB", "marsMcGrpRxLayer3GrpResets"), ("IPATM-IPMC-MIB", "marsMcGrpRowStatus"), ("IPATM-IPMC-MIB", "marsHostMapRowType"), ("IPATM-IPMC-MIB", "marsHostMapRowStatus"), ("IPATM-IPMC-MIB", "marsServerMapRowType"), ("IPATM-IPMC-MIB", "marsServerMapRowStatus"), ("IPATM-IPMC-MIB", "marsVcPartyAddrType"), ("IPATM-IPMC-MIB", "marsVcType"), ("IPATM-IPMC-MIB", "marsVcCtrlType"), ("IPATM-IPMC-MIB", "marsVcIdleTimer"), ("IPATM-IPMC-MIB", "marsVcCmi"), ("IPATM-IPMC-MIB", "marsVcEncapsType"), ("IPATM-IPMC-MIB", "marsVcNegotiatedMtu"), ("IPATM-IPMC-MIB", "marsVcRowStatus"), ("IPATM-IPMC-MIB", "marsRegClientAtmAddr"), ("IPATM-IPMC-MIB", "marsRegMcsAtmAddr"), ("IPATM-IPMC-MIB", "marsStatTxMultiMsgs"), ("IPATM-IPMC-MIB", "marsStatTxGrpLstRplyMsgs"), ("IPATM-IPMC-MIB", "marsStatTxRedirectMapMsgs"), ("IPATM-IPMC-MIB", "marsStatTxMigrateMsgs"), ("IPATM-IPMC-MIB", "marsStatTxNakMsgs"), ("IPATM-IPMC-MIB", "marsStatTxJoinMsgs"), ("IPATM-IPMC-MIB", "marsStatTxLeaveMsgs"), ("IPATM-IPMC-MIB", "marsStatTxSjoinMsgs"), ("IPATM-IPMC-MIB", "marsStatTxSleaveMsgs"), ("IPATM-IPMC-MIB", "marsStatTxMservMsgs"), ("IPATM-IPMC-MIB", "marsStatTxUnservMsgs"), ("IPATM-IPMC-MIB", "marsStatRxReqMsgs"), ("IPATM-IPMC-MIB", "marsStatRxGrpLstReqMsgs"), ("IPATM-IPMC-MIB", "marsStatRxJoinMsgs"), ("IPATM-IPMC-MIB", "marsStatRxLeaveMsgs"), ("IPATM-IPMC-MIB", "marsStatRxMservMsgs"), ("IPATM-IPMC-MIB", "marsStatRxUnservMsgs"), ("IPATM-IPMC-MIB", "marsStatRxBlkJoinMsgs"), ("IPATM-IPMC-MIB", "marsStatRegMemGroups"), ("IPATM-IPMC-MIB", "marsStatRegMcsGroups"),))
if mibBuilder.loadTexts: marsServerGroup.setDescription('A collection of objects to be implemented in a MIB\n            for the management of MARS servers.')
marsServerEventGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 57, 4, 2, 2, 2)).setObjects(*(("IPATM-IPMC-MIB", "marsFaultTrap"),))
if mibBuilder.loadTexts: marsServerEventGroup.setDescription('A collection of events that can be generated from\n            a MARS server.')
marsMcsCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 57, 4, 3, 1, 1)).setObjects(*(("IPATM-IPMC-MIB", "marsMcsGroup"),))
if mibBuilder.loadTexts: marsMcsCompliance.setDescription('The compliance statement for entities that are required\n            for the management of MARS multicast servers (MCS).')
marsMcsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 57, 4, 3, 2, 1)).setObjects(*(("IPATM-IPMC-MIB", "marsMcsAddr"), ("IPATM-IPMC-MIB", "marsMcsDefaultMarsAddr"), ("IPATM-IPMC-MIB", "marsMcsRegistration"), ("IPATM-IPMC-MIB", "marsMcsSsn"), ("IPATM-IPMC-MIB", "marsMcsDefaultMtu"), ("IPATM-IPMC-MIB", "marsMcsFailureTimer"), ("IPATM-IPMC-MIB", "marsMcsRetranDelayTimer"), ("IPATM-IPMC-MIB", "marsMcsRdmMulReqAddRetrTimer"), ("IPATM-IPMC-MIB", "marsMcsRdmVcRevalidateTimer"), ("IPATM-IPMC-MIB", "marsMcsRegisterRetrInterval"), ("IPATM-IPMC-MIB", "marsMcsRegisterRetrLimit"), ("IPATM-IPMC-MIB", "marsMcsRegWithMarsRdmTimer"), ("IPATM-IPMC-MIB", "marsMcsForceWaitTimer"), ("IPATM-IPMC-MIB", "marsMcsIdleTimer"), ("IPATM-IPMC-MIB", "marsMcsLmtToMissRedirMapTimer"), ("IPATM-IPMC-MIB", "marsMcsRowStatus"), ("IPATM-IPMC-MIB", "marsMcsMcGrpRowStatus"), ("IPATM-IPMC-MIB", "marsMcsVcPartyAddrType"), ("IPATM-IPMC-MIB", "marsMcsBackupMarsRowStatus"), ("IPATM-IPMC-MIB", "marsMcsVcType"), ("IPATM-IPMC-MIB", "marsMcsVcCtrlType"), ("IPATM-IPMC-MIB", "marsMcsVcIdleTimer"), ("IPATM-IPMC-MIB", "marsMcsVcRevalidate"), ("IPATM-IPMC-MIB", "marsMcsVcEncapsType"), ("IPATM-IPMC-MIB", "marsMcsVcNegotiatedMtu"), ("IPATM-IPMC-MIB", "marsMcsVcRowStatus"), ("IPATM-IPMC-MIB", "marsMcsStatTxReqMsgs"), ("IPATM-IPMC-MIB", "marsMcsStatTxMservMsgs"), ("IPATM-IPMC-MIB", "marsMcsStatTxUnservMsgs"), ("IPATM-IPMC-MIB", "marsMcsStatRxMultiMsgs"), ("IPATM-IPMC-MIB", "marsMcsStatRxSjoinMsgs"), ("IPATM-IPMC-MIB", "marsMcsStatRxSleaveMsgs"), ("IPATM-IPMC-MIB", "marsMcsStatRxNakMsgs"), ("IPATM-IPMC-MIB", "marsMcsStatRxMigrateMsgs"), ("IPATM-IPMC-MIB", "marsMcsStatFailMultiMsgs"),))
if mibBuilder.loadTexts: marsMcsGroup.setDescription('A collection of objects to be implemented in a MIB\n            for the management of MARS multicast servers (MCS).')
mibBuilder.exportSymbols("IPATM-IPMC-MIB", marsVcPartyAddr=marsVcPartyAddr, marsMcsRetranDelayTimer=marsMcsRetranDelayTimer, marsServerGroup=marsServerGroup, marsStatEntry=marsStatEntry, marsFaultTrap=marsFaultTrap, marsStatRxJoinMsgs=marsStatRxJoinMsgs, marsClientStatTxGrpLstReqMsgs=marsClientStatTxGrpLstReqMsgs, marsMcsGroups=marsMcsGroups, marsMcsCompliance=marsMcsCompliance, marsHostMapAtmAddr=marsHostMapAtmAddr, marsHostMapRowStatus=marsHostMapRowStatus, marsRegClientAtmAddr=marsRegClientAtmAddr, marsVcIdleTimer=marsVcIdleTimer, marsVcRowStatus=marsVcRowStatus, marsStatRegMcsGroups=marsStatRegMcsGroups, marsMcsMcGrpEntry=marsMcsMcGrpEntry, marsMcsStatTxMservMsgs=marsMcsStatTxMservMsgs, marsMcsCompliances=marsMcsCompliances, marsStatTxUnservMsgs=marsStatTxUnservMsgs, marsVcVci=marsVcVci, marsRegClientCmi=marsRegClientCmi, marsClientStatRxNakMsgs=marsClientStatRxNakMsgs, marsStatRxBlkJoinMsgs=marsStatRxBlkJoinMsgs, marsClientJoinLeaveRetrLimit=marsClientJoinLeaveRetrLimit, marsServerMapTable=marsServerMapTable, marsMcsTable=marsMcsTable, marsMcsVcRevalidate=marsMcsVcRevalidate, marsStatTable=marsStatTable, marsStatRegMemGroups=marsStatRegMemGroups, marsClientMcMaxGrpAddr=marsClientMcMaxGrpAddr, marsServerMapRowStatus=marsServerMapRowStatus, marsServerMapAtmAddr=marsServerMapAtmAddr, marsServerConformance=marsServerConformance, marsVcTable=marsVcTable, marsMcGrpRxLayer3GrpSets=marsMcGrpRxLayer3GrpSets, marsMcsObjects=marsMcsObjects, marsClientStatTxReqMsgs=marsClientStatTxReqMsgs, marsClientStatRxLeaveMsgs=marsClientStatRxLeaveMsgs, marsClientAddr=marsClientAddr, marsClientBackupMarsAddr=marsClientBackupMarsAddr, marsObjects=marsObjects, marsClientDefaultMtu=marsClientDefaultMtu, marsMcsRegistration=marsMcsRegistration, marsClientObjects=marsClientObjects, marsRegMcsTable=marsRegMcsTable, marsVcEntry=marsVcEntry, marsServPriority=marsServPriority, marsMcsEntry=marsMcsEntry, marsClientVcTable=marsClientVcTable, marsMcsSsn=marsMcsSsn, marsServerEventGroup=marsServerEventGroup, marsServType=marsServType, marsClientVcCtrlType=marsClientVcCtrlType, marsMcsAddr=marsMcsAddr, marsClientVcMinGrpAddr=marsClientVcMinGrpAddr, marsMcsVcType=marsMcsVcType, marsMcsStatRxNakMsgs=marsMcsStatRxNakMsgs, marsClientFailureTimer=marsClientFailureTimer, marsClientVcIdleTimer=marsClientVcIdleTimer, marsMcsFailureTimer=marsMcsFailureTimer, marsClientBackupMarsPriority=marsClientBackupMarsPriority, marsIfIndex=marsIfIndex, marsMcsRdmMulReqAddRetrTimer=marsMcsRdmMulReqAddRetrTimer, marsMcGrpAddrUsage=marsMcGrpAddrUsage, marsMcsMcMaxGrpAddr=marsMcsMcMaxGrpAddr, marsClientGroups=marsClientGroups, marsVcEncapsType=marsVcEncapsType, marsMcsIndex=marsMcsIndex, marsClientMcGrpEntry=marsClientMcGrpEntry, marsStatRxMservMsgs=marsStatRxMservMsgs, marsEntry=marsEntry, marsClientMcGrpRowStatus=marsClientMcGrpRowStatus, marsClientTable=marsClientTable, marsMcsBackupMarsPriority=marsMcsBackupMarsPriority, marsClientIdleTimer=marsClientIdleTimer, marsClientVcVci=marsClientVcVci, marsVcType=marsVcType, marsMcsConformance=marsMcsConformance, marsMcsRegisterRetrLimit=marsMcsRegisterRetrLimit, marsClientStatTxLeaveMsgs=marsClientStatTxLeaveMsgs, marsClientStatTable=marsClientStatTable, marsClientStatRxMigrateMsgs=marsClientStatRxMigrateMsgs, marsVcNegotiatedMtu=marsVcNegotiatedMtu, marsStatTxJoinMsgs=marsStatTxJoinMsgs, marsMcMaxGrpAddr=marsMcMaxGrpAddr, marsMcsIdleTimer=marsMcsIdleTimer, marsClientRegistration=marsClientRegistration, marsTrapInfo=marsTrapInfo, marsClientCmi=marsClientCmi, marsMcsStatRxMultiMsgs=marsMcsStatRxMultiMsgs, marsClientCompliance=marsClientCompliance, marsMcsVcTable=marsMcsVcTable, marsMcsRegisterRetrInterval=marsMcsRegisterRetrInterval, marsVcPartyAddrType=marsVcPartyAddrType, marsClientGroup=marsClientGroup, marsCsn=marsCsn, marsMcsVcVpi=marsMcsVcVpi, marsMcsDefaultMtu=marsMcsDefaultMtu, marsClientVcVpi=marsClientVcVpi, marsMcsStatFailMultiMsgs=marsMcsStatFailMultiMsgs, marsMcsVcVci=marsMcsVcVci, marsRegMcsAtmAddr=marsRegMcsAtmAddr, marsClientVcEntry=marsClientVcEntry, marsServerMapRowType=marsServerMapRowType, marsClientBackupMarsRowStatus=marsClientBackupMarsRowStatus, marsHostMapTable=marsHostMapTable, marsClientIndex=marsClientIndex, marsClientStatRxMultiMsgs=marsClientStatRxMultiMsgs, marsStatTxLeaveMsgs=marsStatTxLeaveMsgs, marsClientRowStatus=marsClientRowStatus, marsStatTxMultiMsgs=marsStatTxMultiMsgs, marsMcsVcPartyAddr=marsMcsVcPartyAddr, marsServerCompliance=marsServerCompliance, marsMcsBackupMarsRowStatus=marsMcsBackupMarsRowStatus, marsStatRxLeaveMsgs=marsStatRxLeaveMsgs, marsMcsVcEntry=marsMcsVcEntry, marsMcsRowStatus=marsMcsRowStatus, marsStatRxGrpLstReqMsgs=marsStatRxGrpLstReqMsgs, marsClientHsn=marsClientHsn, marsClientStatFailMultiMsgs=marsClientStatFailMultiMsgs, marsClientLmtToMissRedirMapTimer=marsClientLmtToMissRedirMapTimer, marsClientVcPartyAddr=marsClientVcPartyAddr, marsClientRdmMulReqAddRetrTimer=marsClientRdmMulReqAddRetrTimer, marsMcGrpTable=marsMcGrpTable, marsMcsBackupMarsAddr=marsMcsBackupMarsAddr, marsAddr=marsAddr, marsMcsVcCtrlType=marsMcsVcCtrlType, marsMcsStatRxMigrateMsgs=marsMcsStatRxMigrateMsgs, marsMcsStatEntry=marsMcsStatEntry, marsRedirMapMsgTimer=marsRedirMapMsgTimer, marsMcsVcNegotiatedMtu=marsMcsVcNegotiatedMtu, marsMcsVcMinGrpAddr=marsMcsVcMinGrpAddr, marsMcMinGrpAddr=marsMcMinGrpAddr, marsMcsVcRowStatus=marsMcsVcRowStatus, marsClientVcNegotiatedMtu=marsClientVcNegotiatedMtu, marsClientStatRxJoinMsgs=marsClientStatRxJoinMsgs, marsVcCmi=marsVcCmi, marsIndex=marsIndex, marsRegMcsEntry=marsRegMcsEntry, marsMcsDefaultMarsAddr=marsMcsDefaultMarsAddr, marsMcsStatRxSjoinMsgs=marsMcsStatRxSjoinMsgs, marsClientJoinLeaveRetrInterval=marsClientJoinLeaveRetrInterval, marsMcsForceWaitTimer=marsMcsForceWaitTimer, marsServerGroups=marsServerGroups, marsHostMapRowType=marsHostMapRowType, marsMcsStatTable=marsMcsStatTable, marsMcsRegWithMarsRdmTimer=marsMcsRegWithMarsRdmTimer, marsRowStatus=marsRowStatus, marsHostMapEntry=marsHostMapEntry, marsStatTxNakMsgs=marsStatTxNakMsgs, marsClientConformance=marsClientConformance, marsClientVcType=marsClientVcType, marsMcsBackupMarsEntry=marsMcsBackupMarsEntry, marsClientVcRevalidate=marsClientVcRevalidate, marsClientCompliances=marsClientCompliances, marsStatTxMigrateMsgs=marsStatTxMigrateMsgs, marsClientDefaultMarsAddr=marsClientDefaultMarsAddr, marsStatTxRedirectMapMsgs=marsStatTxRedirectMapMsgs, marsClientVcMaxGrpAddr=marsClientVcMaxGrpAddr, marsClientRegWithMarsRdmTimer=marsClientRegWithMarsRdmTimer, marsVcVpi=marsVcVpi, marsClientStatRxGrpLstRplyMsgs=marsClientStatRxGrpLstRplyMsgs, marsMcsVcMaxGrpAddr=marsMcsVcMaxGrpAddr, marsClientForceWaitTimer=marsClientForceWaitTimer, marsStatTxSjoinMsgs=marsStatTxSjoinMsgs, marsClientMcMinGrpAddr=marsClientMcMinGrpAddr, marsMcsStatTxReqMsgs=marsMcsStatTxReqMsgs, marsMcsMcMinGrpAddr=marsMcsMcMinGrpAddr, marsStatRxUnservMsgs=marsStatRxUnservMsgs, marsConformance=marsConformance, marsStatTxMservMsgs=marsStatTxMservMsgs, marsMcsBackupMarsTable=marsMcsBackupMarsTable, marsMcGrpRowStatus=marsMcGrpRowStatus, marsMcGrpEntry=marsMcGrpEntry, marsMcsRdmVcRevalidateTimer=marsMcsRdmVcRevalidateTimer, marsRegClientTable=marsRegClientTable, marsMIB=marsMIB, marsClientStatEntry=marsClientStatEntry, marsMcsVcEncapsType=marsMcsVcEncapsType, marsMcsStatRxSleaveMsgs=marsMcsStatRxSleaveMsgs, marsServerMapEntry=marsServerMapEntry, marsTable=marsTable, marsRegClientEntry=marsRegClientEntry, marsMcsMcGrpRowStatus=marsMcsMcGrpRowStatus, marsClientRdmVcRevalidateTimer=marsClientRdmVcRevalidateTimer, marsVcCtrlType=marsVcCtrlType, marsMcsVcIdleTimer=marsMcsVcIdleTimer, marsSsn=marsSsn, marsServerCompliances=marsServerCompliances, marsClientMcGrpTable=marsClientMcGrpTable, marsServStatus=marsServStatus, marsMcGrpRxLayer3GrpResets=marsMcGrpRxLayer3GrpResets, marsClientRetranDelayTimer=marsClientRetranDelayTimer, marsLocal=marsLocal, marsMcsStatTxUnservMsgs=marsMcsStatTxUnservMsgs, marsMcsVcPartyAddrType=marsMcsVcPartyAddrType, marsStatRxReqMsgs=marsStatRxReqMsgs, marsClientStatTxJoinMsgs=marsClientStatTxJoinMsgs, marsStatTxGrpLstRplyMsgs=marsStatTxGrpLstRplyMsgs, marsClientBackupMarsTable=marsClientBackupMarsTable, marsMcsIfIndex=marsMcsIfIndex, marsClientVcEncapsType=marsClientVcEncapsType, marsMcsGroup=marsMcsGroup, marsClientVcRowStatus=marsClientVcRowStatus, marsClientVcPartyAddrType=marsClientVcPartyAddrType, marsClientBackupMarsEntry=marsClientBackupMarsEntry, marsStatTxSleaveMsgs=marsStatTxSleaveMsgs, marsClientEntry=marsClientEntry, marsMcsMcGrpTable=marsMcsMcGrpTable, PYSNMP_MODULE_ID=marsMIB, marsMcsLmtToMissRedirMapTimer=marsMcsLmtToMissRedirMapTimer)
