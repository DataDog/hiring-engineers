#
# PySNMP MIB module IP-FORWARD-MIB (http://pysnmp.sf.net)
# ASN.1 source http://mibs.snmplabs.com:80/asn1/IP-FORWARD-MIB
# Produced by pysmi-0.0.7 at Sun Feb 14 00:17:45 2016
# On host bldfarm platform Linux version 4.1.13-100.fc21.x86_64 by user goose
# Using Python version 3.5.0 (default, Jan  5 2016, 17:11:52) 
#
( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion")
( IANAipRouteProtocol, ) = mibBuilder.importSymbols("IANA-RTPROTO-MIB", "IANAipRouteProtocol")
( InterfaceIndexOrZero, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
( InetAutonomousSystemNumber, InetAddressPrefixLength, InetAddressType, InetAddress, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAutonomousSystemNumber", "InetAddressPrefixLength", "InetAddressType", "InetAddress")
( ip, ) = mibBuilder.importSymbols("IP-MIB", "ip")
( ModuleCompliance, ObjectGroup, NotificationGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
( Unsigned32, ModuleIdentity, Gauge32, Counter64, MibIdentifier, iso, Counter32, NotificationType, ObjectIdentity, Bits, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Integer32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "ModuleIdentity", "Gauge32", "Counter64", "MibIdentifier", "iso", "Counter32", "NotificationType", "ObjectIdentity", "Bits", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Integer32")
( RowStatus, TextualConvention, DisplayString, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TextualConvention", "DisplayString")
ipForward = ModuleIdentity((1, 3, 6, 1, 2, 1, 4, 24)).setRevisions(("2006-02-01 00:00", "1996-09-19 00:00", "1992-07-02 21:56",))
if mibBuilder.loadTexts: ipForward.setLastUpdated('200602010000Z')
if mibBuilder.loadTexts: ipForward.setOrganization('IETF IPv6 Working Group\n               http://www.ietf.org/html.charters/ipv6-charter.html')
if mibBuilder.loadTexts: ipForward.setContactInfo('Editor:\n               Brian Haberman\n               Johns Hopkins University - Applied Physics Laboratory\n               Mailstop 17-S442\n               11100 Johns Hopkins Road\n               Laurel MD,  20723-6099  USA\n\n               Phone: +1-443-778-1319\n               Email: brian@innovationslab.net\n\n               Send comments to <ipv6@ietf.org>')
if mibBuilder.loadTexts: ipForward.setDescription('The MIB module for the management of CIDR multipath IP\n               Routes.\n\n               Copyright (C) The Internet Society (2006).  This version\n               of this MIB module is a part of RFC 4292; see the RFC\n               itself for full legal notices.')
inetCidrRouteNumber = MibScalar((1, 3, 6, 1, 2, 1, 4, 24, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inetCidrRouteNumber.setDescription('The number of current inetCidrRouteTable entries that\n               are not invalid.')
inetCidrRouteDiscards = MibScalar((1, 3, 6, 1, 2, 1, 4, 24, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inetCidrRouteDiscards.setDescription('The number of valid route entries discarded from the\n               inetCidrRouteTable.  Discarded route entries do not\n               appear in the inetCidrRouteTable.  One possible reason\n               for discarding an entry would be to free-up buffer space\n               for other route table entries.')
inetCidrRouteTable = MibTable((1, 3, 6, 1, 2, 1, 4, 24, 7), )
if mibBuilder.loadTexts: inetCidrRouteTable.setDescription("This entity's IP Routing table.")
inetCidrRouteEntry = MibTableRow((1, 3, 6, 1, 2, 1, 4, 24, 7, 1), ).setIndexNames((0, "IP-FORWARD-MIB", "inetCidrRouteDestType"), (0, "IP-FORWARD-MIB", "inetCidrRouteDest"), (0, "IP-FORWARD-MIB", "inetCidrRoutePfxLen"), (0, "IP-FORWARD-MIB", "inetCidrRoutePolicy"), (0, "IP-FORWARD-MIB", "inetCidrRouteNextHopType"), (0, "IP-FORWARD-MIB", "inetCidrRouteNextHop"))
if mibBuilder.loadTexts: inetCidrRouteEntry.setDescription('A particular route to a particular destination, under a\n               particular policy (as reflected in the\n               inetCidrRoutePolicy object).\n\n               Dynamically created rows will survive an agent reboot.\n\n               Implementers need to be aware that if the total number\n               of elements (octets or sub-identifiers) in\n               inetCidrRouteDest, inetCidrRoutePolicy, and\n               inetCidrRouteNextHop exceeds 111, then OIDs of column\n               instances in this table will have more than 128 sub-\n               identifiers and cannot be accessed using SNMPv1,\n               SNMPv2c, or SNMPv3.')
inetCidrRouteDestType = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 1), InetAddressType())
if mibBuilder.loadTexts: inetCidrRouteDestType.setDescription('The type of the inetCidrRouteDest address, as defined\n               in the InetAddress MIB.\n\n               Only those address types that may appear in an actual\n               routing table are allowed as values of this object.')
inetCidrRouteDest = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 2), InetAddress())
if mibBuilder.loadTexts: inetCidrRouteDest.setDescription('The destination IP address of this route.\n\n               The type of this address is determined by the value of\n               the inetCidrRouteDestType object.\n\n               The values for the index objects inetCidrRouteDest and\n               inetCidrRoutePfxLen must be consistent.  When the value\n               of inetCidrRouteDest (excluding the zone index, if one\n               is present) is x, then the bitwise logical-AND\n               of x with the value of the mask formed from the\n               corresponding index object inetCidrRoutePfxLen MUST be\n               equal to x.  If not, then the index pair is not\n               consistent and an inconsistentName error must be\n               returned on SET or CREATE requests.')
inetCidrRoutePfxLen = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 3), InetAddressPrefixLength())
if mibBuilder.loadTexts: inetCidrRoutePfxLen.setDescription('Indicates the number of leading one bits that form the\n               mask to be logical-ANDed with the destination address\n               before being compared to the value in the\n               inetCidrRouteDest field.\n               The values for the index objects inetCidrRouteDest and\n               inetCidrRoutePfxLen must be consistent.  When the value\n               of inetCidrRouteDest (excluding the zone index, if one\n               is present) is x, then the bitwise logical-AND\n               of x with the value of the mask formed from the\n               corresponding index object inetCidrRoutePfxLen MUST be\n               equal to x.  If not, then the index pair is not\n               consistent and an inconsistentName error must be\n               returned on SET or CREATE requests.')
inetCidrRoutePolicy = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 4), ObjectIdentifier())
if mibBuilder.loadTexts: inetCidrRoutePolicy.setDescription('This object is an opaque object without any defined\n               semantics.  Its purpose is to serve as an additional\n               index that may delineate between multiple entries to\n               the same destination.  The value { 0 0 } shall be used\n               as the default value for this object.')
inetCidrRouteNextHopType = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 5), InetAddressType())
if mibBuilder.loadTexts: inetCidrRouteNextHopType.setDescription('The type of the inetCidrRouteNextHop address, as\n               defined in the InetAddress MIB.\n\n               Value should be set to unknown(0) for non-remote\n               routes.\n\n               Only those address types that may appear in an actual\n               routing table are allowed as values of this object.')
inetCidrRouteNextHop = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 6), InetAddress())
if mibBuilder.loadTexts: inetCidrRouteNextHop.setDescription('On remote routes, the address of the next system en\n               route.  For non-remote routes, a zero length string.\n               The type of this address is determined by the value of\n               the inetCidrRouteNextHopType object.')
inetCidrRouteIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 7), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inetCidrRouteIfIndex.setDescription('The ifIndex value that identifies the local interface\n               through which the next hop of this route should be\n               reached.  A value of 0 is valid and represents the\n               scenario where no interface is specified.')
inetCidrRouteType = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5,))).clone(namedValues=NamedValues(("other", 1), ("reject", 2), ("local", 3), ("remote", 4), ("blackhole", 5),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inetCidrRouteType.setDescription('The type of route.  Note that local(3) refers to a\n               route for which the next hop is the final destination;\n               remote(4) refers to a route for which the next hop is\n               not the final destination.\n\n               Routes that do not result in traffic forwarding or\n               rejection should not be displayed, even if the\n               implementation keeps them stored internally.\n\n               reject(2) refers to a route that, if matched, discards\n               the message as unreachable and returns a notification\n               (e.g., ICMP error) to the message sender.  This is used\n               in some protocols as a means of correctly aggregating\n               routes.\n\n               blackhole(5) refers to a route that, if matched,\n               discards the message silently.')
inetCidrRouteProto = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 9), IANAipRouteProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inetCidrRouteProto.setDescription('The routing mechanism via which this route was learned.\n               Inclusion of values for gateway routing protocols is\n               not intended to imply that hosts should support those\n               protocols.')
inetCidrRouteAge = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inetCidrRouteAge.setDescription("The number of seconds since this route was last updated\n               or otherwise determined to be correct.  Note that no\n               semantics of 'too old' can be implied, except through\n               knowledge of the routing protocol by which the route\n               was learned.")
inetCidrRouteNextHopAS = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 11), InetAutonomousSystemNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inetCidrRouteNextHopAS.setDescription("The Autonomous System Number of the Next Hop.  The\n               semantics of this object are determined by the routing-\n               protocol specified in the route's inetCidrRouteProto\n               value.  When this object is unknown or not relevant, its\n               value should be set to zero.")
inetCidrRouteMetric1 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 12), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inetCidrRouteMetric1.setDescription("The primary routing metric for this route.  The\n               semantics of this metric are determined by the routing-\n               protocol specified in the route's inetCidrRouteProto\n               value.  If this metric is not used, its value should be\n               set to -1.")
inetCidrRouteMetric2 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 13), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inetCidrRouteMetric2.setDescription("An alternate routing metric for this route.  The\n               semantics of this metric are determined by the routing-\n               protocol specified in the route's inetCidrRouteProto\n               value.  If this metric is not used, its value should be\n               set to -1.")
inetCidrRouteMetric3 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 14), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inetCidrRouteMetric3.setDescription("An alternate routing metric for this route.  The\n               semantics of this metric are determined by the routing-\n               protocol specified in the route's inetCidrRouteProto\n               value.  If this metric is not used, its value should be\n               set to -1.")
inetCidrRouteMetric4 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 15), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inetCidrRouteMetric4.setDescription("An alternate routing metric for this route.  The\n               semantics of this metric are determined by the routing-\n               protocol specified in the route's inetCidrRouteProto\n               value.  If this metric is not used, its value should be\n               set to -1.")
inetCidrRouteMetric5 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 16), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inetCidrRouteMetric5.setDescription("An alternate routing metric for this route.  The\n               semantics of this metric are determined by the routing-\n               protocol specified in the route's inetCidrRouteProto\n               value.  If this metric is not used, its value should be\n               set to -1.")
inetCidrRouteStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 7, 1, 17), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: inetCidrRouteStatus.setDescription('The row status variable, used according to row\n               installation and removal conventions.\n\n               A row entry cannot be modified when the status is\n               marked as active(1).')
ipForwardConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 4, 24, 5))
ipForwardGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 4, 24, 5, 1))
ipForwardCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 4, 24, 5, 2))
ipForwardFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 4, 24, 5, 2, 3)).setObjects(*(("IP-FORWARD-MIB", "inetForwardCidrRouteGroup"),))
if mibBuilder.loadTexts: ipForwardFullCompliance.setDescription('When this MIB is implemented for read-create, the\n               implementation can claim full compliance.\n\n               There are a number of INDEX objects that cannot be\n               represented in the form of OBJECT clauses in SMIv2,\n               but for which there are compliance requirements,\n               expressed in OBJECT clause form in this description:\n\n               -- OBJECT      inetCidrRouteDestType\n               -- SYNTAX      InetAddressType (ipv4(1), ipv6(2),\n               --                              ipv4z(3), ipv6z(4))\n               -- DESCRIPTION\n               --     This MIB requires support for global and\n               --     non-global ipv4 and ipv6 addresses.\n               --\n               -- OBJECT      inetCidrRouteDest\n               -- SYNTAX      InetAddress (SIZE (4 | 8 | 16 | 20))\n               -- DESCRIPTION\n               --     This MIB requires support for global and\n               --     non-global IPv4 and IPv6 addresses.\n               --\n               -- OBJECT      inetCidrRouteNextHopType\n               -- SYNTAX      InetAddressType (unknown(0), ipv4(1),\n               --                              ipv6(2), ipv4z(3)\n               --                              ipv6z(4))\n               -- DESCRIPTION\n               --     This MIB requires support for global and\n               --     non-global ipv4 and ipv6 addresses.\n               --\n               -- OBJECT      inetCidrRouteNextHop\n               -- SYNTAX      InetAddress (SIZE (0 | 4 | 8 | 16 | 20))\n               -- DESCRIPTION\n               --     This MIB requires support for global and\n               --     non-global IPv4 and IPv6 addresses.\n               ')
ipForwardReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 4, 24, 5, 2, 4)).setObjects(*(("IP-FORWARD-MIB", "inetForwardCidrRouteGroup"),))
if mibBuilder.loadTexts: ipForwardReadOnlyCompliance.setDescription('When this MIB is implemented without support for read-\n               create (i.e., in read-only mode), the implementation can\n               claim read-only compliance.')
inetForwardCidrRouteGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 4, 24, 5, 1, 4)).setObjects(*(("IP-FORWARD-MIB", "inetCidrRouteDiscards"), ("IP-FORWARD-MIB", "inetCidrRouteIfIndex"), ("IP-FORWARD-MIB", "inetCidrRouteType"), ("IP-FORWARD-MIB", "inetCidrRouteProto"), ("IP-FORWARD-MIB", "inetCidrRouteAge"), ("IP-FORWARD-MIB", "inetCidrRouteNextHopAS"), ("IP-FORWARD-MIB", "inetCidrRouteMetric1"), ("IP-FORWARD-MIB", "inetCidrRouteMetric2"), ("IP-FORWARD-MIB", "inetCidrRouteMetric3"), ("IP-FORWARD-MIB", "inetCidrRouteMetric4"), ("IP-FORWARD-MIB", "inetCidrRouteMetric5"), ("IP-FORWARD-MIB", "inetCidrRouteStatus"), ("IP-FORWARD-MIB", "inetCidrRouteNumber"),))
if mibBuilder.loadTexts: inetForwardCidrRouteGroup.setDescription('The IP version-independent CIDR Route Table.')
ipCidrRouteNumber = MibScalar((1, 3, 6, 1, 2, 1, 4, 24, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCidrRouteNumber.setDescription('The number of current ipCidrRouteTable entries that are\n               not invalid.  This object is deprecated in favor of\n               inetCidrRouteNumber and the inetCidrRouteTable.')
ipCidrRouteTable = MibTable((1, 3, 6, 1, 2, 1, 4, 24, 4), )
if mibBuilder.loadTexts: ipCidrRouteTable.setDescription("This entity's IP Routing table.  This table has been\n               deprecated in favor of the IP version neutral\n               inetCidrRouteTable.")
ipCidrRouteEntry = MibTableRow((1, 3, 6, 1, 2, 1, 4, 24, 4, 1), ).setIndexNames((0, "IP-FORWARD-MIB", "ipCidrRouteDest"), (0, "IP-FORWARD-MIB", "ipCidrRouteMask"), (0, "IP-FORWARD-MIB", "ipCidrRouteTos"), (0, "IP-FORWARD-MIB", "ipCidrRouteNextHop"))
if mibBuilder.loadTexts: ipCidrRouteEntry.setDescription('A particular route to a particular destination, under a\n               particular policy.')
ipCidrRouteDest = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCidrRouteDest.setDescription('The destination IP address of this route.\n\n               This object may not take a Multicast (Class D) address\n               value.\n\n               Any assignment (implicit or otherwise) of an instance\n               of this object to a value x must be rejected if the\n               bitwise logical-AND of x with the value of the\n               corresponding instance of the ipCidrRouteMask object is\n               not equal to x.')
ipCidrRouteMask = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCidrRouteMask.setDescription('Indicate the mask to be logical-ANDed with the\n               destination address before being compared to the value\n               in the ipCidrRouteDest field.  For those systems that\n               do not support arbitrary subnet masks, an agent\n               constructs the value of the ipCidrRouteMask by\n               reference to the IP Address Class.\n\n               Any assignment (implicit or otherwise) of an instance\n               of this object to a value x must be rejected if the\n               bitwise logical-AND of x with the value of the\n               corresponding instance of the ipCidrRouteDest object is\n               not equal to ipCidrRouteDest.')
ipCidrRouteTos = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCidrRouteTos.setDescription('The policy specifier is the IP TOS Field.  The encoding\n               of IP TOS is as specified by the following convention.\n               Zero indicates the default path if no more specific\n               policy applies.\n\n               +-----+-----+-----+-----+-----+-----+-----+-----+\n               |                 |                       |     |\n               |   PRECEDENCE    |    TYPE OF SERVICE    |  0  |\n               |                 |                       |     |\n               +-----+-----+-----+-----+-----+-----+-----+-----+\n\n                            IP TOS                IP TOS\n                  Field     Policy      Field     Policy\n                  Contents    Code      Contents    Code\n                  0 0 0 0  ==>   0      0 0 0 1  ==>   2\n                  0 0 1 0  ==>   4      0 0 1 1  ==>   6\n                  0 1 0 0  ==>   8      0 1 0 1  ==>  10\n                  0 1 1 0  ==>  12      0 1 1 1  ==>  14\n                  1 0 0 0  ==>  16      1 0 0 1  ==>  18\n                  1 0 1 0  ==>  20      1 0 1 1  ==>  22\n                  1 1 0 0  ==>  24      1 1 0 1  ==>  26\n                  1 1 1 0  ==>  28      1 1 1 1  ==>  30')
ipCidrRouteNextHop = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCidrRouteNextHop.setDescription('On remote routes, the address of the next system en\n               route; Otherwise, 0.0.0.0.')
ipCidrRouteIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipCidrRouteIfIndex.setDescription('The ifIndex value that identifies the local interface\n               through which the next hop of this route should be\n               reached.')
ipCidrRouteType = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4,))).clone(namedValues=NamedValues(("other", 1), ("reject", 2), ("local", 3), ("remote", 4),))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipCidrRouteType.setDescription('The type of route.  Note that local(3) refers to a\n               route for which the next hop is the final destination;\n               remote(4) refers to a route for which the next hop is\n               not the final destination.\n\n               Routes that do not result in traffic forwarding or\n               rejection should not be displayed, even if the\n               implementation keeps them stored internally.\n\n               reject (2) refers to a route that, if matched,\n               discards the message as unreachable.  This is used in\n               some protocols as a means of correctly aggregating\n               routes.')
ipCidrRouteProto = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("netmgmt", 3), ("icmp", 4), ("egp", 5), ("ggp", 6), ("hello", 7), ("rip", 8), ("isIs", 9), ("esIs", 10), ("ciscoIgrp", 11), ("bbnSpfIgp", 12), ("ospf", 13), ("bgp", 14), ("idpr", 15), ("ciscoEigrp", 16),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCidrRouteProto.setDescription('The routing mechanism via which this route was learned.\n               Inclusion of values for gateway routing protocols is\n               not intended to imply that hosts should support those\n               protocols.')
ipCidrRouteAge = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCidrRouteAge.setDescription("The number of seconds since this route was last updated\n               or otherwise determined to be correct.  Note that no\n               semantics of `too old' can be implied, except through\n               knowledge of the routing protocol by which the route\n               was learned.")
ipCidrRouteInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 9), ObjectIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipCidrRouteInfo.setDescription("A reference to MIB definitions specific to the\n               particular routing protocol that is responsible for\n               this route, as determined by the value specified in the\n               route's ipCidrRouteProto value.  If this information is\n               not present, its value should be set to the OBJECT\n               IDENTIFIER { 0 0 }, which is a syntactically valid\n               object identifier, and any implementation conforming to\n               ASN.1 and the Basic Encoding Rules must be able to\n               generate and recognize this value.")
ipCidrRouteNextHopAS = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipCidrRouteNextHopAS.setDescription("The Autonomous System Number of the Next Hop.  The\n               semantics of this object are determined by the routing-\n               protocol specified in the route's ipCidrRouteProto\n               value.  When this object is unknown or not relevant, its\n               value should be set to zero.")
ipCidrRouteMetric1 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 11), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipCidrRouteMetric1.setDescription("The primary routing metric for this route.  The\n               semantics of this metric are determined by the routing-\n               protocol specified in the route's ipCidrRouteProto\n               value.  If this metric is not used, its value should be\n               set to -1.")
ipCidrRouteMetric2 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 12), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipCidrRouteMetric2.setDescription("An alternate routing metric for this route.  The\n               semantics of this metric are determined by the routing-\n               protocol specified in the route's ipCidrRouteProto\n               value.  If this metric is not used, its value should be\n               set to -1.")
ipCidrRouteMetric3 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 13), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipCidrRouteMetric3.setDescription("An alternate routing metric for this route.  The\n               semantics of this metric are determined by the routing-\n               protocol specified in the route's ipCidrRouteProto\n               value.  If this metric is not used, its value should be\n               set to -1.")
ipCidrRouteMetric4 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 14), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipCidrRouteMetric4.setDescription("An alternate routing metric for this route.  The\n               semantics of this metric are determined by the routing-\n               protocol specified in the route's ipCidrRouteProto\n               value.  If this metric is not used, its value should be\n               set to -1.")
ipCidrRouteMetric5 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 15), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipCidrRouteMetric5.setDescription("An alternate routing metric for this route.  The\n               semantics of this metric are determined by the routing-\n               protocol specified in the route's ipCidrRouteProto\n               value.  If this metric is not used, its value should be\n               set to -1.")
ipCidrRouteStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 4, 1, 16), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipCidrRouteStatus.setDescription('The row status variable, used according to row\n               installation and removal conventions.')
ipForwardCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 4, 24, 5, 2, 1)).setObjects(*(("IP-FORWARD-MIB", "ipForwardCidrRouteGroup"),))
if mibBuilder.loadTexts: ipForwardCompliance.setDescription('The compliance statement for SNMPv2 entities that\n               implement the ipForward MIB.\n\n               This compliance statement has been deprecated and\n               replaced with ipForwardFullCompliance and\n               ipForwardReadOnlyCompliance.')
ipForwardCidrRouteGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 4, 24, 5, 1, 3)).setObjects(*(("IP-FORWARD-MIB", "ipCidrRouteNumber"), ("IP-FORWARD-MIB", "ipCidrRouteDest"), ("IP-FORWARD-MIB", "ipCidrRouteMask"), ("IP-FORWARD-MIB", "ipCidrRouteTos"), ("IP-FORWARD-MIB", "ipCidrRouteNextHop"), ("IP-FORWARD-MIB", "ipCidrRouteIfIndex"), ("IP-FORWARD-MIB", "ipCidrRouteType"), ("IP-FORWARD-MIB", "ipCidrRouteProto"), ("IP-FORWARD-MIB", "ipCidrRouteAge"), ("IP-FORWARD-MIB", "ipCidrRouteInfo"), ("IP-FORWARD-MIB", "ipCidrRouteNextHopAS"), ("IP-FORWARD-MIB", "ipCidrRouteMetric1"), ("IP-FORWARD-MIB", "ipCidrRouteMetric2"), ("IP-FORWARD-MIB", "ipCidrRouteMetric3"), ("IP-FORWARD-MIB", "ipCidrRouteMetric4"), ("IP-FORWARD-MIB", "ipCidrRouteMetric5"), ("IP-FORWARD-MIB", "ipCidrRouteStatus"),))
if mibBuilder.loadTexts: ipForwardCidrRouteGroup.setDescription('The CIDR Route Table.\n\n               This group has been deprecated and replaced with\n               inetForwardCidrRouteGroup.')
ipForwardNumber = MibScalar((1, 3, 6, 1, 2, 1, 4, 24, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipForwardNumber.setDescription('The number of current ipForwardTable entries that are\n               not invalid.')
ipForwardTable = MibTable((1, 3, 6, 1, 2, 1, 4, 24, 2), )
if mibBuilder.loadTexts: ipForwardTable.setDescription("This entity's IP Routing table.")
ipForwardEntry = MibTableRow((1, 3, 6, 1, 2, 1, 4, 24, 2, 1), ).setIndexNames((0, "IP-FORWARD-MIB", "ipForwardDest"), (0, "IP-FORWARD-MIB", "ipForwardProto"), (0, "IP-FORWARD-MIB", "ipForwardPolicy"), (0, "IP-FORWARD-MIB", "ipForwardNextHop"))
if mibBuilder.loadTexts: ipForwardEntry.setDescription('A particular route to a particular destination, under a\n               particular policy.')
ipForwardDest = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipForwardDest.setDescription('The destination IP address of this route.  An entry\n               with a value of 0.0.0.0 is considered a default route.\n\n               This object may not take a Multicast (Class D) address\n               value.\n\n               Any assignment (implicit or otherwise) of an instance\n               of this object to a value x must be rejected if the\n               bitwise logical-AND of x with the value of the\n               corresponding instance of the ipForwardMask object is\n               not equal to x.')
ipForwardMask = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 2), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipForwardMask.setDescription('Indicate the mask to be logical-ANDed with the\n               destination address before being compared to the value\n               in the ipForwardDest field.  For those systems that do\n               not support arbitrary subnet masks, an agent constructs\n               the value of the ipForwardMask by reference to the IP\n               Address Class.\n\n               Any assignment (implicit or otherwise) of an instance\n               of this object to a value x must be rejected if the\n               bitwise logical-AND of x with the value of the\n               corresponding instance of the ipForwardDest object is\n               not equal to ipForwardDest.')
ipForwardPolicy = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0,2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipForwardPolicy.setDescription("The general set of conditions that would cause\n               the selection of one multipath route (set of\n               next hops for a given destination) is referred\n               to as 'policy'.\n\n               Unless the mechanism indicated by ipForwardProto\n               specifies otherwise, the policy specifier is\n               the IP TOS Field.  The encoding of IP TOS is as\n               specified by the following convention.  Zero\n               indicates the default path if no more specific\n               policy applies.\n\n               +-----+-----+-----+-----+-----+-----+-----+-----+\n               |                 |                       |     |\n               |   PRECEDENCE    |    TYPE OF SERVICE    |  0  |\n               |                 |                       |     |\n               +-----+-----+-----+-----+-----+-----+-----+-----+\n\n                            IP TOS                IP TOS\n                  Field     Policy      Field     Policy\n                  Contents    Code      Contents    Code\n                  0 0 0 0  ==>   0      0 0 0 1  ==>   2\n                  0 0 1 0  ==>   4      0 0 1 1  ==>   6\n                  0 1 0 0  ==>   8      0 1 0 1  ==>  10\n                  0 1 1 0  ==>  12      0 1 1 1  ==>  14\n                  1 0 0 0  ==>  16      1 0 0 1  ==>  18\n                  1 0 1 0  ==>  20      1 0 1 1  ==>  22\n                  1 1 0 0  ==>  24      1 1 0 1  ==>  26\n                  1 1 1 0  ==>  28      1 1 1 1  ==>  30\n\n               Protocols defining 'policy' otherwise must either\n               define a set of values that are valid for\n               this object or must implement an integer-instanced\n               policy table for which this object's\n               value acts as an index.")
ipForwardNextHop = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipForwardNextHop.setDescription('On remote routes, the address of the next system en\n               route; otherwise, 0.0.0.0.')
ipForwardIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipForwardIfIndex.setDescription('The ifIndex value that identifies the local interface\n               through which the next hop of this route should be\n               reached.')
ipForwardType = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4,))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("local", 3), ("remote", 4),)).clone('invalid')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipForwardType.setDescription('The type of route.  Note that local(3) refers to a\n               route for which the next hop is the final destination;\n               remote(4) refers to a route for which the next hop is\n               not the final destination.\n\n               Setting this object to the value invalid(2) has the\n               effect of invalidating the corresponding entry in the\n               ipForwardTable object.  That is, it effectively\n               disassociates the destination identified with said\n               entry from the route identified with said entry.  It is\n               an implementation-specific matter as to whether the\n               agent removes an invalidated entry from the table.\n               Accordingly, management stations must be prepared to\n               receive tabular information from agents that\n               corresponds to entries not currently in use.  Proper\n               interpretation of such entries requires examination of\n               the relevant ipForwardType object.')
ipForwardProto = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("netmgmt", 3), ("icmp", 4), ("egp", 5), ("ggp", 6), ("hello", 7), ("rip", 8), ("is-is", 9), ("es-is", 10), ("ciscoIgrp", 11), ("bbnSpfIgp", 12), ("ospf", 13), ("bgp", 14), ("idpr", 15),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipForwardProto.setDescription('The routing mechanism via which this route was learned.\n               Inclusion of values for gateway routing protocols is\n               not intended to imply that hosts should support those\n               protocols.')
ipForwardAge = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipForwardAge.setDescription("The number of seconds since this route was last updated\n               or otherwise determined to be correct.  Note that no\n               semantics of `too old' can be implied except through\n               knowledge of the routing protocol by which the route\n               was learned.")
ipForwardInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 9), ObjectIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipForwardInfo.setDescription("A reference to MIB definitions specific to the\n               particular routing protocol that is responsible for\n               this route, as determined by the value specified in the\n               route's ipForwardProto value.  If this information is\n               not present, its value should be set to the OBJECT\n               IDENTIFIER { 0 0 }, which is a syntactically valid\n               object identifier, and any implementation conforming to\n               ASN.1 and the Basic Encoding Rules must be able to\n               generate and recognize this value.")
ipForwardNextHopAS = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipForwardNextHopAS.setDescription('The Autonomous System Number of the Next Hop.  When\n               this is unknown or not relevant to the protocol\n               indicated by ipForwardProto, zero.')
ipForwardMetric1 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 11), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipForwardMetric1.setDescription("The primary routing metric for this route.  The\n               semantics of this metric are determined by the routing-\n               protocol specified in the route's ipForwardProto value.\n               If this metric is not used, its value should be set to\n               -1.")
ipForwardMetric2 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 12), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipForwardMetric2.setDescription("An alternate routing metric for this route.  The\n               semantics of this metric are determined by the routing-\n               protocol specified in the route's ipForwardProto value.\n               If this metric is not used, its value should be set to\n               -1.")
ipForwardMetric3 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 13), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipForwardMetric3.setDescription("An alternate routing metric for this route.  The\n               semantics of this metric are determined by the routing-\n               protocol specified in the route's ipForwardProto value.\n               If this metric is not used, its value should be set to\n               -1.")
ipForwardMetric4 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 14), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipForwardMetric4.setDescription("An alternate routing metric for this route.  The\n               semantics of this metric are determined by the routing-\n               protocol specified in the route's ipForwardProto value.\n               If this metric is not used, its value should be set to\n               -1.")
ipForwardMetric5 = MibTableColumn((1, 3, 6, 1, 2, 1, 4, 24, 2, 1, 15), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipForwardMetric5.setDescription("An alternate routing metric for this route.  The\n               semantics of this metric are determined by the routing-\n               protocol specified in the route's ipForwardProto value.\n               If this metric is not used, its value should be set to\n               -1.")
ipForwardOldCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 4, 24, 5, 2, 2)).setObjects(*(("IP-FORWARD-MIB", "ipForwardMultiPathGroup"),))
if mibBuilder.loadTexts: ipForwardOldCompliance.setDescription('The compliance statement for SNMP entities that\n               implement the ipForward MIB.')
ipForwardMultiPathGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 4, 24, 5, 1, 2)).setObjects(*(("IP-FORWARD-MIB", "ipForwardNumber"), ("IP-FORWARD-MIB", "ipForwardDest"), ("IP-FORWARD-MIB", "ipForwardMask"), ("IP-FORWARD-MIB", "ipForwardPolicy"), ("IP-FORWARD-MIB", "ipForwardNextHop"), ("IP-FORWARD-MIB", "ipForwardIfIndex"), ("IP-FORWARD-MIB", "ipForwardType"), ("IP-FORWARD-MIB", "ipForwardProto"), ("IP-FORWARD-MIB", "ipForwardAge"), ("IP-FORWARD-MIB", "ipForwardInfo"), ("IP-FORWARD-MIB", "ipForwardNextHopAS"), ("IP-FORWARD-MIB", "ipForwardMetric1"), ("IP-FORWARD-MIB", "ipForwardMetric2"), ("IP-FORWARD-MIB", "ipForwardMetric3"), ("IP-FORWARD-MIB", "ipForwardMetric4"), ("IP-FORWARD-MIB", "ipForwardMetric5"),))
if mibBuilder.loadTexts: ipForwardMultiPathGroup.setDescription('IP Multipath Route Table.')
mibBuilder.exportSymbols("IP-FORWARD-MIB", inetCidrRouteAge=inetCidrRouteAge, ipForwardFullCompliance=ipForwardFullCompliance, inetCidrRouteDest=inetCidrRouteDest, ipCidrRouteInfo=ipCidrRouteInfo, ipForwardNextHop=ipForwardNextHop, ipForwardConformance=ipForwardConformance, PYSNMP_MODULE_ID=ipForward, inetCidrRouteMetric5=inetCidrRouteMetric5, inetCidrRouteEntry=inetCidrRouteEntry, inetCidrRouteIfIndex=inetCidrRouteIfIndex, ipForwardNextHopAS=ipForwardNextHopAS, ipCidrRouteIfIndex=ipCidrRouteIfIndex, inetCidrRouteMetric2=inetCidrRouteMetric2, ipForwardInfo=ipForwardInfo, ipForwardDest=ipForwardDest, inetCidrRouteMetric1=inetCidrRouteMetric1, ipForwardEntry=ipForwardEntry, inetCidrRouteNextHop=inetCidrRouteNextHop, ipCidrRouteNextHopAS=ipCidrRouteNextHopAS, ipCidrRouteNumber=ipCidrRouteNumber, ipForwardMask=ipForwardMask, ipForwardPolicy=ipForwardPolicy, ipCidrRouteProto=ipCidrRouteProto, ipCidrRouteMetric2=ipCidrRouteMetric2, ipForward=ipForward, ipCidrRouteMetric4=ipCidrRouteMetric4, inetForwardCidrRouteGroup=inetForwardCidrRouteGroup, ipForwardMetric3=ipForwardMetric3, ipForwardCompliances=ipForwardCompliances, ipForwardReadOnlyCompliance=ipForwardReadOnlyCompliance, ipCidrRouteMask=ipCidrRouteMask, ipForwardIfIndex=ipForwardIfIndex, ipForwardCompliance=ipForwardCompliance, ipCidrRouteMetric3=ipCidrRouteMetric3, ipForwardProto=ipForwardProto, ipForwardMetric4=ipForwardMetric4, inetCidrRouteDiscards=inetCidrRouteDiscards, ipCidrRouteNextHop=ipCidrRouteNextHop, ipForwardTable=ipForwardTable, ipCidrRouteAge=ipCidrRouteAge, inetCidrRouteNextHopAS=inetCidrRouteNextHopAS, inetCidrRouteTable=inetCidrRouteTable, inetCidrRoutePolicy=inetCidrRoutePolicy, ipCidrRouteType=ipCidrRouteType, ipForwardOldCompliance=ipForwardOldCompliance, ipForwardGroups=ipForwardGroups, ipForwardMetric1=ipForwardMetric1, ipForwardNumber=ipForwardNumber, inetCidrRouteProto=inetCidrRouteProto, ipForwardMetric2=ipForwardMetric2, ipForwardAge=ipForwardAge, inetCidrRouteMetric3=inetCidrRouteMetric3, inetCidrRoutePfxLen=inetCidrRoutePfxLen, ipCidrRouteEntry=ipCidrRouteEntry, ipCidrRouteMetric5=ipCidrRouteMetric5, ipForwardType=ipForwardType, ipCidrRouteTable=ipCidrRouteTable, ipForwardMultiPathGroup=ipForwardMultiPathGroup, inetCidrRouteStatus=inetCidrRouteStatus, ipCidrRouteDest=ipCidrRouteDest, ipForwardMetric5=ipForwardMetric5, ipCidrRouteTos=ipCidrRouteTos, inetCidrRouteType=inetCidrRouteType, inetCidrRouteNumber=inetCidrRouteNumber, ipCidrRouteStatus=ipCidrRouteStatus, ipForwardCidrRouteGroup=ipForwardCidrRouteGroup, ipCidrRouteMetric1=ipCidrRouteMetric1, inetCidrRouteMetric4=inetCidrRouteMetric4, inetCidrRouteNextHopType=inetCidrRouteNextHopType, inetCidrRouteDestType=inetCidrRouteDestType)
