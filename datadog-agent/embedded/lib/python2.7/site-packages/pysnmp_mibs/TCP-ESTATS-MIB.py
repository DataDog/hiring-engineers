#
# PySNMP MIB module TCP-ESTATS-MIB (http://pysnmp.sf.net)
# ASN.1 source http://mibs.snmplabs.com:80/asn1/TCP-ESTATS-MIB
# Produced by pysmi-0.0.7 at Sun Feb 14 00:31:06 2016
# On host bldfarm platform Linux version 4.1.13-100.fc21.x86_64 by user goose
# Using Python version 3.5.0 (default, Jan  5 2016, 17:11:52) 
#
( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint")
( ZeroBasedCounter64, ) = mibBuilder.importSymbols("HCNUM-TC", "ZeroBasedCounter64")
( ZeroBasedCounter32, ) = mibBuilder.importSymbols("RMON2-MIB", "ZeroBasedCounter32")
( ModuleCompliance, ObjectGroup, NotificationGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
( MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, mib_2, Integer32, ModuleIdentity, IpAddress, Bits, ObjectIdentity, iso, NotificationType, Gauge32, Counter64, Counter32, Unsigned32, TimeTicks, ) = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "mib-2", "Integer32", "ModuleIdentity", "IpAddress", "Bits", "ObjectIdentity", "iso", "NotificationType", "Gauge32", "Counter64", "Counter32", "Unsigned32", "TimeTicks")
( DateAndTime, TextualConvention, TimeStamp, DisplayString, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "DateAndTime", "TextualConvention", "TimeStamp", "DisplayString", "TruthValue")
( tcpListenerEntry, tcpConnectionEntry, ) = mibBuilder.importSymbols("TCP-MIB", "tcpListenerEntry", "tcpConnectionEntry")
tcpEStatsMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 156)).setRevisions(("2007-05-18 00:00",))
if mibBuilder.loadTexts: tcpEStatsMIB.setLastUpdated('200705180000Z')
if mibBuilder.loadTexts: tcpEStatsMIB.setOrganization('IETF TSV Working Group')
if mibBuilder.loadTexts: tcpEStatsMIB.setContactInfo('Matt Mathis\n        John Heffner\n        Web100 Project\n        Pittsburgh Supercomputing Center\n        300 S. Craig St.\n        Pittsburgh, PA 15213\n        Email: mathis@psc.edu, jheffner@psc.edu\n\n        Rajiv Raghunarayan\n        Cisco Systems Inc.\n        San Jose, CA 95134\n        Phone: 408 853 9612\n        Email: raraghun@cisco.com\n\n        Jon Saperia\n        84 Kettell Plain Road\n        Stow, MA 01775\n        Phone: 617-201-2655\n        Email: saperia@jdscons.com ')
if mibBuilder.loadTexts: tcpEStatsMIB.setDescription('Documentation of TCP Extended Performance Instrumentation\n         variables from the Web100 project.  [Web100]\n\n         All of the objects in this MIB MUST have the same\n         persistence properties as the underlying TCP implementation.\n         On a reboot, all zero-based counters MUST be cleared, all\n         dynamically created table rows MUST be deleted, and all\n         read-write objects MUST be restored to their default values.\n\n         It is assumed that all TCP implementation have some\n         initialization code (if nothing else to set IP addresses)\n         that has the opportunity to adjust tcpEStatsConnTableLatency\n         and other read-write scalars controlling the creation of the\n         various tables, before establishing the first TCP\n         connection.  Implementations MAY also choose to make these\n         control scalars persist across reboots.\n\n         Copyright (C) The IETF Trust (2007).  This version\n         of this MIB module is a part of RFC 4898; see the RFC\n         itself for full legal notices.')
tcpEStatsNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 156, 0))
tcpEStatsMIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 156, 1))
tcpEStatsConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 156, 2))
tcpEStats = MibIdentifier((1, 3, 6, 1, 2, 1, 156, 1, 1))
tcpEStatsControl = MibIdentifier((1, 3, 6, 1, 2, 1, 156, 1, 2))
tcpEStatsScalar = MibIdentifier((1, 3, 6, 1, 2, 1, 156, 1, 3))
class TcpEStatsNegotiated(Integer32, TextualConvention):
    subtypeSpec = Integer32.subtypeSpec+ConstraintsUnion(SingleValueConstraint(1, 2, 3,))
    namedValues = NamedValues(("enabled", 1), ("selfDisabled", 2), ("peerDisabled", 3),)

tcpEStatsListenerTableLastChange = MibScalar((1, 3, 6, 1, 2, 1, 156, 1, 3, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsListenerTableLastChange.setDescription('The value of sysUpTime at the time of the last\n            creation or deletion of an entry in the tcpListenerTable.\n            If the number of entries has been unchanged since the\n            last re-initialization of the local network management\n            subsystem, then this object contains a zero value.')
tcpEStatsControlPath = MibScalar((1, 3, 6, 1, 2, 1, 156, 1, 2, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpEStatsControlPath.setDescription("Controls the activation of the TCP Path Statistics\n        table.\n\n        A value 'true' indicates that the TCP Path Statistics\n        table is active, while 'false' indicates that the\n        table is inactive.")
tcpEStatsControlStack = MibScalar((1, 3, 6, 1, 2, 1, 156, 1, 2, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpEStatsControlStack.setDescription("Controls the activation of the TCP Stack Statistics\n        table.\n\n        A value 'true' indicates that the TCP Stack Statistics\n        table is active, while 'false' indicates that the\n        table is inactive.")
tcpEStatsControlApp = MibScalar((1, 3, 6, 1, 2, 1, 156, 1, 2, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpEStatsControlApp.setDescription("Controls the activation of the TCP Application\n        Statistics table.\n\n        A value 'true' indicates that the TCP Application\n        Statistics table is active, while 'false' indicates\n        that the table is inactive.")
tcpEStatsControlTune = MibScalar((1, 3, 6, 1, 2, 1, 156, 1, 2, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpEStatsControlTune.setDescription("Controls the activation of the TCP Tuning table.\n\n        A value 'true' indicates that the TCP Tuning\n        table is active, while 'false' indicates that the\n        table is inactive.")
tcpEStatsControlNotify = MibScalar((1, 3, 6, 1, 2, 1, 156, 1, 2, 5), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpEStatsControlNotify.setDescription("Controls the generation of all notifications defined in\n        this MIB.\n\n        A value 'true' indicates that the notifications\n        are active, while 'false' indicates that the\n        notifications are inactive.")
tcpEStatsConnTableLatency = MibScalar((1, 3, 6, 1, 2, 1, 156, 1, 2, 6), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpEStatsConnTableLatency.setDescription('Specifies the number of seconds that the entity will\n         retain entries in the TCP connection tables, after the\n         connection first enters the closed state.  The entity\n         SHOULD provide a configuration option to enable\n\n\n\n         customization of this value.  A value of 0\n         results in entries being removed from the tables as soon as\n         the connection enters the closed state.  The value of\n         this object pertains to the following tables:\n           tcpEStatsConnectIdTable\n           tcpEStatsPerfTable\n           tcpEStatsPathTable\n           tcpEStatsStackTable\n           tcpEStatsAppTable\n           tcpEStatsTuneTable')
tcpEStatsListenerTable = MibTable((1, 3, 6, 1, 2, 1, 156, 1, 1, 1), )
if mibBuilder.loadTexts: tcpEStatsListenerTable.setDescription('This table contains information about TCP Listeners,\n        in addition to the information maintained by the\n        tcpListenerTable RFC 4022.')
tcpEStatsListenerEntry = MibTableRow((1, 3, 6, 1, 2, 1, 156, 1, 1, 1, 1), )
tcpListenerEntry.registerAugmentions(("TCP-ESTATS-MIB", "tcpEStatsListenerEntry"))
tcpEStatsListenerEntry.setIndexNames(*tcpListenerEntry.getIndexNames())
if mibBuilder.loadTexts: tcpEStatsListenerEntry.setDescription('Each entry in the table contains information about\n        a specific TCP Listener.')
tcpEStatsListenerStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 1, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsListenerStartTime.setDescription('The value of sysUpTime at the time this listener was\n        established.  If the current state was entered prior to\n        the last re-initialization of the local network management\n        subsystem, then this object contains a zero value.')
tcpEStatsListenerSynRcvd = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 1, 1, 2), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsListenerSynRcvd.setDescription('The number of SYNs which have been received for this\n        listener.  The total number of failed connections for\n        all reasons can be estimated to be tcpEStatsListenerSynRcvd\n        minus tcpEStatsListenerAccepted and\n        tcpEStatsListenerCurBacklog.')
tcpEStatsListenerInitial = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 1, 1, 3), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsListenerInitial.setDescription('The total number of connections for which the Listener\n       has allocated initial state and placed the\n       connection in the backlog.  This may happen in the\n       SYN-RCVD or ESTABLISHED states, depending on the\n       implementation.')
tcpEStatsListenerEstablished = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 1, 1, 4), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsListenerEstablished.setDescription('The number of connections that have been established to\n        this endpoint (e.g., the number of first ACKs that have\n        been received for this listener).')
tcpEStatsListenerAccepted = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 1, 1, 5), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsListenerAccepted.setDescription('The total number of connections for which the Listener\n       has successfully issued an accept, removing the connection\n       from the backlog.')
tcpEStatsListenerExceedBacklog = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 1, 1, 6), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsListenerExceedBacklog.setDescription('The total number of connections dropped from the\n      backlog by this listener due to all reasons.  This\n      includes all connections that are allocated initial\n      resources, but are not accepted for some reason.')
tcpEStatsListenerHCSynRcvd = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 1, 1, 7), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsListenerHCSynRcvd.setDescription('The number of SYNs that have been received for this\n        listener on systems that can process (or reject) more\n        than 1 million connections per second.  See\n        tcpEStatsListenerSynRcvd.')
tcpEStatsListenerHCInitial = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 1, 1, 8), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsListenerHCInitial.setDescription('The total number of connections for which the Listener\n       has allocated initial state and placed the connection\n       in the backlog on systems that can process (or reject)\n       more than 1 million connections per second.  See\n       tcpEStatsListenerInitial.')
tcpEStatsListenerHCEstablished = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 1, 1, 9), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsListenerHCEstablished.setDescription('The number of connections that have been established to\n        this endpoint on systems that can process (or reject) more\n        than 1 million connections per second.  See\n        tcpEStatsListenerEstablished.')
tcpEStatsListenerHCAccepted = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 1, 1, 10), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsListenerHCAccepted.setDescription('The total number of connections for which the Listener\n       has successfully issued an accept, removing the connection\n       from the backlog on systems that can process (or reject)\n       more than 1 million connections per second.  See\n       tcpEStatsListenerAccepted.')
tcpEStatsListenerHCExceedBacklog = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 1, 1, 11), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsListenerHCExceedBacklog.setDescription('The total number of connections dropped from the\n      backlog by this listener due to all reasons on\n      systems that can process (or reject) more than\n      1 million connections per second.  See\n      tcpEStatsListenerExceedBacklog.')
tcpEStatsListenerCurConns = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 1, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsListenerCurConns.setDescription('The current number of connections in the ESTABLISHED\n       state, which have also been accepted.  It excludes\n       connections that have been established but not accepted\n       because they are still subject to being discarded to\n       shed load without explicit action by either endpoint.')
tcpEStatsListenerMaxBacklog = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 1, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsListenerMaxBacklog.setDescription('The maximum number of connections allowed in the\n       backlog at one time.')
tcpEStatsListenerCurBacklog = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 1, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsListenerCurBacklog.setDescription('The current number of connections that are in the backlog.\n       This gauge includes connections in ESTABLISHED or\n       SYN-RECEIVED states for which the Listener has not yet\n       issued an accept.\n\n       If this listener is using some technique to implicitly\n       represent the SYN-RECEIVED states (e.g., by\n       cryptographically encoding the state information in the\n       initial sequence number, ISS), it MAY elect to exclude\n       connections in the SYN-RECEIVED state from the backlog.')
tcpEStatsListenerCurEstabBacklog = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 1, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsListenerCurEstabBacklog.setDescription('The current number of connections in the backlog that are\n       in the ESTABLISHED state, but for which the Listener has\n       not yet issued an accept.')
tcpEStatsConnectIdTable = MibTable((1, 3, 6, 1, 2, 1, 156, 1, 1, 2), )
if mibBuilder.loadTexts: tcpEStatsConnectIdTable.setDescription('This table maps information that uniquely identifies\n        each active TCP connection to the connection ID used by\n\n\n\n        other tables in this MIB Module.  It is an extension of\n        tcpConnectionTable in RFC 4022.\n\n        Entries are retained in this table for the number of\n        seconds indicated by the tcpEStatsConnTableLatency\n        object, after the TCP connection first enters the closed\n        state.')
tcpEStatsConnectIdEntry = MibTableRow((1, 3, 6, 1, 2, 1, 156, 1, 1, 2, 1), )
tcpConnectionEntry.registerAugmentions(("TCP-ESTATS-MIB", "tcpEStatsConnectIdEntry"))
tcpEStatsConnectIdEntry.setIndexNames(*tcpConnectionEntry.getIndexNames())
if mibBuilder.loadTexts: tcpEStatsConnectIdEntry.setDescription('Each entry in this table maps a TCP connection\n        4-tuple to a connection index.')
tcpEStatsConnectIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1,4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsConnectIndex.setDescription('A unique integer value assigned to each TCP Connection\n        entry.\n\n        The RECOMMENDED algorithm is to begin at 1 and increase to\n        some implementation-specific maximum value and then start\n        again at 1 skipping values already in use.')
tcpEStatsPerfTable = MibTable((1, 3, 6, 1, 2, 1, 156, 1, 1, 3), )
if mibBuilder.loadTexts: tcpEStatsPerfTable.setDescription('This table contains objects that are useful for\n\n\n\n        measuring TCP performance and first line problem\n        diagnosis.  Most objects in this table directly expose\n        some TCP state variable or are easily implemented as\n        simple functions (e.g., the maximum value) of TCP\n        state variables.\n\n        Entries are retained in this table for the number of\n        seconds indicated by the tcpEStatsConnTableLatency\n        object, after the TCP connection first enters the closed\n        state.')
tcpEStatsPerfEntry = MibTableRow((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1), ).setIndexNames((0, "TCP-ESTATS-MIB", "tcpEStatsConnectIndex"))
if mibBuilder.loadTexts: tcpEStatsPerfEntry.setDescription('Each entry in this table has information about the\n        characteristics of each active and recently closed TCP\n        connection.')
tcpEStatsPerfSegsOut = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 1), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfSegsOut.setDescription('The total number of segments sent.')
tcpEStatsPerfDataSegsOut = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 2), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfDataSegsOut.setDescription('The number of segments sent containing a positive length\n        data segment.')
tcpEStatsPerfDataOctetsOut = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 3), ZeroBasedCounter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfDataOctetsOut.setDescription('The number of octets of data contained in transmitted\n        segments, including retransmitted data.  Note that this does\n        not include TCP headers.')
tcpEStatsPerfHCDataOctetsOut = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 4), ZeroBasedCounter64()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfHCDataOctetsOut.setDescription('The number of octets of data contained in transmitted\n        segments, including retransmitted data, on systems that can\n        transmit more than 10 million bits per second.  Note that\n        this does not include TCP headers.')
tcpEStatsPerfSegsRetrans = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 5), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfSegsRetrans.setDescription('The number of segments transmitted containing at least some\n        retransmitted data.')
tcpEStatsPerfOctetsRetrans = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 6), ZeroBasedCounter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfOctetsRetrans.setDescription('The number of octets retransmitted.')
tcpEStatsPerfSegsIn = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 7), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfSegsIn.setDescription('The total number of segments received.')
tcpEStatsPerfDataSegsIn = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 8), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfDataSegsIn.setDescription('The number of segments received containing a positive\n\n\n\n        length data segment.')
tcpEStatsPerfDataOctetsIn = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 9), ZeroBasedCounter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfDataOctetsIn.setDescription('The number of octets contained in received data segments,\n        including retransmitted data.  Note that this does not\n        include TCP headers.')
tcpEStatsPerfHCDataOctetsIn = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 10), ZeroBasedCounter64()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfHCDataOctetsIn.setDescription('The number of octets contained in received data segments,\n        including retransmitted data, on systems that can receive\n        more than 10 million bits per second.  Note that this does\n        not include TCP headers.')
tcpEStatsPerfElapsedSecs = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 11), ZeroBasedCounter32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfElapsedSecs.setDescription('The seconds part of the time elapsed between\n        tcpEStatsPerfStartTimeStamp and the most recent protocol\n        event (segment sent or received).')
tcpEStatsPerfElapsedMicroSecs = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 12), ZeroBasedCounter32()).setUnits('microseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfElapsedMicroSecs.setDescription('The micro-second part of time elapsed between\n        tcpEStatsPerfStartTimeStamp to the most recent protocol\n        event (segment sent or received).  This may be updated in\n        whatever time granularity is the system supports.')
tcpEStatsPerfStartTimeStamp = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 13), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfStartTimeStamp.setDescription('Time at which this row was created and all\n        ZeroBasedCounters in the row were initialized to zero.')
tcpEStatsPerfCurMSS = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 14), Gauge32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfCurMSS.setDescription('The current maximum segment size (MSS), in octets.')
tcpEStatsPerfPipeSize = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 15), Gauge32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfPipeSize.setDescription("The TCP senders current estimate of the number of\n        unacknowledged data octets in the network.\n\n        While not in recovery (e.g., while the receiver is not\n        reporting missing data to the sender), this is precisely the\n        same as 'Flight size' as defined in RFC 2581, which can be\n        computed as SND.NXT minus SND.UNA. [RFC793]\n\n        During recovery, the TCP sender has incomplete information\n        about the state of the network (e.g., which segments are\n        lost vs reordered, especially if the return path is also\n        dropping TCP acknowledgments).  Current TCP standards do not\n        mandate any specific algorithm for estimating the number of\n        unacknowledged data octets in the network.\n\n        RFC 3517 describes a conservative algorithm to use SACK\n\n\n\n        information to estimate the number of unacknowledged data\n        octets in the network. tcpEStatsPerfPipeSize object SHOULD\n        be the same as 'pipe' as defined in RFC 3517 if it is\n        implemented. (Note that while not in recovery the pipe\n        algorithm yields the same values as flight size).\n\n        If RFC 3517 is not implemented, the data octets in flight\n        SHOULD be estimated as SND.NXT minus SND.UNA adjusted by\n        some measure of the data that has left the network and\n        retransmitted data.  For example, with Reno or NewReno style\n        TCP, the number of duplicate acknowledgment is used to\n        count the number of segments that have left the network.\n        That is,\n        PipeSize=SND.NXT-SND.UNA+(retransmits-dupacks)*CurMSS")
tcpEStatsPerfMaxPipeSize = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 16), Gauge32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfMaxPipeSize.setDescription('The maximum value of tcpEStatsPerfPipeSize, for this\n        connection.')
tcpEStatsPerfSmoothedRTT = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 17), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfSmoothedRTT.setDescription('The smoothed round trip time used in calculation of the\n        RTO. See SRTT in [RFC2988].')
tcpEStatsPerfCurRTO = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 18), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfCurRTO.setDescription('The current value of the retransmit timer RTO.')
tcpEStatsPerfCongSignals = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 19), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfCongSignals.setDescription('The number of multiplicative downward congestion window\n        adjustments due to all forms of congestion signals,\n        including Fast Retransmit, Explicit Congestion Notification\n        (ECN), and timeouts.  This object summarizes all events that\n        invoke the MD portion of Additive Increase Multiplicative\n        Decrease (AIMD) congestion control, and as such is the best\n        indicator of how a cwnd is being affected by congestion.\n\n        Note that retransmission timeouts multiplicatively reduce\n        the window implicitly by setting ssthresh, and SHOULD be\n        included in tcpEStatsPerfCongSignals.  In order to minimize\n        spurious congestion indications due to out-of-order\n        segments, tcpEStatsPerfCongSignals SHOULD be incremented in\n        association with the Fast Retransmit algorithm.')
tcpEStatsPerfCurCwnd = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 20), Gauge32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfCurCwnd.setDescription('The current congestion window, in octets.')
tcpEStatsPerfCurSsthresh = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 21), Gauge32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfCurSsthresh.setDescription('The current slow start threshold in octets.')
tcpEStatsPerfTimeouts = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 22), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfTimeouts.setDescription('The number of times the retransmit timeout has expired when\n        the RTO backoff multiplier is equal to one.')
tcpEStatsPerfCurRwinSent = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 23), Gauge32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfCurRwinSent.setDescription('The most recent window advertisement sent, in octets.')
tcpEStatsPerfMaxRwinSent = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 24), Gauge32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfMaxRwinSent.setDescription('The maximum window advertisement sent, in octets.')
tcpEStatsPerfZeroRwinSent = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 25), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfZeroRwinSent.setDescription('The number of acknowledgments sent announcing a zero\n\n\n\n        receive window, when the previously announced window was\n        not zero.')
tcpEStatsPerfCurRwinRcvd = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 26), Gauge32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfCurRwinRcvd.setDescription('The most recent window advertisement received, in octets.')
tcpEStatsPerfMaxRwinRcvd = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 27), Gauge32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfMaxRwinRcvd.setDescription('The maximum window advertisement received, in octets.')
tcpEStatsPerfZeroRwinRcvd = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 28), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfZeroRwinRcvd.setDescription('The number of acknowledgments received announcing a zero\n        receive window, when the previously announced window was\n        not zero.')
tcpEStatsPerfSndLimTransRwin = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 31), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfSndLimTransRwin.setDescription("The number of transitions into the 'Receiver Limited' state\n        from either the 'Congestion Limited' or 'Sender Limited'\n        states.  This state is entered whenever TCP transmission\n        stops because the sender has filled the announced receiver\n        window, i.e., when SND.NXT has advanced to SND.UNA +\n        SND.WND - 1 as described in RFC 793.")
tcpEStatsPerfSndLimTransCwnd = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 32), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfSndLimTransCwnd.setDescription("The number of transitions into the 'Congestion Limited'\n        state from either the 'Receiver Limited' or 'Sender\n        Limited' states.  This state is entered whenever TCP\n        transmission stops because the sender has reached some\n        limit defined by congestion control (e.g., cwnd) or other\n        algorithms (retransmission timeouts) designed to control\n        network traffic.  See the definition of 'CONGESTION WINDOW'\n\n\n\n        in RFC 2581.")
tcpEStatsPerfSndLimTransSnd = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 33), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfSndLimTransSnd.setDescription("The number of transitions into the 'Sender Limited' state\n        from either the 'Receiver Limited' or 'Congestion Limited'\n        states.  This state is entered whenever TCP transmission\n        stops due to some sender limit such as running out of\n        application data or other resources and the Karn algorithm.\n        When TCP stops sending data for any reason, which cannot be\n        classified as Receiver Limited or Congestion Limited, it\n        MUST be treated as Sender Limited.")
tcpEStatsPerfSndLimTimeRwin = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 34), ZeroBasedCounter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfSndLimTimeRwin.setDescription("The cumulative time spent in the 'Receiver Limited' state.\n        See tcpEStatsPerfSndLimTransRwin.")
tcpEStatsPerfSndLimTimeCwnd = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 35), ZeroBasedCounter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfSndLimTimeCwnd.setDescription("The cumulative time spent in the 'Congestion Limited'\n        state.  See tcpEStatsPerfSndLimTransCwnd.  When there is a\n        retransmission timeout, it SHOULD be counted in\n        tcpEStatsPerfSndLimTimeCwnd (and not the cumulative time\n        for some other state.)")
tcpEStatsPerfSndLimTimeSnd = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 3, 1, 36), ZeroBasedCounter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPerfSndLimTimeSnd.setDescription("The cumulative time spent in the 'Sender Limited' state.\n        See tcpEStatsPerfSndLimTransSnd.")
tcpEStatsPathTable = MibTable((1, 3, 6, 1, 2, 1, 156, 1, 1, 4), )
if mibBuilder.loadTexts: tcpEStatsPathTable.setDescription('This table contains objects that can be used to infer\n        detailed behavior of the Internet path, such as the\n        extent that there is reordering, ECN bits, and if\n        RTT fluctuations are correlated to losses.\n\n        Entries are retained in this table for the number of\n        seconds indicated by the tcpEStatsConnTableLatency\n        object, after the TCP connection first enters the closed\n        state.')
tcpEStatsPathEntry = MibTableRow((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1), ).setIndexNames((0, "TCP-ESTATS-MIB", "tcpEStatsConnectIndex"))
if mibBuilder.loadTexts: tcpEStatsPathEntry.setDescription('Each entry in this table has information about the\n        characteristics of each active and recently closed TCP\n        connection.')
tcpEStatsPathRetranThresh = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathRetranThresh.setDescription('The number of duplicate acknowledgments required to trigger\n        Fast Retransmit.  Note that although this is constant in\n        traditional Reno TCP implementations, it is adaptive in\n        many newer TCPs.')
tcpEStatsPathNonRecovDAEpisodes = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 2), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathNonRecovDAEpisodes.setDescription("The number of duplicate acknowledgment episodes that did\n        not trigger a Fast Retransmit because ACK advanced prior to\n        the number of duplicate acknowledgments reaching\n        RetranThresh.\n\n\n\n\n        In many implementations this is the number of times the\n        'dupacks' counter is set to zero when it is non-zero but\n        less than RetranThresh.\n\n        Note that the change in tcpEStatsPathNonRecovDAEpisodes\n        divided by the change in tcpEStatsPerfDataSegsOut is an\n        estimate of the frequency of data reordering on the forward\n        path over some interval.")
tcpEStatsPathSumOctetsReordered = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 3), ZeroBasedCounter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathSumOctetsReordered.setDescription('The sum of the amounts SND.UNA advances on the\n        acknowledgment which ends a dup-ack episode without a\n        retransmission.\n\n        Note the change in tcpEStatsPathSumOctetsReordered divided\n        by the change in tcpEStatsPathNonRecovDAEpisodes is an\n        estimates of the average reordering distance, over some\n        interval.')
tcpEStatsPathNonRecovDA = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 4), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathNonRecovDA.setDescription("Duplicate acks (or SACKS) that did not trigger a Fast\n        Retransmit because ACK advanced prior to the number of\n        duplicate acknowledgments reaching RetranThresh.\n\n        In many implementations, this is the sum of the 'dupacks'\n        counter, just before it is set to zero because ACK advanced\n        without a Fast Retransmit.\n\n        Note that the change in tcpEStatsPathNonRecovDA divided by\n        the change in tcpEStatsPathNonRecovDAEpisodes is an\n        estimate of the average reordering distance in segments\n        over some interval.")
tcpEStatsPathSampleRTT = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 11), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathSampleRTT.setDescription('The most recent raw round trip time measurement used in\n        calculation of the RTO.')
tcpEStatsPathRTTVar = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 12), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathRTTVar.setDescription('The round trip time variation used in calculation of the\n        RTO.  See RTTVAR in [RFC2988].')
tcpEStatsPathMaxRTT = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 13), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathMaxRTT.setDescription('The maximum sampled round trip time.')
tcpEStatsPathMinRTT = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 14), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathMinRTT.setDescription('The minimum sampled round trip time.')
tcpEStatsPathSumRTT = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 15), ZeroBasedCounter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathSumRTT.setDescription('The sum of all sampled round trip times.\n\n        Note that the change in tcpEStatsPathSumRTT divided by the\n        change in tcpEStatsPathCountRTT is the mean RTT, uniformly\n        averaged over an enter interval.')
tcpEStatsPathHCSumRTT = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 16), ZeroBasedCounter64()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathHCSumRTT.setDescription('The sum of all sampled round trip times, on all systems\n        that implement multiple concurrent RTT measurements.\n\n        Note that the change in tcpEStatsPathHCSumRTT divided by\n        the change in tcpEStatsPathCountRTT is the mean RTT,\n        uniformly averaged over an enter interval.')
tcpEStatsPathCountRTT = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 17), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathCountRTT.setDescription('The number of round trip time samples included in\n        tcpEStatsPathSumRTT and tcpEStatsPathHCSumRTT.')
tcpEStatsPathMaxRTO = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 18), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathMaxRTO.setDescription('The maximum value of the retransmit timer RTO.')
tcpEStatsPathMinRTO = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 19), Gauge32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathMinRTO.setDescription('The minimum value of the retransmit timer RTO.')
tcpEStatsPathIpTtl = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 20), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathIpTtl.setDescription('The value of the TTL field carried in the most recently\n        received IP header.  This is sometimes useful to detect\n        changing or unstable routes.')
tcpEStatsPathIpTosIn = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 21), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1,1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathIpTosIn.setDescription('The value of the IPv4 Type of Service octet, or the IPv6\n        traffic class octet, carried in the most recently received\n        IP header.\n\n        This is useful to diagnose interactions between TCP and any\n        IP layer packet scheduling and delivery policy, which might\n        be in effect to implement Diffserv.')
tcpEStatsPathIpTosOut = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 22), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1,1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathIpTosOut.setDescription('The value of the IPv4 Type Of Service octet, or the IPv6\n        traffic class octet, carried in the most recently\n        transmitted IP header.\n\n        This is useful to diagnose interactions between TCP and any\n        IP layer packet scheduling and delivery policy, which might\n        be in effect to implement Diffserv.')
tcpEStatsPathPreCongSumCwnd = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 23), ZeroBasedCounter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathPreCongSumCwnd.setDescription('The sum of the values of the congestion window, in octets,\n        captured each time a congestion signal is received.  This\n        MUST be updated each time tcpEStatsPerfCongSignals is\n        incremented, such that the change in\n        tcpEStatsPathPreCongSumCwnd divided by the change in\n        tcpEStatsPerfCongSignals is the average window (over some\n        interval) just prior to a congestion signal.')
tcpEStatsPathPreCongSumRTT = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 24), ZeroBasedCounter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathPreCongSumRTT.setDescription('Sum of the last sample of the RTT (tcpEStatsPathSampleRTT)\n        prior to the received congestion signals.  This MUST be\n        updated each time tcpEStatsPerfCongSignals is incremented,\n        such that the change in tcpEStatsPathPreCongSumRTT divided by\n        the change in tcpEStatsPerfCongSignals is the average RTT\n        (over some interval) just prior to a congestion signal.')
tcpEStatsPathPostCongSumRTT = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 25), ZeroBasedCounter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathPostCongSumRTT.setDescription('Sum of the first sample of the RTT (tcpEStatsPathSampleRTT)\n        following each congestion signal.  Such that the change in\n        tcpEStatsPathPostCongSumRTT divided by the change in\n        tcpEStatsPathPostCongCountRTT is the average RTT (over some\n        interval) just after a congestion signal.')
tcpEStatsPathPostCongCountRTT = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 26), ZeroBasedCounter32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathPostCongCountRTT.setDescription('The number of RTT samples included in\n        tcpEStatsPathPostCongSumRTT such that the change in\n        tcpEStatsPathPostCongSumRTT divided by the change in\n        tcpEStatsPathPostCongCountRTT is the average RTT (over some\n        interval) just after a congestion signal.')
tcpEStatsPathECNsignals = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 27), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathECNsignals.setDescription('The number of congestion signals delivered to the TCP\n        sender via explicit congestion notification (ECN).  This is\n        typically the number of segments bearing Echo Congestion\n\n\n\n        Experienced (ECE) bits, but\n        should also include segments failing the ECN nonce check or\n        other explicit congestion signals.')
tcpEStatsPathDupAckEpisodes = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 28), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathDupAckEpisodes.setDescription('The number of Duplicate Acks Sent when prior Ack was not\n        duplicate.  This is the number of times that a contiguous\n        series of duplicate acknowledgments have been sent.\n\n        This is an indication of the number of data segments lost\n        or reordered on the path from the remote TCP endpoint to\n        the near TCP endpoint.')
tcpEStatsPathRcvRTT = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 29), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathRcvRTT.setDescription("The receiver's estimate of the Path RTT.\n\n        Adaptive receiver window algorithms depend on the receiver\n        to having a good estimate of the path RTT.")
tcpEStatsPathDupAcksOut = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 30), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathDupAcksOut.setDescription('The number of duplicate ACKs sent.  The ratio of the change\n        in tcpEStatsPathDupAcksOut to the change in\n        tcpEStatsPathDupAckEpisodes is an indication of reorder or\n        recovery distance over some interval.')
tcpEStatsPathCERcvd = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 31), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathCERcvd.setDescription('The number of segments received with IP headers bearing\n        Congestion Experienced (CE) markings.')
tcpEStatsPathECESent = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 4, 1, 32), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsPathECESent.setDescription('Number of times the Echo Congestion Experienced (ECE) bit\n        in the TCP header has been set (transitioned from 0 to 1),\n        due to a Congestion Experienced (CE) marking on an IP\n        header.  Note that ECE can be set and reset only once per\n        RTT, while CE can be set on many segments per RTT.')
tcpEStatsStackTable = MibTable((1, 3, 6, 1, 2, 1, 156, 1, 1, 5), )
if mibBuilder.loadTexts: tcpEStatsStackTable.setDescription('This table contains objects that are most useful for\n        determining how well some of the TCP control\n        algorithms are coping with this particular\n\n\n\n        path.\n\n        Entries are retained in this table for the number of\n        seconds indicated by the tcpEStatsConnTableLatency\n        object, after the TCP connection first enters the closed\n        state.')
tcpEStatsStackEntry = MibTableRow((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1), ).setIndexNames((0, "TCP-ESTATS-MIB", "tcpEStatsConnectIndex"))
if mibBuilder.loadTexts: tcpEStatsStackEntry.setDescription('Each entry in this table has information about the\n        characteristics of each active and recently closed TCP\n        connection.')
tcpEStatsStackActiveOpen = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackActiveOpen.setDescription('True(1) if the local connection traversed the SYN-SENT\n        state, else false(2).')
tcpEStatsStackMSSSent = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackMSSSent.setDescription('The value sent in an MSS option, or zero if none.')
tcpEStatsStackMSSRcvd = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackMSSRcvd.setDescription('The value received in an MSS option, or zero if none.')
tcpEStatsStackWinScaleSent = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1,14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackWinScaleSent.setDescription('The value of the transmitted window scale option if one was\n        sent; otherwise, a value of -1.\n\n        Note that if both tcpEStatsStackWinScaleSent and\n        tcpEStatsStackWinScaleRcvd are not -1, then Rcv.Wind.Scale\n        will be the same as this value and used to scale receiver\n        window announcements from the local host to the remote\n        host.')
tcpEStatsStackWinScaleRcvd = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1,14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackWinScaleRcvd.setDescription('The value of the received window scale option if one was\n        received; otherwise, a value of -1.\n\n        Note that if both tcpEStatsStackWinScaleSent and\n        tcpEStatsStackWinScaleRcvd are not -1, then Snd.Wind.Scale\n        will be the same as this value and used to scale receiver\n        window announcements from the remote host to the local\n        host.')
tcpEStatsStackTimeStamps = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 6), TcpEStatsNegotiated()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackTimeStamps.setDescription('Enabled(1) if TCP timestamps have been negotiated on,\n        selfDisabled(2) if they are disabled or not implemented on\n        the local host, or peerDisabled(3) if not negotiated by the\n        remote hosts.')
tcpEStatsStackECN = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 7), TcpEStatsNegotiated()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackECN.setDescription('Enabled(1) if Explicit Congestion Notification (ECN) has\n        been negotiated on, selfDisabled(2) if it is disabled or\n        not implemented on the local host, or peerDisabled(3) if\n        not negotiated by the remote hosts.')
tcpEStatsStackWillSendSACK = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 8), TcpEStatsNegotiated()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackWillSendSACK.setDescription('Enabled(1) if the local host will send SACK options,\n        selfDisabled(2) if SACK is disabled or not implemented on\n        the local host, or peerDisabled(3) if the remote host did\n        not send the SACK-permitted option.\n\n        Note that SACK negotiation is not symmetrical.  SACK can\n        enabled on one side of the connection and not the other.')
tcpEStatsStackWillUseSACK = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 9), TcpEStatsNegotiated()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackWillUseSACK.setDescription('Enabled(1) if the local host will process SACK options,\n        selfDisabled(2) if SACK is disabled or not implemented on\n        the local host, or peerDisabled(3) if the remote host sends\n\n\n\n        duplicate ACKs without SACK options, or the local host\n        otherwise decides not to process received SACK options.\n\n        Unlike other TCP options, the remote data receiver cannot\n        explicitly indicate if it is able to generate SACK options.\n        When sending data, the local host has to deduce if the\n        remote receiver is sending SACK options.  This object can\n        transition from Enabled(1) to peerDisabled(3) after the SYN\n        exchange.\n\n        Note that SACK negotiation is not symmetrical.  SACK can\n        enabled on one side of the connection and not the other.')
tcpEStatsStackState = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,))).clone(namedValues=NamedValues(("tcpESStateClosed", 1), ("tcpESStateListen", 2), ("tcpESStateSynSent", 3), ("tcpESStateSynReceived", 4), ("tcpESStateEstablished", 5), ("tcpESStateFinWait1", 6), ("tcpESStateFinWait2", 7), ("tcpESStateCloseWait", 8), ("tcpESStateLastAck", 9), ("tcpESStateClosing", 10), ("tcpESStateTimeWait", 11), ("tcpESStateDeleteTcb", 12),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackState.setDescription('An integer value representing the connection state from the\n        TCP State Transition Diagram.\n\n        The value listen(2) is included only for parallelism to the\n        old tcpConnTable, and SHOULD NOT be used because the listen\n        state in managed by the tcpListenerTable.\n\n        The value DeleteTcb(12) is included only for parallelism to\n        the tcpConnTable mechanism for terminating connections,\n\n\n\n        although this table does not permit writing.')
tcpEStatsStackNagle = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackNagle.setDescription('True(1) if the Nagle algorithm is being used, else\n        false(2).')
tcpEStatsStackMaxSsCwnd = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 12), Gauge32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackMaxSsCwnd.setDescription('The maximum congestion window used during Slow Start, in\n        octets.')
tcpEStatsStackMaxCaCwnd = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 13), Gauge32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackMaxCaCwnd.setDescription('The maximum congestion window used during Congestion\n        Avoidance, in octets.')
tcpEStatsStackMaxSsthresh = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 14), Gauge32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackMaxSsthresh.setDescription('The maximum slow start threshold, excluding the initial\n        value.')
tcpEStatsStackMinSsthresh = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 15), Gauge32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackMinSsthresh.setDescription('The minimum slow start threshold.')
tcpEStatsStackInRecovery = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3,))).clone(namedValues=NamedValues(("tcpESDataContiguous", 1), ("tcpESDataUnordered", 2), ("tcpESDataRecovery", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackInRecovery.setDescription('An integer value representing the state of the loss\n        recovery for this connection.\n\n        tcpESDataContiguous(1) indicates that the remote receiver\n        is reporting contiguous data (no duplicate acknowledgments\n        or SACK options) and that there are no unacknowledged\n        retransmissions.\n\n        tcpESDataUnordered(2) indicates that the remote receiver is\n        reporting missing or out-of-order data (e.g., sending\n        duplicate acknowledgments or SACK options) and that there\n        are no unacknowledged retransmissions (because the missing\n        data has not yet been retransmitted).\n\n        tcpESDataRecovery(3) indicates that the sender has\n        outstanding retransmitted data that is still\n\n\n\n        unacknowledged.')
tcpEStatsStackDupAcksIn = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 17), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackDupAcksIn.setDescription('The number of duplicate ACKs received.')
tcpEStatsStackSpuriousFrDetected = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 18), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackSpuriousFrDetected.setDescription("The number of acknowledgments reporting out-of-order\n        segments after the Fast Retransmit algorithm has already\n        retransmitted the segments. (For example as detected by the\n        Eifel algorithm).'")
tcpEStatsStackSpuriousRtoDetected = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 19), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackSpuriousRtoDetected.setDescription('The number of acknowledgments reporting segments that have\n        already been retransmitted due to a Retransmission Timeout.')
tcpEStatsStackSoftErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 21), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackSoftErrors.setDescription('The number of segments that fail various consistency tests\n        during TCP input processing.  Soft errors might cause the\n        segment to be discarded but some do not.  Some of these soft\n        errors cause the generation of a TCP acknowledgment, while\n        others are silently discarded.')
tcpEStatsStackSoftErrorReason = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8,))).clone(namedValues=NamedValues(("belowDataWindow", 1), ("aboveDataWindow", 2), ("belowAckWindow", 3), ("aboveAckWindow", 4), ("belowTSWindow", 5), ("aboveTSWindow", 6), ("dataCheckSum", 7), ("otherSoftError", 8),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackSoftErrorReason.setDescription('This object identifies which consistency test most recently\n        failed during TCP input processing.  This object SHOULD be\n        set every time tcpEStatsStackSoftErrors is incremented.  The\n        codes are as follows:\n\n        belowDataWindow(1) - All data in the segment is below\n        SND.UNA. (Normal for keep-alives and zero window probes).\n\n        aboveDataWindow(2) - Some data in the segment is above\n        SND.WND. (Indicates an implementation bug or possible\n        attack).\n\n        belowAckWindow(3) - ACK below SND.UNA. (Indicates that the\n        return path is reordering ACKs)\n\n        aboveAckWindow(4) - An ACK for data that we have not sent.\n        (Indicates an implementation bug or possible attack).\n\n        belowTSWindow(5) - TSecr on the segment is older than the\n        current TS.Recent (Normal for the rare case where PAWS\n        detects data reordered by the network).\n\n        aboveTSWindow(6) - TSecr on the segment is newer than the\n        current TS.Recent. (Indicates an implementation bug or\n        possible attack).\n\n\n\n\n        dataCheckSum(7) - Incorrect checksum.  Note that this value\n        is intrinsically fragile, because the header fields used to\n        identify the connection may have been corrupted.\n\n        otherSoftError(8) - All other soft errors not listed\n        above.')
tcpEStatsStackSlowStart = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 23), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackSlowStart.setDescription('The number of times the congestion window has been\n        increased by the Slow Start algorithm.')
tcpEStatsStackCongAvoid = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 24), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackCongAvoid.setDescription('The number of times the congestion window has been\n        increased by the Congestion Avoidance algorithm.')
tcpEStatsStackOtherReductions = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 25), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackOtherReductions.setDescription('The number of congestion window reductions made as a result\n        of anything other than AIMD congestion control algorithms.\n        Examples of non-multiplicative window reductions include\n        Congestion Window Validation [RFC2861] and experimental\n        algorithms such as Vegas [Bra94].\n\n\n\n\n        All window reductions MUST be counted as either\n        tcpEStatsPerfCongSignals or tcpEStatsStackOtherReductions.')
tcpEStatsStackCongOverCount = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 26), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackCongOverCount.setDescription("The number of congestion events that were 'backed out' of\n        the congestion control state machine such that the\n        congestion window was restored to a prior value.  This can\n        happen due to the Eifel algorithm [RFC3522] or other\n        algorithms that can be used to detect and cancel spurious\n        invocations of the Fast Retransmit Algorithm.\n\n        Although it may be feasible to undo the effects of spurious\n        invocation of the Fast Retransmit congestion events cannot\n        easily be backed out of tcpEStatsPerfCongSignals and\n        tcpEStatsPathPreCongSumCwnd, etc.")
tcpEStatsStackFastRetran = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 27), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackFastRetran.setDescription('The number of invocations of the Fast Retransmit algorithm.')
tcpEStatsStackSubsequentTimeouts = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 28), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackSubsequentTimeouts.setDescription('The number of times the retransmit timeout has expired after\n        the RTO has been doubled.  See Section 5.5 of RFC 2988.')
tcpEStatsStackCurTimeoutCount = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 29), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackCurTimeoutCount.setDescription('The current number of times the retransmit timeout has\n        expired without receiving an acknowledgment for new data.\n        tcpEStatsStackCurTimeoutCount is reset to zero when new\n        data is acknowledged and incremented for each invocation of\n        Section 5.5 of RFC 2988.')
tcpEStatsStackAbruptTimeouts = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 30), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackAbruptTimeouts.setDescription('The number of timeouts that occurred without any\n        immediately preceding duplicate acknowledgments or other\n        indications of congestion.  Abrupt Timeouts indicate that\n        the path lost an entire window of data or acknowledgments.\n\n        Timeouts that are preceded by duplicate acknowledgments or\n        other congestion signals (e.g., ECN) are not counted as\n        abrupt, and might have been avoided by a more sophisticated\n        Fast Retransmit algorithm.')
tcpEStatsStackSACKsRcvd = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 31), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackSACKsRcvd.setDescription('The number of SACK options received.')
tcpEStatsStackSACKBlocksRcvd = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 32), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackSACKBlocksRcvd.setDescription('The number of SACK blocks received (within SACK options).')
tcpEStatsStackSendStall = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 33), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackSendStall.setDescription('The number of interface stalls or other sender local\n        resource limitations that are treated as congestion\n        signals.')
tcpEStatsStackDSACKDups = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 34), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackDSACKDups.setDescription('The number of duplicate segments reported to the local host\n        by D-SACK blocks.')
tcpEStatsStackMaxMSS = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 35), Gauge32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackMaxMSS.setDescription('The maximum MSS, in octets.')
tcpEStatsStackMinMSS = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 36), Gauge32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackMinMSS.setDescription('The minimum MSS, in octets.')
tcpEStatsStackSndInitial = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 37), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackSndInitial.setDescription('Initial send sequence number.  Note that by definition\n        tcpEStatsStackSndInitial never changes for a given\n        connection.')
tcpEStatsStackRecInitial = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 38), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackRecInitial.setDescription('Initial receive sequence number.  Note that by definition\n        tcpEStatsStackRecInitial never changes for a given\n        connection.')
tcpEStatsStackCurRetxQueue = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 39), Gauge32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackCurRetxQueue.setDescription('The current number of octets of data occupying the\n        retransmit queue.')
tcpEStatsStackMaxRetxQueue = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 40), Gauge32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackMaxRetxQueue.setDescription('The maximum number of octets of data occupying the\n        retransmit queue.')
tcpEStatsStackCurReasmQueue = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 41), Gauge32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackCurReasmQueue.setDescription('The current number of octets of sequence space spanned by\n        the reassembly queue.  This is generally the difference\n        between rcv.nxt and the sequence number of the right most\n        edge of the reassembly queue.')
tcpEStatsStackMaxReasmQueue = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 5, 1, 42), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsStackMaxReasmQueue.setDescription('The maximum value of tcpEStatsStackCurReasmQueue')
tcpEStatsAppTable = MibTable((1, 3, 6, 1, 2, 1, 156, 1, 1, 6), )
if mibBuilder.loadTexts: tcpEStatsAppTable.setDescription('This table contains objects that are useful for\n        determining if the application using TCP is\n\n\n\n        limiting TCP performance.\n\n        Entries are retained in this table for the number of\n        seconds indicated by the tcpEStatsConnTableLatency\n        object, after the TCP connection first enters the closed\n        state.')
tcpEStatsAppEntry = MibTableRow((1, 3, 6, 1, 2, 1, 156, 1, 1, 6, 1), ).setIndexNames((0, "TCP-ESTATS-MIB", "tcpEStatsConnectIndex"))
if mibBuilder.loadTexts: tcpEStatsAppEntry.setDescription('Each entry in this table has information about the\n        characteristics of each active and recently closed TCP\n        connection.')
tcpEStatsAppSndUna = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsAppSndUna.setDescription('The value of SND.UNA, the oldest unacknowledged sequence\n        number.\n\n        Note that SND.UNA is a TCP state variable that is congruent\n        to Counter32 semantics.')
tcpEStatsAppSndNxt = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 6, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsAppSndNxt.setDescription('The value of SND.NXT, the next sequence number to be sent.\n        Note that tcpEStatsAppSndNxt is not monotonic (and thus not\n        a counter) because TCP sometimes retransmits lost data by\n        pulling tcpEStatsAppSndNxt back to the missing data.')
tcpEStatsAppSndMax = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsAppSndMax.setDescription('The farthest forward (right most or largest) SND.NXT value.\n        Note that this will be equal to tcpEStatsAppSndNxt except\n        when tcpEStatsAppSndNxt is pulled back during recovery.')
tcpEStatsAppThruOctetsAcked = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 6, 1, 4), ZeroBasedCounter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsAppThruOctetsAcked.setDescription('The number of octets for which cumulative acknowledgments\n        have been received.  Note that this will be the sum of\n        changes to tcpEStatsAppSndUna.')
tcpEStatsAppHCThruOctetsAcked = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 6, 1, 5), ZeroBasedCounter64()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsAppHCThruOctetsAcked.setDescription('The number of octets for which cumulative acknowledgments\n        have been received, on systems that can receive more than\n        10 million bits per second.  Note that this will be the sum\n        of changes in tcpEStatsAppSndUna.')
tcpEStatsAppRcvNxt = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsAppRcvNxt.setDescription('The value of RCV.NXT.  The next sequence number expected on\n        an incoming segment, and the left or lower edge of the\n        receive window.\n\n        Note that RCV.NXT is a TCP state variable that is congruent\n        to Counter32 semantics.')
tcpEStatsAppThruOctetsReceived = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 6, 1, 7), ZeroBasedCounter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsAppThruOctetsReceived.setDescription('The number of octets for which cumulative acknowledgments\n        have been sent.  Note that this will be the sum of changes\n        to tcpEStatsAppRcvNxt.')
tcpEStatsAppHCThruOctetsReceived = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 6, 1, 8), ZeroBasedCounter64()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsAppHCThruOctetsReceived.setDescription('The number of octets for which cumulative acknowledgments\n        have been sent, on systems that can transmit more than 10\n        million bits per second.  Note that this will be the sum of\n        changes in tcpEStatsAppRcvNxt.')
tcpEStatsAppCurAppWQueue = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 6, 1, 11), Gauge32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsAppCurAppWQueue.setDescription('The current number of octets of application data buffered\n        by TCP, pending first transmission, i.e., to the left of\n        SND.NXT or SndMax.  This data will generally be transmitted\n        (and SND.NXT advanced to the left) as soon as there is an\n        available congestion window (cwnd) or receiver window\n        (rwin).  This is the amount of data readily available for\n        transmission, without scheduling the application.  TCP\n        performance may suffer if there is insufficient queued\n        write data.')
tcpEStatsAppMaxAppWQueue = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 6, 1, 12), Gauge32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsAppMaxAppWQueue.setDescription('The maximum number of octets of application data buffered\n        by TCP, pending first transmission.  This is the maximum\n        value of tcpEStatsAppCurAppWQueue.  This pair of objects can\n        be used to determine if insufficient queued data is steady\n        state (suggesting insufficient queue space) or transient\n        (suggesting insufficient application performance or\n        excessive CPU load or scheduler latency).')
tcpEStatsAppCurAppRQueue = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 6, 1, 13), Gauge32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsAppCurAppRQueue.setDescription('The current number of octets of application data that has\n        been acknowledged by TCP but not yet delivered to the\n        application.')
tcpEStatsAppMaxAppRQueue = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 6, 1, 14), Gauge32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: tcpEStatsAppMaxAppRQueue.setDescription('The maximum number of octets of application data that has\n        been acknowledged by TCP but not yet delivered to the\n        application.')
tcpEStatsTuneTable = MibTable((1, 3, 6, 1, 2, 1, 156, 1, 1, 7), )
if mibBuilder.loadTexts: tcpEStatsTuneTable.setDescription('This table contains per-connection controls that can\n        be used to work around a number of common problems that\n        plague TCP over some paths.  All can be characterized as\n        limiting the growth of the congestion window so as to\n        prevent TCP from overwhelming some component in the\n        path.\n\n        Entries are retained in this table for the number of\n        seconds indicated by the tcpEStatsConnTableLatency\n        object, after the TCP connection first enters the closed\n        state.')
tcpEStatsTuneEntry = MibTableRow((1, 3, 6, 1, 2, 1, 156, 1, 1, 7, 1), ).setIndexNames((0, "TCP-ESTATS-MIB", "tcpEStatsConnectIndex"))
if mibBuilder.loadTexts: tcpEStatsTuneEntry.setDescription('Each entry in this table is a control that can be used to\n        place limits on each active TCP connection.')
tcpEStatsTuneLimCwnd = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 7, 1, 1), Unsigned32()).setUnits('octets').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpEStatsTuneLimCwnd.setDescription('A control to set the maximum congestion window that may be\n        used, in octets.')
tcpEStatsTuneLimSsthresh = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 7, 1, 2), Unsigned32()).setUnits('octets').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpEStatsTuneLimSsthresh.setDescription('A control to limit the maximum queue space (in octets) that\n        this TCP connection is likely to occupy during slowstart.\n\n        It can be implemented with the algorithm described in\n        RFC 3742 by setting the max_ssthresh parameter to twice\n        tcpEStatsTuneLimSsthresh.\n\n        This algorithm can be used to overcome some TCP performance\n        problems over network paths that do not have sufficient\n        buffering to withstand the bursts normally present during\n        slowstart.')
tcpEStatsTuneLimRwin = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 7, 1, 3), Unsigned32()).setUnits('octets').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpEStatsTuneLimRwin.setDescription('A control to set the maximum window advertisement that may\n        be sent, in octets.')
tcpEStatsTuneLimMSS = MibTableColumn((1, 3, 6, 1, 2, 1, 156, 1, 1, 7, 1, 4), Unsigned32()).setUnits('octets').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpEStatsTuneLimMSS.setDescription('A control to limit the maximum segment size in octets, that\n        this TCP connection can use.')
tcpEStatsEstablishNotification = NotificationType((1, 3, 6, 1, 2, 1, 156, 0, 1)).setObjects(*(("TCP-ESTATS-MIB", "tcpEStatsConnectIndex"),))
if mibBuilder.loadTexts: tcpEStatsEstablishNotification.setDescription('The indicated connection has been accepted\n        (or alternatively entered the established state).')
tcpEStatsCloseNotification = NotificationType((1, 3, 6, 1, 2, 1, 156, 0, 2)).setObjects(*(("TCP-ESTATS-MIB", "tcpEStatsConnectIndex"),))
if mibBuilder.loadTexts: tcpEStatsCloseNotification.setDescription('The indicated connection has left the\n        established state')
tcpEStatsCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 156, 2, 1))
tcpEStatsGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 156, 2, 2))
tcpEStatsCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 156, 2, 1, 1)).setObjects(*(("TCP-ESTATS-MIB", "tcpEStatsListenerGroup"), ("TCP-ESTATS-MIB", "tcpEStatsConnectIdGroup"), ("TCP-ESTATS-MIB", "tcpEStatsPerfGroup"), ("TCP-ESTATS-MIB", "tcpEStatsPathGroup"), ("TCP-ESTATS-MIB", "tcpEStatsStackGroup"), ("TCP-ESTATS-MIB", "tcpEStatsAppGroup"), ("TCP-ESTATS-MIB", "tcpEStatsListenerHCGroup"), ("TCP-ESTATS-MIB", "tcpEStatsPerfOptionalGroup"), ("TCP-ESTATS-MIB", "tcpEStatsPerfHCGroup"), ("TCP-ESTATS-MIB", "tcpEStatsPathOptionalGroup"), ("TCP-ESTATS-MIB", "tcpEStatsPathHCGroup"), ("TCP-ESTATS-MIB", "tcpEStatsStackOptionalGroup"), ("TCP-ESTATS-MIB", "tcpEStatsAppHCGroup"), ("TCP-ESTATS-MIB", "tcpEStatsAppOptionalGroup"), ("TCP-ESTATS-MIB", "tcpEStatsTuneOptionalGroup"), ("TCP-ESTATS-MIB", "tcpEStatsNotificationsGroup"), ("TCP-ESTATS-MIB", "tcpEStatsNotificationsCtlGroup"),))
if mibBuilder.loadTexts: tcpEStatsCompliance.setDescription('Compliance statement for all systems that implement TCP\n         extended statistics.')
tcpEStatsListenerGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 156, 2, 2, 1)).setObjects(*(("TCP-ESTATS-MIB", "tcpEStatsListenerTableLastChange"), ("TCP-ESTATS-MIB", "tcpEStatsListenerStartTime"), ("TCP-ESTATS-MIB", "tcpEStatsListenerSynRcvd"), ("TCP-ESTATS-MIB", "tcpEStatsListenerInitial"), ("TCP-ESTATS-MIB", "tcpEStatsListenerEstablished"), ("TCP-ESTATS-MIB", "tcpEStatsListenerAccepted"), ("TCP-ESTATS-MIB", "tcpEStatsListenerExceedBacklog"), ("TCP-ESTATS-MIB", "tcpEStatsListenerCurConns"), ("TCP-ESTATS-MIB", "tcpEStatsListenerMaxBacklog"), ("TCP-ESTATS-MIB", "tcpEStatsListenerCurBacklog"), ("TCP-ESTATS-MIB", "tcpEStatsListenerCurEstabBacklog"),))
if mibBuilder.loadTexts: tcpEStatsListenerGroup.setDescription('The tcpEStatsListener group includes objects that\n              provide valuable statistics and debugging\n              information for TCP Listeners.')
tcpEStatsListenerHCGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 156, 2, 2, 2)).setObjects(*(("TCP-ESTATS-MIB", "tcpEStatsListenerHCSynRcvd"), ("TCP-ESTATS-MIB", "tcpEStatsListenerHCInitial"), ("TCP-ESTATS-MIB", "tcpEStatsListenerHCEstablished"), ("TCP-ESTATS-MIB", "tcpEStatsListenerHCAccepted"), ("TCP-ESTATS-MIB", "tcpEStatsListenerHCExceedBacklog"),))
if mibBuilder.loadTexts: tcpEStatsListenerHCGroup.setDescription('The tcpEStatsListenerHC group includes 64-bit\n               counters in tcpEStatsListenerTable.')
tcpEStatsConnectIdGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 156, 2, 2, 3)).setObjects(*(("TCP-ESTATS-MIB", "tcpEStatsConnTableLatency"), ("TCP-ESTATS-MIB", "tcpEStatsConnectIndex"),))
if mibBuilder.loadTexts: tcpEStatsConnectIdGroup.setDescription('The tcpEStatsConnectId group includes objects that\n              identify TCP connections and control how long TCP\n              connection entries are retained in the tables.')
tcpEStatsPerfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 156, 2, 2, 4)).setObjects(*(("TCP-ESTATS-MIB", "tcpEStatsPerfSegsOut"), ("TCP-ESTATS-MIB", "tcpEStatsPerfDataSegsOut"), ("TCP-ESTATS-MIB", "tcpEStatsPerfDataOctetsOut"), ("TCP-ESTATS-MIB", "tcpEStatsPerfSegsRetrans"), ("TCP-ESTATS-MIB", "tcpEStatsPerfOctetsRetrans"), ("TCP-ESTATS-MIB", "tcpEStatsPerfSegsIn"), ("TCP-ESTATS-MIB", "tcpEStatsPerfDataSegsIn"), ("TCP-ESTATS-MIB", "tcpEStatsPerfDataOctetsIn"), ("TCP-ESTATS-MIB", "tcpEStatsPerfElapsedSecs"), ("TCP-ESTATS-MIB", "tcpEStatsPerfElapsedMicroSecs"), ("TCP-ESTATS-MIB", "tcpEStatsPerfStartTimeStamp"), ("TCP-ESTATS-MIB", "tcpEStatsPerfCurMSS"), ("TCP-ESTATS-MIB", "tcpEStatsPerfPipeSize"), ("TCP-ESTATS-MIB", "tcpEStatsPerfMaxPipeSize"), ("TCP-ESTATS-MIB", "tcpEStatsPerfSmoothedRTT"), ("TCP-ESTATS-MIB", "tcpEStatsPerfCurRTO"), ("TCP-ESTATS-MIB", "tcpEStatsPerfCongSignals"), ("TCP-ESTATS-MIB", "tcpEStatsPerfCurCwnd"), ("TCP-ESTATS-MIB", "tcpEStatsPerfCurSsthresh"), ("TCP-ESTATS-MIB", "tcpEStatsPerfTimeouts"), ("TCP-ESTATS-MIB", "tcpEStatsPerfCurRwinSent"), ("TCP-ESTATS-MIB", "tcpEStatsPerfMaxRwinSent"), ("TCP-ESTATS-MIB", "tcpEStatsPerfZeroRwinSent"), ("TCP-ESTATS-MIB", "tcpEStatsPerfCurRwinRcvd"), ("TCP-ESTATS-MIB", "tcpEStatsPerfMaxRwinRcvd"), ("TCP-ESTATS-MIB", "tcpEStatsPerfZeroRwinRcvd"),))
if mibBuilder.loadTexts: tcpEStatsPerfGroup.setDescription('The tcpEStatsPerf group includes those objects that\n              provide basic performance data for a TCP connection.')
tcpEStatsPerfOptionalGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 156, 2, 2, 5)).setObjects(*(("TCP-ESTATS-MIB", "tcpEStatsPerfSndLimTransRwin"), ("TCP-ESTATS-MIB", "tcpEStatsPerfSndLimTransCwnd"), ("TCP-ESTATS-MIB", "tcpEStatsPerfSndLimTransSnd"), ("TCP-ESTATS-MIB", "tcpEStatsPerfSndLimTimeRwin"), ("TCP-ESTATS-MIB", "tcpEStatsPerfSndLimTimeCwnd"), ("TCP-ESTATS-MIB", "tcpEStatsPerfSndLimTimeSnd"),))
if mibBuilder.loadTexts: tcpEStatsPerfOptionalGroup.setDescription('The tcpEStatsPerf group includes those objects that\n              provide basic performance data for a TCP connection.')
tcpEStatsPerfHCGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 156, 2, 2, 6)).setObjects(*(("TCP-ESTATS-MIB", "tcpEStatsPerfHCDataOctetsOut"), ("TCP-ESTATS-MIB", "tcpEStatsPerfHCDataOctetsIn"),))
if mibBuilder.loadTexts: tcpEStatsPerfHCGroup.setDescription('The tcpEStatsPerfHC group includes 64-bit\n              counters in the tcpEStatsPerfTable.')
tcpEStatsPathGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 156, 2, 2, 7)).setObjects(*(("TCP-ESTATS-MIB", "tcpEStatsControlPath"), ("TCP-ESTATS-MIB", "tcpEStatsPathRetranThresh"), ("TCP-ESTATS-MIB", "tcpEStatsPathNonRecovDAEpisodes"), ("TCP-ESTATS-MIB", "tcpEStatsPathSumOctetsReordered"), ("TCP-ESTATS-MIB", "tcpEStatsPathNonRecovDA"),))
if mibBuilder.loadTexts: tcpEStatsPathGroup.setDescription('The tcpEStatsPath group includes objects that\n              control the creation of the tcpEStatsPathTable,\n              and provide information about the path\n              for each TCP connection.')
tcpEStatsPathOptionalGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 156, 2, 2, 8)).setObjects(*(("TCP-ESTATS-MIB", "tcpEStatsPathSampleRTT"), ("TCP-ESTATS-MIB", "tcpEStatsPathRTTVar"), ("TCP-ESTATS-MIB", "tcpEStatsPathMaxRTT"), ("TCP-ESTATS-MIB", "tcpEStatsPathMinRTT"), ("TCP-ESTATS-MIB", "tcpEStatsPathSumRTT"), ("TCP-ESTATS-MIB", "tcpEStatsPathCountRTT"), ("TCP-ESTATS-MIB", "tcpEStatsPathMaxRTO"), ("TCP-ESTATS-MIB", "tcpEStatsPathMinRTO"), ("TCP-ESTATS-MIB", "tcpEStatsPathIpTtl"), ("TCP-ESTATS-MIB", "tcpEStatsPathIpTosIn"), ("TCP-ESTATS-MIB", "tcpEStatsPathIpTosOut"), ("TCP-ESTATS-MIB", "tcpEStatsPathPreCongSumCwnd"), ("TCP-ESTATS-MIB", "tcpEStatsPathPreCongSumRTT"), ("TCP-ESTATS-MIB", "tcpEStatsPathPostCongSumRTT"), ("TCP-ESTATS-MIB", "tcpEStatsPathPostCongCountRTT"), ("TCP-ESTATS-MIB", "tcpEStatsPathECNsignals"), ("TCP-ESTATS-MIB", "tcpEStatsPathDupAckEpisodes"), ("TCP-ESTATS-MIB", "tcpEStatsPathRcvRTT"), ("TCP-ESTATS-MIB", "tcpEStatsPathDupAcksOut"), ("TCP-ESTATS-MIB", "tcpEStatsPathCERcvd"), ("TCP-ESTATS-MIB", "tcpEStatsPathECESent"),))
if mibBuilder.loadTexts: tcpEStatsPathOptionalGroup.setDescription('The tcpEStatsPath group includes objects that\n              provide additional information about the path\n              for each TCP connection.')
tcpEStatsPathHCGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 156, 2, 2, 9)).setObjects(*(("TCP-ESTATS-MIB", "tcpEStatsPathHCSumRTT"),))
if mibBuilder.loadTexts: tcpEStatsPathHCGroup.setDescription('The tcpEStatsPathHC group includes 64-bit\n              counters in the tcpEStatsPathTable.')
tcpEStatsStackGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 156, 2, 2, 10)).setObjects(*(("TCP-ESTATS-MIB", "tcpEStatsControlStack"), ("TCP-ESTATS-MIB", "tcpEStatsStackActiveOpen"), ("TCP-ESTATS-MIB", "tcpEStatsStackMSSSent"), ("TCP-ESTATS-MIB", "tcpEStatsStackMSSRcvd"), ("TCP-ESTATS-MIB", "tcpEStatsStackWinScaleSent"), ("TCP-ESTATS-MIB", "tcpEStatsStackWinScaleRcvd"), ("TCP-ESTATS-MIB", "tcpEStatsStackTimeStamps"), ("TCP-ESTATS-MIB", "tcpEStatsStackECN"), ("TCP-ESTATS-MIB", "tcpEStatsStackWillSendSACK"), ("TCP-ESTATS-MIB", "tcpEStatsStackWillUseSACK"), ("TCP-ESTATS-MIB", "tcpEStatsStackState"), ("TCP-ESTATS-MIB", "tcpEStatsStackNagle"), ("TCP-ESTATS-MIB", "tcpEStatsStackMaxSsCwnd"), ("TCP-ESTATS-MIB", "tcpEStatsStackMaxCaCwnd"), ("TCP-ESTATS-MIB", "tcpEStatsStackMaxSsthresh"), ("TCP-ESTATS-MIB", "tcpEStatsStackMinSsthresh"), ("TCP-ESTATS-MIB", "tcpEStatsStackInRecovery"), ("TCP-ESTATS-MIB", "tcpEStatsStackDupAcksIn"), ("TCP-ESTATS-MIB", "tcpEStatsStackSpuriousFrDetected"), ("TCP-ESTATS-MIB", "tcpEStatsStackSpuriousRtoDetected"),))
if mibBuilder.loadTexts: tcpEStatsStackGroup.setDescription('The tcpEStatsConnState group includes objects that\n              control the creation of the tcpEStatsStackTable,\n              and provide information about the operation of\n              algorithms used within TCP.')
tcpEStatsStackOptionalGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 156, 2, 2, 11)).setObjects(*(("TCP-ESTATS-MIB", "tcpEStatsStackSoftErrors"), ("TCP-ESTATS-MIB", "tcpEStatsStackSoftErrorReason"), ("TCP-ESTATS-MIB", "tcpEStatsStackSlowStart"), ("TCP-ESTATS-MIB", "tcpEStatsStackCongAvoid"), ("TCP-ESTATS-MIB", "tcpEStatsStackOtherReductions"), ("TCP-ESTATS-MIB", "tcpEStatsStackCongOverCount"), ("TCP-ESTATS-MIB", "tcpEStatsStackFastRetran"), ("TCP-ESTATS-MIB", "tcpEStatsStackSubsequentTimeouts"), ("TCP-ESTATS-MIB", "tcpEStatsStackCurTimeoutCount"), ("TCP-ESTATS-MIB", "tcpEStatsStackAbruptTimeouts"), ("TCP-ESTATS-MIB", "tcpEStatsStackSACKsRcvd"), ("TCP-ESTATS-MIB", "tcpEStatsStackSACKBlocksRcvd"), ("TCP-ESTATS-MIB", "tcpEStatsStackSendStall"), ("TCP-ESTATS-MIB", "tcpEStatsStackDSACKDups"), ("TCP-ESTATS-MIB", "tcpEStatsStackMaxMSS"), ("TCP-ESTATS-MIB", "tcpEStatsStackMinMSS"), ("TCP-ESTATS-MIB", "tcpEStatsStackSndInitial"), ("TCP-ESTATS-MIB", "tcpEStatsStackRecInitial"), ("TCP-ESTATS-MIB", "tcpEStatsStackCurRetxQueue"), ("TCP-ESTATS-MIB", "tcpEStatsStackMaxRetxQueue"), ("TCP-ESTATS-MIB", "tcpEStatsStackCurReasmQueue"), ("TCP-ESTATS-MIB", "tcpEStatsStackMaxReasmQueue"),))
if mibBuilder.loadTexts: tcpEStatsStackOptionalGroup.setDescription('The tcpEStatsConnState group includes objects that\n              provide additional information about the operation of\n              algorithms used within TCP.')
tcpEStatsAppGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 156, 2, 2, 12)).setObjects(*(("TCP-ESTATS-MIB", "tcpEStatsControlApp"), ("TCP-ESTATS-MIB", "tcpEStatsAppSndUna"), ("TCP-ESTATS-MIB", "tcpEStatsAppSndNxt"), ("TCP-ESTATS-MIB", "tcpEStatsAppSndMax"), ("TCP-ESTATS-MIB", "tcpEStatsAppThruOctetsAcked"), ("TCP-ESTATS-MIB", "tcpEStatsAppRcvNxt"), ("TCP-ESTATS-MIB", "tcpEStatsAppThruOctetsReceived"),))
if mibBuilder.loadTexts: tcpEStatsAppGroup.setDescription('The tcpEStatsConnState group includes objects that\n              control the creation of the tcpEStatsAppTable,\n              and provide information about the operation of\n              algorithms used within TCP.')
tcpEStatsAppHCGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 156, 2, 2, 13)).setObjects(*(("TCP-ESTATS-MIB", "tcpEStatsAppHCThruOctetsAcked"), ("TCP-ESTATS-MIB", "tcpEStatsAppHCThruOctetsReceived"),))
if mibBuilder.loadTexts: tcpEStatsAppHCGroup.setDescription('The tcpEStatsStackHC group includes 64-bit\n              counters in the tcpEStatsStackTable.')
tcpEStatsAppOptionalGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 156, 2, 2, 14)).setObjects(*(("TCP-ESTATS-MIB", "tcpEStatsAppCurAppWQueue"), ("TCP-ESTATS-MIB", "tcpEStatsAppMaxAppWQueue"), ("TCP-ESTATS-MIB", "tcpEStatsAppCurAppRQueue"), ("TCP-ESTATS-MIB", "tcpEStatsAppMaxAppRQueue"),))
if mibBuilder.loadTexts: tcpEStatsAppOptionalGroup.setDescription('The tcpEStatsConnState group includes objects that\n              provide additional information about how applications\n              are interacting with each TCP connection.')
tcpEStatsTuneOptionalGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 156, 2, 2, 15)).setObjects(*(("TCP-ESTATS-MIB", "tcpEStatsControlTune"), ("TCP-ESTATS-MIB", "tcpEStatsTuneLimCwnd"), ("TCP-ESTATS-MIB", "tcpEStatsTuneLimSsthresh"), ("TCP-ESTATS-MIB", "tcpEStatsTuneLimRwin"), ("TCP-ESTATS-MIB", "tcpEStatsTuneLimMSS"),))
if mibBuilder.loadTexts: tcpEStatsTuneOptionalGroup.setDescription('The tcpEStatsConnState group includes objects that\n              control the creation of the tcpEStatsConnectionTable,\n              which can be used to set tuning parameters\n              for each TCP connection.')
tcpEStatsNotificationsGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 156, 2, 2, 16)).setObjects(*(("TCP-ESTATS-MIB", "tcpEStatsEstablishNotification"), ("TCP-ESTATS-MIB", "tcpEStatsCloseNotification"),))
if mibBuilder.loadTexts: tcpEStatsNotificationsGroup.setDescription('Notifications sent by a TCP extended statistics agent.')
tcpEStatsNotificationsCtlGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 156, 2, 2, 17)).setObjects(*(("TCP-ESTATS-MIB", "tcpEStatsControlNotify"),))
if mibBuilder.loadTexts: tcpEStatsNotificationsCtlGroup.setDescription('The tcpEStatsNotificationsCtl group includes the\n              object that controls the creation of the events\n              in the tcpEStatsNotificationsGroup.')
mibBuilder.exportSymbols("TCP-ESTATS-MIB", tcpEStatsPerfSegsIn=tcpEStatsPerfSegsIn, tcpEStatsAppHCThruOctetsAcked=tcpEStatsAppHCThruOctetsAcked, tcpEStatsStackMSSSent=tcpEStatsStackMSSSent, tcpEStatsTuneLimRwin=tcpEStatsTuneLimRwin, tcpEStatsStackTimeStamps=tcpEStatsStackTimeStamps, tcpEStatsStackState=tcpEStatsStackState, tcpEStatsPerfZeroRwinRcvd=tcpEStatsPerfZeroRwinRcvd, tcpEStatsStackSpuriousFrDetected=tcpEStatsStackSpuriousFrDetected, tcpEStatsStackMaxMSS=tcpEStatsStackMaxMSS, tcpEStatsPerfDataOctetsIn=tcpEStatsPerfDataOctetsIn, tcpEStatsStackSACKsRcvd=tcpEStatsStackSACKsRcvd, tcpEStatsTuneTable=tcpEStatsTuneTable, TcpEStatsNegotiated=TcpEStatsNegotiated, tcpEStatsPathCERcvd=tcpEStatsPathCERcvd, tcpEStatsPerfEntry=tcpEStatsPerfEntry, tcpEStatsConnectIndex=tcpEStatsConnectIndex, tcpEStatsPerfSndLimTransSnd=tcpEStatsPerfSndLimTransSnd, tcpEStatsPerfZeroRwinSent=tcpEStatsPerfZeroRwinSent, tcpEStatsStackSACKBlocksRcvd=tcpEStatsStackSACKBlocksRcvd, tcpEStatsPerfSndLimTimeRwin=tcpEStatsPerfSndLimTimeRwin, tcpEStatsPerfTable=tcpEStatsPerfTable, tcpEStatsPathSampleRTT=tcpEStatsPathSampleRTT, tcpEStatsEstablishNotification=tcpEStatsEstablishNotification, tcpEStatsPerfMaxRwinRcvd=tcpEStatsPerfMaxRwinRcvd, tcpEStatsAppMaxAppRQueue=tcpEStatsAppMaxAppRQueue, tcpEStatsPerfCurSsthresh=tcpEStatsPerfCurSsthresh, tcpEStatsStackDSACKDups=tcpEStatsStackDSACKDups, tcpEStatsCloseNotification=tcpEStatsCloseNotification, tcpEStatsAppEntry=tcpEStatsAppEntry, tcpEStatsControlApp=tcpEStatsControlApp, tcpEStatsStackRecInitial=tcpEStatsStackRecInitial, tcpEStatsStackMaxReasmQueue=tcpEStatsStackMaxReasmQueue, tcpEStatsStackWillSendSACK=tcpEStatsStackWillSendSACK, tcpEStatsAppRcvNxt=tcpEStatsAppRcvNxt, tcpEStatsPerfHCGroup=tcpEStatsPerfHCGroup, tcpEStatsPerfSndLimTimeCwnd=tcpEStatsPerfSndLimTimeCwnd, tcpEStatsPerfStartTimeStamp=tcpEStatsPerfStartTimeStamp, tcpEStatsConnectIdTable=tcpEStatsConnectIdTable, tcpEStatsControlStack=tcpEStatsControlStack, tcpEStatsStackDupAcksIn=tcpEStatsStackDupAcksIn, tcpEStatsListenerGroup=tcpEStatsListenerGroup, tcpEStatsControlPath=tcpEStatsControlPath, tcpEStatsPathIpTosIn=tcpEStatsPathIpTosIn, tcpEStatsStackOtherReductions=tcpEStatsStackOtherReductions, tcpEStatsStackCurRetxQueue=tcpEStatsStackCurRetxQueue, tcpEStatsTuneEntry=tcpEStatsTuneEntry, tcpEStatsPerfHCDataOctetsIn=tcpEStatsPerfHCDataOctetsIn, tcpEStatsStackMaxSsCwnd=tcpEStatsStackMaxSsCwnd, tcpEStatsPathNonRecovDA=tcpEStatsPathNonRecovDA, tcpEStatsStackSoftErrorReason=tcpEStatsStackSoftErrorReason, tcpEStatsStackTable=tcpEStatsStackTable, tcpEStatsPathECESent=tcpEStatsPathECESent, tcpEStatsPerfPipeSize=tcpEStatsPerfPipeSize, tcpEStatsStackSlowStart=tcpEStatsStackSlowStart, tcpEStatsStackMSSRcvd=tcpEStatsStackMSSRcvd, tcpEStatsListenerAccepted=tcpEStatsListenerAccepted, tcpEStatsAppGroup=tcpEStatsAppGroup, tcpEStatsStackAbruptTimeouts=tcpEStatsStackAbruptTimeouts, tcpEStatsPathPostCongCountRTT=tcpEStatsPathPostCongCountRTT, tcpEStatsPathSumRTT=tcpEStatsPathSumRTT, tcpEStatsPathEntry=tcpEStatsPathEntry, tcpEStatsPathHCGroup=tcpEStatsPathHCGroup, tcpEStatsListenerSynRcvd=tcpEStatsListenerSynRcvd, tcpEStatsStackMinMSS=tcpEStatsStackMinMSS, tcpEStatsPathSumOctetsReordered=tcpEStatsPathSumOctetsReordered, tcpEStatsAppSndUna=tcpEStatsAppSndUna, tcpEStatsPerfTimeouts=tcpEStatsPerfTimeouts, tcpEStatsListenerExceedBacklog=tcpEStatsListenerExceedBacklog, tcpEStatsPathMinRTO=tcpEStatsPathMinRTO, tcpEStatsPerfOctetsRetrans=tcpEStatsPerfOctetsRetrans, tcpEStatsStackMaxSsthresh=tcpEStatsStackMaxSsthresh, tcpEStatsAppOptionalGroup=tcpEStatsAppOptionalGroup, tcpEStatsPathPreCongSumCwnd=tcpEStatsPathPreCongSumCwnd, tcpEStatsListenerMaxBacklog=tcpEStatsListenerMaxBacklog, tcpEStatsPerfCongSignals=tcpEStatsPerfCongSignals, tcpEStatsStackFastRetran=tcpEStatsStackFastRetran, tcpEStatsTuneOptionalGroup=tcpEStatsTuneOptionalGroup, tcpEStatsCompliance=tcpEStatsCompliance, tcpEStatsListenerCurBacklog=tcpEStatsListenerCurBacklog, tcpEStatsStackMaxCaCwnd=tcpEStatsStackMaxCaCwnd, tcpEStatsPathIpTosOut=tcpEStatsPathIpTosOut, tcpEStatsControlNotify=tcpEStatsControlNotify, tcpEStatsNotificationsCtlGroup=tcpEStatsNotificationsCtlGroup, tcpEStatsAppTable=tcpEStatsAppTable, tcpEStatsPerfSndLimTimeSnd=tcpEStatsPerfSndLimTimeSnd, tcpEStatsPathRcvRTT=tcpEStatsPathRcvRTT, tcpEStatsStackEntry=tcpEStatsStackEntry, tcpEStatsStackWillUseSACK=tcpEStatsStackWillUseSACK, tcpEStatsPerfSmoothedRTT=tcpEStatsPerfSmoothedRTT, tcpEStatsControl=tcpEStatsControl, tcpEStatsPathMaxRTO=tcpEStatsPathMaxRTO, tcpEStatsAppHCThruOctetsReceived=tcpEStatsAppHCThruOctetsReceived, tcpEStatsAppCurAppWQueue=tcpEStatsAppCurAppWQueue, tcpEStatsGroups=tcpEStatsGroups, tcpEStatsMIBObjects=tcpEStatsMIBObjects, tcpEStatsListenerEstablished=tcpEStatsListenerEstablished, tcpEStatsPerfCurMSS=tcpEStatsPerfCurMSS, tcpEStatsListenerHCEstablished=tcpEStatsListenerHCEstablished, tcpEStatsPathECNsignals=tcpEStatsPathECNsignals, tcpEStatsPerfCurCwnd=tcpEStatsPerfCurCwnd, tcpEStatsNotifications=tcpEStatsNotifications, tcpEStatsListenerHCExceedBacklog=tcpEStatsListenerHCExceedBacklog, tcpEStatsPerfSegsRetrans=tcpEStatsPerfSegsRetrans, tcpEStatsPerfMaxRwinSent=tcpEStatsPerfMaxRwinSent, tcpEStatsPathCountRTT=tcpEStatsPathCountRTT, tcpEStatsPerfSegsOut=tcpEStatsPerfSegsOut, tcpEStatsAppSndNxt=tcpEStatsAppSndNxt, tcpEStatsPerfDataSegsIn=tcpEStatsPerfDataSegsIn, tcpEStatsControlTune=tcpEStatsControlTune, tcpEStatsTuneLimMSS=tcpEStatsTuneLimMSS, tcpEStatsStackSpuriousRtoDetected=tcpEStatsStackSpuriousRtoDetected, tcpEStatsStackSendStall=tcpEStatsStackSendStall, tcpEStatsListenerTable=tcpEStatsListenerTable, tcpEStatsStackInRecovery=tcpEStatsStackInRecovery, tcpEStatsAppThruOctetsAcked=tcpEStatsAppThruOctetsAcked, tcpEStatsStackGroup=tcpEStatsStackGroup, tcpEStatsPathRTTVar=tcpEStatsPathRTTVar, tcpEStatsConnectIdEntry=tcpEStatsConnectIdEntry, tcpEStatsPathHCSumRTT=tcpEStatsPathHCSumRTT, tcpEStatsListenerHCInitial=tcpEStatsListenerHCInitial, tcpEStatsAppMaxAppWQueue=tcpEStatsAppMaxAppWQueue, tcpEStatsListenerCurEstabBacklog=tcpEStatsListenerCurEstabBacklog, tcpEStatsListenerHCSynRcvd=tcpEStatsListenerHCSynRcvd, tcpEStatsStackWinScaleRcvd=tcpEStatsStackWinScaleRcvd, tcpEStatsPerfOptionalGroup=tcpEStatsPerfOptionalGroup, tcpEStatsConformance=tcpEStatsConformance, tcpEStatsPerfHCDataOctetsOut=tcpEStatsPerfHCDataOctetsOut, tcpEStatsStackCurTimeoutCount=tcpEStatsStackCurTimeoutCount, tcpEStatsListenerInitial=tcpEStatsListenerInitial, tcpEStatsStackNagle=tcpEStatsStackNagle, tcpEStatsAppCurAppRQueue=tcpEStatsAppCurAppRQueue, tcpEStatsPerfElapsedMicroSecs=tcpEStatsPerfElapsedMicroSecs, tcpEStatsStackCurReasmQueue=tcpEStatsStackCurReasmQueue, tcpEStatsStackSubsequentTimeouts=tcpEStatsStackSubsequentTimeouts, tcpEStatsStackECN=tcpEStatsStackECN, tcpEStatsAppHCGroup=tcpEStatsAppHCGroup, tcpEStatsConnTableLatency=tcpEStatsConnTableLatency, tcpEStatsPathDupAckEpisodes=tcpEStatsPathDupAckEpisodes, tcpEStatsStackMinSsthresh=tcpEStatsStackMinSsthresh, tcpEStatsPathMaxRTT=tcpEStatsPathMaxRTT, tcpEStatsMIB=tcpEStatsMIB, tcpEStatsPathRetranThresh=tcpEStatsPathRetranThresh, tcpEStatsConnectIdGroup=tcpEStatsConnectIdGroup, tcpEStatsTuneLimSsthresh=tcpEStatsTuneLimSsthresh, tcpEStatsPerfSndLimTransCwnd=tcpEStatsPerfSndLimTransCwnd, tcpEStatsPerfCurRTO=tcpEStatsPerfCurRTO, tcpEStatsPathTable=tcpEStatsPathTable, PYSNMP_MODULE_ID=tcpEStatsMIB, tcpEStatsAppSndMax=tcpEStatsAppSndMax, tcpEStatsListenerHCGroup=tcpEStatsListenerHCGroup, tcpEStatsPathIpTtl=tcpEStatsPathIpTtl, tcpEStatsStackCongAvoid=tcpEStatsStackCongAvoid, tcpEStatsPathGroup=tcpEStatsPathGroup, tcpEStatsStackSndInitial=tcpEStatsStackSndInitial, tcpEStatsPathPostCongSumRTT=tcpEStatsPathPostCongSumRTT, tcpEStatsPathMinRTT=tcpEStatsPathMinRTT, tcpEStats=tcpEStats, tcpEStatsPathPreCongSumRTT=tcpEStatsPathPreCongSumRTT, tcpEStatsPathDupAcksOut=tcpEStatsPathDupAcksOut, tcpEStatsStackCongOverCount=tcpEStatsStackCongOverCount, tcpEStatsPathOptionalGroup=tcpEStatsPathOptionalGroup, tcpEStatsNotificationsGroup=tcpEStatsNotificationsGroup, tcpEStatsPerfMaxPipeSize=tcpEStatsPerfMaxPipeSize, tcpEStatsListenerEntry=tcpEStatsListenerEntry, tcpEStatsPerfSndLimTransRwin=tcpEStatsPerfSndLimTransRwin, tcpEStatsPerfGroup=tcpEStatsPerfGroup, tcpEStatsListenerHCAccepted=tcpEStatsListenerHCAccepted, tcpEStatsTuneLimCwnd=tcpEStatsTuneLimCwnd, tcpEStatsPerfElapsedSecs=tcpEStatsPerfElapsedSecs, tcpEStatsListenerStartTime=tcpEStatsListenerStartTime, tcpEStatsPerfCurRwinSent=tcpEStatsPerfCurRwinSent, tcpEStatsPathNonRecovDAEpisodes=tcpEStatsPathNonRecovDAEpisodes, tcpEStatsStackMaxRetxQueue=tcpEStatsStackMaxRetxQueue, tcpEStatsStackSoftErrors=tcpEStatsStackSoftErrors, tcpEStatsStackWinScaleSent=tcpEStatsStackWinScaleSent, tcpEStatsListenerTableLastChange=tcpEStatsListenerTableLastChange, tcpEStatsPerfDataSegsOut=tcpEStatsPerfDataSegsOut, tcpEStatsCompliances=tcpEStatsCompliances, tcpEStatsStackActiveOpen=tcpEStatsStackActiveOpen, tcpEStatsPerfCurRwinRcvd=tcpEStatsPerfCurRwinRcvd, tcpEStatsAppThruOctetsReceived=tcpEStatsAppThruOctetsReceived, tcpEStatsPerfDataOctetsOut=tcpEStatsPerfDataOctetsOut, tcpEStatsListenerCurConns=tcpEStatsListenerCurConns, tcpEStatsScalar=tcpEStatsScalar, tcpEStatsStackOptionalGroup=tcpEStatsStackOptionalGroup)
